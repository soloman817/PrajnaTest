<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Prajna</name></assembly>
<members>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.RightOuterJoinByMergeAfterBinSortByKey``4(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.CSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},System.Func{System.Nullable{``1},``2,``3})">
<summary>
 Right outer join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.RightOuterJoinByMergeAfterBinSortByKey``4(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.CSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},System.Func{``1,``2,``3})">
<summary>
 Right outer join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.RepartitionPByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Core.DParam,System.Func{``0,System.Int32})">
<summary>
 Apply a partition function, repartition elements by the key across nodes in the cluster according to the setting specified by &quot;param&quot;.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.RepartitionNByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Int32,System.Func{``0,System.Int32})">
<summary>
 Apply a partition function, repartition elements by key into &apos;numPartitions&quot; partitions across nodes in the cluster.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.RepartitionByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Func{``0,System.Int32})">
<summary>
 Apply a partition function, repartition elements across nodes in the cluster. The number of partitions remains unchanged.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.ReduceByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Func{``1,``1,``1})">
 <summary>
 Aggregate all values of a unique key of the DKV togeter. Caution: as this function uses mapreduce, the network cost is not negligble. If the aggregated result is to be returned to the client, 
 rather than further used in the cluster, the .fold function should be considered instead for performance. 
 </summary>
 <param name="reduceFunc"> Reduce Function, see Seq.reduce for examples </param>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.ParallelMapByValue``3(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Func{``1,System.Threading.Tasks.Task{``2}})">
 <summary>
 Map DKV by value, in which func is an Task&lt;_> function that may contains asynchronous operation. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.MapByValue``3(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Func{``1,``2})">
<summary>
 Create a new dataset by transforming only the value of the original dataset
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.LeftOuterJoinByMergeAfterBinSortByKey``4(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.CSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},System.Func{``1,System.Nullable{``2},``3})">
<summary>
 Left outer join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.LeftOuterJoinByMergeAfterBinSortByKey``4(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.CSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},System.Func{``1,``2,``3})">
<summary>
 Left outer join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.InnerJoinByMergeAfterBinSortByKey``4(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.CSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},System.Func{``1,``2,``3})">
<summary>
 Inner join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.GroupByKeyN``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Int32)">
 <summary> Group all values of the same key to a List. 
 </summary> 
 <param name="numSerialization"> The collection size used before sending over network to improve efficiency </param>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.GroupByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}})">
<summary>
 Group all values of the same key to a List. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.FilterByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Func{``0,System.Boolean})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate on key returns true.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.BinSortPByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},Prajna.Core.DParam,System.Func{``0,System.Int32},System.Collections.Generic.IComparer{``0})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key across nodes in the cluster according to the setting specified by "param".
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.BinSortNByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Int32,System.Func{``0,System.Int32},System.Collections.Generic.IComparer{``0})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key into 'numPartitions" partitions across nodes in the cluster.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DKVMemberExtensionsToDSet.BinSortByKey``2(Prajna.Api.CSharp.DSet{System.Tuple{``0,``1}},System.Func{``0,System.Int32},System.Collections.Generic.IComparer{``0})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key across nodes in the cluster. The number of partitions remains unchanged.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="T:Prajna.Api.CSharp.DKVMemberExtensionsToDSet">
<summary>
 Extension member functions for DSet&lt;Tuple&lt;&apos;K,&apos;V&gt;&gt;
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Version(System.DateTime)">
<summary>
 Get and Set version 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.TypeOfLoadBalancer(Prajna.Core.LoadBalanceAlgorithm)">
<summary>
 Get or Set Load Balancer
 Note that the change will affect Partitioner
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.StorageType(Prajna.Core.StorageKind)">
<summary>
 Storage Type, which include StorageMedia and IndexMethod
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.SerializationLimit(System.Int32)">
<summary>
 Number of record in a collection during data analytical jobs. 
 This parameter will not change number of record in an existing collection of a DSet. To change the 
 number of record of an existing collection, please use RowsReorg(). 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.SendingQueueLimit(System.Int32)">
<summary>
 Sender flow control, DSet/DStream limits the total sending queue to SendingQueueLimit
 If it is communicating with N peer, each peer, the sending queue limit is SendingQueueLimit/N
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.PreGroupByReserialization(System.Int32)">
<summary>
 In BinSort/MapReduce, indicate whether need to regroup collection before sending a collection of data across network 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.PostGroupByReserialization(System.Int32)">
<summary>
 In BinSort/MapReduce, indicate the collection size after the a collection of data is received from network  
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.PeerRcvdSpeedLimit(System.Int64)">
<summary>
 Flow control, limits the total bytes send out to PeerRcvdSpeedLimit
 If it is communicating with N peer, each peer, the sending queue limit is PeerRcvdSpeedLimit/N
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Password(System.String)">
<summary>
 Password that will be hashed and used for triple DES encryption and decryption of data. 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.NumReplications(System.Int32)">
<summary>
 Required number of replications for durability
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.NumPartitions(System.Int32)">
<summary>
 Number of partitions  
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.NumParallelExecution(System.Int32)">
<summary>
 Maximum number of parallel threads that will execute the data analytic jobs in a remote container. 
 If 0, the remote container will determine the number of parallel threads used according to its computation and memory resource
 available. 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Name(System.String)">
<summary>
 Name of the DSet
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.IsPartitionByKey(System.Boolean)">
<summary>
 Is the partition of DSet formed by a key function that maps a data item to an unique partition
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.ContentKey(System.UInt64)">
<summary>
 Set a content key for DSet that governs partition mapping, 
 For two DSets that have the same content key, a single key will be mapped uniquely to a partition
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Cluster(Prajna.Core.Cluster)">
<summary>
 Get and Set Cluster 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.VersionString">
<summary>
 Represent version in a string for display 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Version">
<summary>
 Get and Set version 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.TypeOfLoadBalancer">
<summary>
 Get or Set Load Balancer
 Note that the change will affect Partitioner
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.StorageType">
<summary>
 Storage Type, which include StorageMedia and IndexMethod
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.SizeInBytes">
<summary>
 Get the size of all key-values or blobs in DSet
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.SerializationLimit">
<summary>
 Number of record in a collection during data analytical jobs. 
 This parameter will not change number of record in an existing collection of a DSet. To change the 
 number of record of an existing collection, please use RowsReorg(). 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.SendingQueueLimit">
<summary>
 Sender flow control, DSet/DStream limits the total sending queue to SendingQueueLimit
 If it is communicating with N peer, each peer, the sending queue limit is SendingQueueLimit/N
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.PreGroupByReserialization">
<summary>
 In BinSort/MapReduce, indicate whether need to regroup collection before sending a collection of data across network 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.PostGroupByReserialization">
<summary>
 In BinSort/MapReduce, indicate the collection size after the a collection of data is received from network  
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.PeerRcvdSpeedLimit">
<summary>
 Flow control, limits the total bytes send out to PeerRcvdSpeedLimit
 If it is communicating with N peer, each peer, the sending queue limit is PeerRcvdSpeedLimit/N
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Password">
<summary>
 Password that will be hashed and used for triple DES encryption and decryption of data. 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.NumReplications">
<summary>
 Required number of replications for durability
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.NumPartitions">
<summary>
 Number of partitions  
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.NumParallelExecution">
<summary>
 Maximum number of parallel threads that will execute the data analytic jobs in a remote container. 
 If 0, the remote container will determine the number of parallel threads used according to its computation and memory resource
 available. 
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Name">
<summary>
 Name of the DSet
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.IsPartitionByKey">
<summary>
 Is the partition of DSet formed by a key function that maps a data item to an unique partition
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.ContentKey">
<summary>
 Set a content key for DSet that governs partition mapping, 
 For two DSets that have the same content key, a single key will be mapped uniquely to a partition
</summary>
</member>
<member name="P:Prajna.Api.CSharp.DSet`1.Cluster">
<summary>
 Get and Set Cluster 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.ToIEnumerable">
<summary>
 Convert DSet to an IEnumerable&lt;&apos;U&gt;
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Store(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Store an IEnumerable to a persisted DSet
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Split4``4(System.Func{`0,``0},System.Func{`0,``1},System.Func{`0,``2},System.Func{`0,``3})">
 <summary>
 Correlated split a dataset to four, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 They can be combined later by Map4 transforms. 
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Split3``3(System.Func{`0,``0},System.Func{`0,``1},System.Func{`0,``2})">
 <summary>
 Correlated split a dataset to three, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 They can be combined later by Map3 transforms. 
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Split2``2(System.Func{`0,``0},System.Func{`0,``1})">
 <summary>
 Correlated split a dataset to two, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 They can be combined later by Map2 transforms. 
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SourceN(System.Int32,System.Func{System.Int32,System.Collections.Generic.IEnumerable{`0}})">
 <summary> 
 Generate a distributed dataset through customerized seq functional delegates running on each of the machine. 
 Each node runs num local instance of the functional delegates, each of which forms one partition of the dataset.
 The number of partitions of dataset is N * num, where N is the number of the nodes in the cluster, and num is the number of partitions per node. 
 The NumReplications is 1. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. </summary>
 <param name="sourceNSeqFunc"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set. </param>
 <remarks> See code example DistributedLogAnalysis </remarks>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SourceI(System.Int32,System.Func{System.Int32,System.Collections.Generic.IEnumerable{`0}})">
 <summary> 
 Generate a distributed dataset through customerized seq functional delegates running on each of the machine. 
 The number of partitions of dataset is numPartitions. 
 If any node in the cluster is not responding, the partition may be rerun at a different node. </summary>
 <param name="sourceISeqFunc"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set, the input parameter is the index (0 based)of the partition.  </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Source(System.Func{System.Collections.Generic.IEnumerable{`0}})">
 <summary> 
 Generate a distributed dataset through a customerized seq functional delegate running on each of the machine. 
 Each node runs a local instance of the functional delegate, which generates a seq('U) that forms one partition of DSet('U).
 The number of partitions of DSet('U) is N, which is the number of the nodes in the cluster. The NumReplications is 1. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegate in that node. </summary>
 <param name="sourceSeqFun"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set. </param>
 <remarks> See code example DistributedLogAnalysis </remarks>
 <return> generated DSet('U) </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SaveWithMonitor``3(System.Func{`0,System.Boolean},System.Action{`0},``0,``1)">
<summary>
 Save the DSet to the storage specifed by storageKind with name &quot;name&quot;. 
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
 Note: make it public when we support more than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SaveToHDDWithMonitor(System.Func{`0,System.Boolean},System.Action{`0})">
<summary>
 Save the DSet to HDD. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SaveToHDDByNameWithMonitor(System.Func{`0,System.Boolean},System.Action{`0},System.String)">
<summary>
 Save the DSet to HDD using &quot;name&quot;. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SaveToHDDByName(System.String)">
<summary>
 Save the DSet to HDD using &quot;name&quot;. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.SaveToHDD">
<summary>
 Save the DSet to HDD. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Save``3(``0,``1)">
<summary>
 Save the DSet to the storage specifed by storageKind with name &quot;name&quot;. This is an action.
 Note: make it public when we support more than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.RowsSplit">
<summary>
 Reorganization collection of a dataset so that each collection has a single row. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.RowsReorg(System.Int32)">
<summary>
 Reorganization collection of a dataset. 
 If numRows = 1, the dataset is split into one row per collection. 
 If numRows = Int32.MaxValue, the data set is merged so that all rows in a partition is grouped into a single collection. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.RowsMergeAll">
<summary>
 merge all rows of a partition into a single collection object
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.RepartitionP(Prajna.Core.DParam,System.Func{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster according to the setting specified by &quot;param&quot;.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.RepartitionN(System.Int32,System.Func{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset into &apos;numPartitions&quot; partitions across nodes in the cluster.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Repartition(System.Func{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster. The number of partitions remains unchanged.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.ReorgWDegree(System.Int32)">
<summary>
 Reorganization collection in a dataset to accommodate a certain parallel execution degree. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Reduce(System.Func{`0,`0,`0})">
 <summary>
 Reduces the elements using the specified 'reducer' function
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.ParallelMapi``1(System.Func{System.Int32,System.Int64,`0,System.Threading.Tasks.Task{``0}})">
 <summary>
 Map DSet , in which func is an Task&lt;_> function that may contains asynchronous operation. 
 The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.ParallelMap``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
 <summary>
 Map DSet , in which func is an Task&lt;_> function that may contains asynchronous operation. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Multicast">
<summary>
 Multicast a DSet over network, replicate its content to all peers in the cluster. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Mix4``3(Prajna.Api.CSharp.DSet{``0},Prajna.Api.CSharp.DSet{``1},Prajna.Api.CSharp.DSet{``2})">
 <summary> 
 Mixing four DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Mix3``2(Prajna.Api.CSharp.DSet{``0},Prajna.Api.CSharp.DSet{``1})">
 <summary> 
 Mixing three DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Mix2``1(Prajna.Api.CSharp.DSet{``0})">
 <summary> 
 Mixing two DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Mix``1(Prajna.Api.CSharp.DSet{``0})">
 <summary> 
 Mixing two DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Merge(System.Collections.Generic.IEnumerable{Prajna.Api.CSharp.DSet{`0}})">
 <summary> 
 Merge the content of multiple dataset into a single dataset. The original dataset become partitions of the resultant dataset. 
 This can be considered as merge dataset by rows, and all dataset have the same column structure. </summary>
 <param name="source"> Source dataset </param>
 <return> Merged dataset </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Mapi``1(System.Func{System.Int32,System.Int64,`0,``0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.MapReducePWithPartitionFunction``3(Prajna.Core.DParam,System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Func{``0,System.Int32},System.Func{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="param"> Controls the settings for the map reduce </param>
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="partFunc"> After map, used for user defined repartition </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.MapReduceP``3(Prajna.Core.DParam,System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Func{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="param"> Controls the settings for the map reduce </param>
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param>  
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.MapReduce``3(System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Func{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param>  
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.MapByCollection``1(System.Func{`0[],``0[]})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each collection of the elements 
 of the dataset. In the input DSet, a parttition can have multiple collections, 
 the size of the which is determined by the SerializationLimit of the cluster.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Map4``4(System.Func{`0,``0,``1,``2,``3},Prajna.Api.CSharp.DSet{``0},Prajna.Api.CSharp.DSet{``1},Prajna.Api.CSharp.DSet{``2})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the four DSets pairwise
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Map3``3(System.Func{`0,``0,``1,``2},Prajna.Api.CSharp.DSet{``0},Prajna.Api.CSharp.DSet{``1})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the three DSets pairwise
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Map2``2(System.Func{`0,``0,``1},Prajna.Api.CSharp.DSet{``0})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the two DSets pairwise
 The two DSet must have the same partition mapping structure and same number of element (e.g.), established via Split.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Map``1(System.Func{`0,``0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function will be applied per collection as the dataset is being distributedly iterated. 
 The entire dataset never materialize entirely. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.LocalIter(System.Action{`0})">
<summary>
 Read DSet back to local machine and apply a function on each value. Caution: the iter function will be executed locally as the entire DSet is read back. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.LoadSource">
 <summary>
 Trigger to load metadata. 
 </summary>
 <returns> Dataset with loaded metadata. </returns>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.LazySaveToHDDByName(System.String)">
<summary>
 Lazily save the DSet to HDD using &quot;name&quot;. 
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.LazySaveToHDD">
<summary>
 Lazily save the DSet to HDD.
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.LazySave``3(``0,``1)">
<summary>
 Lazily save the DSet to the storage specifed by storageKind with name &quot;name&quot;. 
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
 Note: make it public when we support more than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Iter(System.Action{`0})">
<summary>
 Applies a function &apos;iterFunc&apos; to each element
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.InitS(System.Func{System.Tuple{System.Int32,System.Int32},`0},System.Int32)">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate.
 </summary> 
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSize"> Size of each partition </param> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.InitN(System.Func{System.Tuple{System.Int32,System.Int32},`0},System.Func{System.Int32,System.Int32,System.Int32})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate, using
 a given number of parallel execution per node.
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSizeFunc"> The functional delegate that returns the size of the partition,  the integer index passed to the function 
 indicates the partition. 
 </param> 
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Init(System.Func{System.Tuple{System.Int32,System.Int32},`0},System.Func{System.Int32,System.Int32})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate.
 </summary> 
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSizeFunc"> The functional delegate that returns the size of the partition,  the integer index passed to the function 
 indicates the partition </param> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.ImportN(Prajna.Service.ContractServersInfo,System.String[])">
 <summary> 
 Generate a distributed dataset by importing customerized functional delegates from a local contract store. The imported functional delegate 
 is usually exported by another service (either in the same remote container or in anotherPrajna remote container. 
 Each node runs multiple local instance of the functional delegates, each of which forms one partition of the dataset.
 The number of partitions of dataset is N * num , where N is the number of the nodes in the cluster, and num is the number of contracts 
 in the contract list. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. 
 </summary>
 <param name="server"> The servers infor from which the contracts are imported. </param>
 <param name="importNames"> The names of the contracts that are to be imported. </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Import(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Generate a distributed dataset by importing a customerized functional delegate from a local contract store. The imported functional delegate 
 is usually exported by another service (either in the same remote container or in anotherPrajna remote container. 
 Each node runs one local instance of the functional delegate, which forms one partition of the dataset.
 The number of partitions of dataset is N, where N is the number of the nodes in the cluster. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. 
 </summary>
 <param name="server"> The servers infor from which the contracts are imported. </param>
 <param name="importName"> The name of the contract that is attached to the sequence functional delegate. </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Identity">
<summary>
 Identity Mapping, the new DSet is the same as the old DSet, with an encode function installed.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.FoldWithCommonStatePerNode``1(System.Func{``0,`0,``0},System.Func{``0,``0,``0},``0)">
 <summary>
 Fold the entire DSet with a fold function, an aggregation function, and an initial state. The initial state is broadcasted to each node, 
 and shared across partition within the node.  
 Within each partition, the elements are folded into the state variable using 'folder' function. Then 'aggrFunc' is used to aggregate the resulting
 state variables from all partitions to a single state.
 </summary>
 <param name="folder"> update the state given the input elements </param>
 <param name="aggrFunc"> aggregate the state from different partitions to a single state variable.</param>
 <param name="state"> initial state for each partition </param>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Fold``1(System.Func{``0,`0,``0},System.Func{``0,``0,``0},``0)">
 <summary>
 Fold the entire DSet with a fold function, an aggregation function, and an initial state. The initial state is deserialized (separately) for each partition. 
 Within each partition, the elements are folded into the state variable using 'folder' function. Then 'aggrFunc' is used to aggregate the resulting
 state variables from all partitions to a single state.
 </summary>
 <param name="folder"> update the state given the input elements </param>
 <param name="aggrFunc"> aggregate the state from different partitions to a single state variable.</param>
 <param name="state"> initial state for each partition </param>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Filter(System.Func{`0,System.Boolean})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate returns true.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.ExecuteN(System.Int32,System.Action{System.Int32})">
 <summary> 
 Execute num distributed customerized functional delegates on each of the machine. 
 The functional delegate is running remotely on each node. If any node in the cluster is not responding, the functional delegates do not run on that node. </summary>
 <param name="num"> The number of instances run on each of the node. </param>
 <param name="funcN"> The customerized functional delegate that runs on each remote container, the input integer index (from 0) the instance of the functional delegate runs. </param>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Execute(System.Action)">
 <summary> 
 Execute a distributed customerized functional delegate on each of the machine. 
 The functional delegate is running remotely on each node. If any node in the cluster is not responding, the functional delegate does not run on that node. </summary>
 <param name="func"> The customerized functional delegate that runs on each remote container. </param>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.DistributeN(System.Int32,System.Collections.Generic.IEnumerable{`0})">
 <summary> 
 Span an IEnumerable (dataset) to a distributed dataset by splitting the sequence to NUM * N partitions, with NUM being the number of partitions on each node, 
 and N being the number of nodes in the cluster. Each node get NUM partition of the dataset. 
 </summary>
 <param name="num"> Number of partitions in each node. </param>
 <param name="sourceEnumerable"> Source dataset. </param>
 <remarks> See code example DistributedKMeans. </remarks>
 <return> Generated dataset. </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Distribute(System.Collections.Generic.IEnumerable{`0})">
 <summary> 
 Span an IEnumerable (dataset) to a distributed dataset by splitting the sequence to N partitions, with N being the number of nodes in the cluster. 
 Each node get one partition of the dataset. The number of partitions of the distributed dataset is N, which is the number of the active nodes in the cluster. 
 </summary>
 <param name="sourceEnumerable"> Source dataset </param>
 <return> Generated dataset. </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.CrossJoinFold``3(System.Func{`0,``0,``1},System.Func{``2,``1,``2},``2,Prajna.Api.CSharp.DSet{``0})">
 <summary> 
 Cross Join with Fold, for each entry in x:DSet&lt;'U> and x1:DSet&lt;'U1> apply mapFunc:'U->'U1->'U2, and foldFunc: 'S->'U2->'S
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:DSet&lt;'U> and each entry in x1:DSet&lt;'U1>  </param>
 <param name="foldFunc"> The fold function that is executed for each of the map result </param>
 <param name="x1"> The DSet&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.CrossJoinChoose``2(System.Func{`0,``0,System.Nullable{``1}},Prajna.Api.CSharp.DSet{``0})">
 <summary> 
 Cross Join with Filtering, for each entry in x:Dset&lt;'U> and x1:Dset&lt;'U1> apply mapFunc. 
 Filter out all those result that returns null. 
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:Dset&lt;'U> and each entry in x1:Dset&lt;'U1>  </param>
 <param name="x1"> The Dset&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.CrossJoinChoose``2(System.Func{`0,``0,``1},Prajna.Api.CSharp.DSet{``0})">
 <summary> 
 Cross Join with Filtering, for each entry in x:Dset&lt;'U> and x1:Dset&lt;'U1> apply mapFunc
 Filter out all those result that returns null. 
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:Dset&lt;'U> and each entry in x1:Dset&lt;'U1>  </param>
 <param name="x1"> The Dset&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.CrossJoin``2(System.Func{`0,``0,``1},Prajna.Api.CSharp.DSet{``0})">
 <summary> 
 Cross Join, for each entry in x:Dset&lt;'U> and x1:Dset&lt;'U1> apply mapFunc:'U->'U1->'U2
 The resultant set is the product of Dset&lt;'U> and Dset&lt;'U1>
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:Dset&lt;'U> and each entry in x1:Dset&lt;'U1>  </param>
 <param name="x1"> The Dset&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Count">
<summary>
 Count the number of elements(rows) in the DSet 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Collect``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
<summary>
 Applies the given function to each element of the dataset and concatenates all the results. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Choose``1(System.Func{`0,System.Nullable{``0}})">
<summary>
 Applies the given function to each element of the dataset. 
 The new dataset comprised of the results for each element where the function returns some value or null.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Choose``1(System.Func{`0,``0})">
<summary>
 Applies the given function to each element of the dataset. 
 The new dataset comprised of the results for each element where the function returns some value or null.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.CacheInMemory">
<summary>
 Cache DSet content in memory, in raw object form. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.BypassN(System.Int32)">
<summary>
 Bypass the Dset in n ways. One of the DSet is pulled, the other n - 1 DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Bypass4">
<summary>
 Bypass the Dset in 4 ways. One of the DSet is pulled, the other three DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Bypass3">
<summary>
 Bypass the Dset in 3 ways. One of the DSet is pulled, the other two DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Bypass2">
<summary>
 Bypass the Dset in 2 ways. One of the DSet is pulled, the other DSet will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.Bypass">
<summary>
 Bypass the Dset in 2 ways. One of the DSet is pulled, the other DSet will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.BinSortP(Prajna.Core.DParam,System.Func{`0,System.Int32},System.Collections.Generic.IComparer{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset across nodes in the cluster according to the setting specified by "param".
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.BinSortN(System.Int32,System.Func{`0,System.Int32},System.Collections.Generic.IComparer{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset into 'numPartitions" partitions across nodes in the cluster.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.CSharp.DSet`1.BinSort(System.Func{`0,System.Int32},System.Collections.Generic.IComparer{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset across nodes in the cluster. The number of partitions remains unchanged.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="T:Prajna.Api.CSharp.DSet`1">
<summary>
 Generic distributed dataset. If storing the content of DSet to a persisted store, it is highly advisable that &apos;U used is either of .Net system type, 
 or using a customized serializer/deserializer to serialize (&apos;U)[]. Otherwise, the stored data may not be retrievable as the BinaryFormatter may fail 
 to deserialize a class if the associated code has changed.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.Where``1(Prajna.Api.CSharp.DSet{``0},System.Func{``0,System.Boolean})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate returns true.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.SelectMany``2(Prajna.Api.CSharp.DSet{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
<summary>
 Applies the given function to each element of the dataset and concatenates all the results. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.Select``2(Prajna.Api.CSharp.DSet{``0},System.Func{``0,System.Int32,System.Int64,``1})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.Select``2(Prajna.Api.CSharp.DSet{``0},System.Func{``0,``1})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. 
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.GroupBy``4(Prajna.Api.CSharp.DSet{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
<summary>
 Groups the elements of a dataset according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.GroupBy``3(Prajna.Api.CSharp.DSet{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
<summary>
 Groups the elements of a dataset according to a specified key selector function and creates a result value from each group and its key.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.GroupBy``3(Prajna.Api.CSharp.DSet{``0},System.Func{``0,``1},System.Func{``0,``2})">
<summary>
 Groups the elements of a dataset according to a specified key selector function and projects the elements for each group by using a specified function.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.GroupBy``2(Prajna.Api.CSharp.DSet{``0},System.Func{``0,``1})">
<summary>
 Groups the elements of a dataset according to a specified key selector function.
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.AsEnumerable``1(Prajna.Api.CSharp.DSet{``0})">
<summary>
 Returns the dataset as an IEnumerable&lt;&apos;U&gt;
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.Aggregate``1(Prajna.Api.CSharp.DSet{``0},System.Func{``0,``0,``0})">
<summary>
 Reduces the elements using the specified &apos;reducer&apos; function
</summary>
</member>
<member name="M:Prajna.Api.CSharp.Linq.DSetLinqExtensions.Aggregate``2(Prajna.Api.CSharp.DSet{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1})">
<summary>
 Fold the entire DSet with a fold function, an aggregation function, and an initial state. The initial state is deserialized (separately) for each partition. 
 Within each partition, the elements are folded into the state variable using &apos;folder&apos; function. Then &apos;aggrFunc&apos; is used to aggregate the resulting
 state variables from all partitions to a single state.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.RightOuterJoinByMergeAfterBinSortByKey``4(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}})">
<summary>
 Right outer join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.RightOuterJoinByHash``4(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpOption{``1},``2},``3})">
<summary>
 Right join the DKV with another DKV by hash join.
 It assumes this DKV is small and can completely fit into the memory of each single node of the cluster
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.RepartitionPByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32})">
<summary>
 Apply a partition function, repartition elements by the key across nodes in the cluster according to the setting specified by &quot;param&quot;.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.RepartitionNByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32})">
<summary>
 Apply a partition function, repartition elements by key into &apos;numPartitions&quot; partitions across nodes in the cluster.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.RepartitionByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32})">
<summary>
 Apply a partition function, repartition elements across nodes in the cluster. The number of partitions remains unchanged.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.ReduceByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}})">
 <summary>
 Aggregate all values of a unique key of the DKV togeter. Caution: as this function uses mapreduce, the network cost is not negligble. If the aggregated result is to be returned to the client, 
 rather than further used in the cluster, the .fold function should be considered instead for performance. 
 </summary>
 <param name="reduceFunc"> Reduce Function, see Seq.reduce for examples </param>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.ParallelMapByValue``3(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Threading.Tasks.Task{``2}})">
 <summary>
 Map DKV by value, in which func is an Task&lt;_> function that may contains asynchronous operation. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.MapByValue``3(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Create a new dataset by transforming only the value of the original dataset
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.LeftOuterJoinByMergeAfterBinSortByKey``4(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``2},``3}})">
<summary>
 Left outer join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.LeftOuterJoinByHash``4(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``3})">
<summary>
 Left join the DKV with another DKV by hash join.
 It assumes this DKV is small and can completely fit into the memory of each single node of the cluster
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.InnerJoinByMergeAfterBinSortByKey``4(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{``0,``2}},System.Collections.Generic.IComparer{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}})">
<summary>
 Inner join the DKV with another DKV by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.InnerJoinByHash``4(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,``2},``3})">
<summary>
 Inner join the DKV with another DKV by hash join.
 It assumes this DKV is small and can completely fit into the memory of each single node of the cluster
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.GroupByKeyN``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},System.Int32)">
 <summary> Group all values of the same key to a List. 
 </summary> 
 <param name="numSerialization"> The collection size used before sending over network to improve efficiency </param>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.GroupByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}})">
<summary>
 Group all values of the same key to a List. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.FilterByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate on key returns true.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.BinSortPByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},System.Collections.Generic.IComparer{``0})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key across nodes in the cluster according to the setting specified by "param".
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.BinSortNByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},System.Collections.Generic.IComparer{``0})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key into 'numPartitions" partitions across nodes in the cluster.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.BinSortByKey``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},System.Collections.Generic.IComparer{``0})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key across nodes in the cluster. The number of partitions remains unchanged.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DKVExtensionsToDSet.AsyncMapByValue``3(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Map DKV by value, in which func is an async function so that all data in a serialization block will be executed with Async.Parallel 
</summary>
</member>
<member name="T:Prajna.Api.FSharp.DKVExtensionsToDSet">
<summary>
 Extension member functions for DSet&lt;&apos;K*&apos;V&gt;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.rightOuterJoinByMergeAfterBinSortByKey``2(System.Collections.Generic.IComparer{`0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{`1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,``0}})">
<summary>
 Right outer join the DKV &apos;x&apos; with DKV &apos;x1&apos; by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.rightOuterJoinByHash``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpOption{`1},``0},``1},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,``0}})">
<summary>
 Right join the two DKVs by hash join.
 It assumes the &apos;probeDKV&apos; is small and can completely fit into the memory of of each single node of the cluster
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.repartitionPByKey(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Apply a partition function, repartition elements by the key across nodes in the cluster according to the setting specified by &quot;param&quot;.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.repartitionNByKey(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Apply a partition function, repartition elements by key into &apos;numPartitions&quot; partitions across nodes in the cluster.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.repartitionByUniqueKey``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Map element to one unique key, and repartition the DKV to ensure that each 
 unique key is mapped to a different partition 
 Note: This operation triggers the evaluation of all previous transformations up to this point.
       It&apos;s different from other transformations/actions. 
       Make it private for now, user can implement it by herself if that&apos;s what wanted.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.repartitionByKey(Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Apply a partition function, repartition elements across nodes in the cluster. The number of partitions remains unchanged.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.reduceByKey(Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`1,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
 <summary>
 Aggregate all values of a unique key of the DKV togeter. Caution: as this function uses mapreduce, the network cost is not negligble. If the aggregated result is to be returned to the client, 
 rather than further used in the cluster, the .fold function should be considered instead for performance. 
 </summary>
 <param name="reduceFunc"> Reduce Function, see Seq.reduce for examples </param>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.parallelMapByValue``1(Microsoft.FSharp.Core.FSharpFunc{`1,System.Threading.Tasks.Task{``0}},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
 <summary>
 Map DKV by value, in which func is an Task&lt;_> function that may contains asynchronous operation. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.mapByValue``1(Microsoft.FSharp.Core.FSharpFunc{`1,``0},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Create a new dataset by transforming only the value of the original dataset
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.leftOuterJoinByMergeAfterBinSortByKey``2(System.Collections.Generic.IComparer{`0},Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},``1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,``0}})">
<summary>
 Left outer join DKV &apos;x&apos; with DKV &apos;x1&apos; by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.leftOuterJoinByHash``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`1,Microsoft.FSharp.Core.FSharpOption{``0}},``1},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,``0}})">
<summary>
 Left join the two DKVs by hash join.
 It assumes the &apos;probeDKV&apos; is small and can completely fit into the memory of of each single node of the cluster
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.innerJoinByMergeAfterBinSortByKey``2(System.Collections.Generic.IComparer{`0},Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,``0}})">
<summary>
 Inner join the two DKVs by merge join at each partition.
 It assumes that both DKVs have already been bin sorted by key (using one of the BinSortByKey methods). 
 The bin sorts should have partitioned the two DKVs into the same number of paritions. For elements with the 
 same key, they should have been placed into the same parition.
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.innerJoinByHash``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`1,``0},``1},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}},Prajna.Api.FSharp.DSet{System.Tuple{`0,``0}})">
<summary>
 Inner join the two DKVs by hash join.
 It assumes the &apos;probeDKV&apos; is small and can completely fit into the memory of of each single node of the cluster
 Please refer to http://en.wikipedia.org/wiki/Join_(SQL) on the join operators.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.groupByValue(Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Group all values that correspond to a similar key in a partition to a List function
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.groupByKeyN(System.Int32,Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
 <summary> Group all values of the same key to a List. 
 </summary> 
 <param name="serializationNum"> The collection size used before sending over network to improve efficiency </param>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.groupByKey(Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Group all values of the same key to a List. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.filterByKey(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate on key returns true.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.binSortPByKey(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key across nodes in the cluster according to the setting specified by "param".
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.binSortNByKey(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key into 'numPartitions" partitions across nodes in the cluster.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.binSortByKey(Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
 <summary> 
 Bin sort the DKV by key.
 Apply a partition function, repartition elements by key across nodes in the cluster. The number of partitions remains unchanged.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary>  
</member>
<member name="M:Prajna.Api.FSharp.DKV`2.asyncMapByValue``1(Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Control.FSharpAsync{``0}},Prajna.Api.FSharp.DSet{System.Tuple{`0,`1}})">
<summary>
 async map DKV by value
</summary>
</member>
<member name="T:Prajna.Api.FSharp.DKV`2">
<summary>
 Functions for DSet&lt;&apos;U&gt; when &apos;U represents a key-value pair with type &apos;K*&apos;V
</summary>
</member>
<member name="F:Prajna.Api.FSharp.DSet`1.Action@">
<summary>
 Action associated with the current DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.tryFind(Prajna.Core.Cluster,System.String)">
 <summary> 
 Find dataset with name that matches the search pattern.</summary>
 <param name="cluster"> Find the DSet that are on the cluster </param>
 <param name="searchPattern"> Find DSet with name that matches the search Patterns </param>
 <return> DSet[] </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.toSeq(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Convert DSet to a sequence seq&lt;&apos;U&gt;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.toBase(Prajna.Api.FSharp.DSet{`0})">
<summary>
 to base class
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.store(Prajna.Api.FSharp.DSet{`0},System.Collections.Generic.IEnumerable{`0})">
<summary>
 Store a sequence to a persisted DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.split4``4(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{`0,``1},Microsoft.FSharp.Core.FSharpFunc{`0,``2},Microsoft.FSharp.Core.FSharpFunc{`0,``3},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Correlated split a dataset to four, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 They can be combined later by Map4 transforms. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.split3``3(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{`0,``1},Microsoft.FSharp.Core.FSharpFunc{`0,``2},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Correlated split a dataset to three, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.split2``2(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{`0,``1},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Correlated split a dataset to two, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.sourceN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{`0}},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Generate a distributed dataset through customerized seq functional delegates running on each of the machine. 
 Each node runs num local instance of the functional delegates, each of which forms one partition of the dataset.
 The number of partitions of dataset is N * num, where N is the number of the nodes in the cluster, and num is the number of partitions per node. 
 The NumReplications is 1. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. </summary>
 <param name="sourceNSeqFunc"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set. </param>
 <remarks> See code example DistributedLogAnalysis </remarks>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.sourceI(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{`0}},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Generate a distributed dataset through customerized seq functional delegates running on each of the machine. 
 The number of partitions of dataset is numPartitions. 
 If any node in the cluster is not responding, the partition may be rerun at a different node. </summary>
 <param name="sourceISeqFunc"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set, the input parameter is the index (0 based)of the partition.  </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.source(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{`0}},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Generate a distributed dataset through a customerized seq functional delegate running on each of the machine. 
 Each node runs a local instance of the functional delegate, which generates a seq('U) that forms one partition of DSet('U).
 The number of partitions of DSet('U) is N, which is the number of the nodes in the cluster. The NumReplications is 1. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegate in that node. </summary>
 <param name="sourceSeqFun"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set. </param>
 <remarks> See code example DistributedLogAnalysis </remarks>
 <return> generated DSet('U) </return>
</member>
<member name="P:Prajna.Api.FSharp.DSet`1.PartitionFunc(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0,System.Int32},System.Int32})">
<summary>
 Get and set the partition function, the function takes a Key and an int32 which is the number of partitions in DSet, 
 and return the partition that the key is mapped to. 
 Note: it&apos;s only used in &quot;store&quot; so far, make it temporary for now. Will check whether it&apos;s worth exposing it to allow
       customized partition function here.
</summary>
</member>
<member name="P:Prajna.Api.FSharp.DSet`1.Action(Prajna.Core.DSetAction)">
<summary>
 Action associated with the current DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.saveWithMonitor(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},Prajna.Core.StorageKind,System.String,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Save the DSet to the storage specifed by storageKind with name &quot;name&quot;. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
 Note: make it public when we support mroe than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.saveToHDDWithMonitor(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Save the DSet to HDD. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.saveToHDDByNameWithMonitor(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},System.String,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Save the DSet to HDD using &quot;name&quot;. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.saveToHDDByName(System.String,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Save the DSet to HDD using &quot;name&quot;. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.saveToHDD(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Save the DSet to HDD. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.save(Prajna.Core.StorageKind,System.String,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Save the DSet to the storage specifed by storageKind with name &quot;name&quot;. This is an action.
 Note: make it public when we support mroe than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.rowsSplit(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Reorganization collection of a dataset so that each collection has a single row. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.rowsReorg(System.Int32,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Reorganization collection of a dataset. 
 If numRows = 1, the dataset is split into one row per collection. 
 If numRows = Int32.MaxValue, the data set is merged so that all rows in a partition is grouped into a single collection. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.rowsMergeAll(Prajna.Api.FSharp.DSet{`0})">
<summary>
 merge all rows of a partition into a single collection object
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.repartitionP(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster according to the setting specified by &quot;param&quot;.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.repartitionN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Apply a partition function, repartition elements of dataset into &apos;numPartitions&quot; partitions across nodes in the cluster.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.repartition(Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster. The number of partitions remains unchanged.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.reorgWDegree(System.Int32,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Reorganization collection in a dataset to accommodate a certain parallel execution degree. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.reduce(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,`0}},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Reduces the elements using the specified 'reducer' function
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.printfn``1(Microsoft.FSharp.Core.PrintfFormat{Microsoft.FSharp.Core.FSharpFunc{`0,``0},System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Read DSet back to local machine and apply a function on each value. Caution: the iter function will be executed locally as the entire DSet is read back. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.partitionInNodeParam(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Change partition within a node
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.parallelMapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{``0}}}},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Map DSet , in which func is an Task&lt;_> function that may contains asynchronous operation. 
 The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.parallelMap``1(Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{``0}},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Map DSet , in which func is an Task&lt;_> function that may contains asynchronous operation. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.multicast(Prajna.Api.FSharp.DSet{`0})">
 <summary> Multicast a DSet over network, replicate its content to all peers in the cluster. </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mix4``3(Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1},Prajna.Api.FSharp.DSet{``2})">
 <summary> 
 Mixing four DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mix3``2(Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1})">
 <summary> 
 Mixing three DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mix2``1(Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Mixing two DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mix``1(Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Mixing two DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.merge(System.Collections.Generic.IEnumerable{Prajna.Api.FSharp.DSet{`0}})">
 <summary> 
 Merge the content of multiple dataset into a single dataset. The original dataset become partitions of the resultant dataset. 
 This can be considered as merge dataset by rows, and all dataset have the same column structure. </summary>
 <param name="source"> Source dataset </param>
 <return> Merged dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{`0,``0}}},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mapReducePWithPartitionFunction``3(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2},Prajna.Api.FSharp.DSet{`0})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="param"> Controls the settings for the map reduce </param>
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="partFunc"> After map, used for user defined repartition </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mapReduceP``3(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2},Prajna.Api.FSharp.DSet{`0})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="param"> Controls the settings for the map reduce </param>
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mapReduce``3(Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2},Prajna.Api.FSharp.DSet{`0})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.mapByCollection``1(Microsoft.FSharp.Core.FSharpFunc{`0[],``0[]},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each collection of the elements 
 of the dataset. In the input DSet, a parttition can have multiple collections, 
 the size of the which is determined by the SerializationLimit of the cluster.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.map4``4(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}}},Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1},Prajna.Api.FSharp.DSet{``2})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the four DSets pairwise
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.map3``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the three DSets pairwise
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.map2``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the two DSets pairwise
 The two DSet must have the same partition mapping structure and same number of element (e.g.), established via Split.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.map``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function will be applied per collection as the dataset is being distributedly iterated. 
 The entire dataset never materialize entirely. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.localIter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Read DSet back to local machine and apply a function on each value. Caution: the iter function will be executed locally as the entire DSet is read back. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.loadSource(Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Trigger to load metadata. 
 </summary>
 <returns> Dataset with loaded metadata. </returns>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.lazySaveToHDDByName(System.String,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Lazily save the DSet to HDD using &quot;name&quot;. 
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.lazySaveToHDD(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Lazily save the DSet to HDD.
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.lazySave(Prajna.Core.StorageKind,System.String,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Lazily save the DSet to the storage specifed by storageKind with name &quot;name&quot;. 
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
 Note: make it public when we support mroe than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.iter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Iterate the given function to each element. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.initS(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32},`0},System.Int32,Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate.
 </summary> 
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSize"> Size of each partition </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.initN(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32},`0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32}},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate, using
 a given number of parallel execution per node.
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSizeFunc"> The functional delegate that returns the size of the partition,  the integer index passed to the function 
 indicates the partition. 
 </param> 
 <param name="x"> The DSet to operate on </param>
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.init(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32},`0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate.
 </summary> 
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSizeFunc"> The functional delegate that returns the size of the partition,  the integer index passed to the function 
 indicates the partition </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.importN(Prajna.Service.ContractServersInfo,System.String[],Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Generate a distributed dataset by importing customerized functional delegates from a local contract store. The imported functional delegate 
 is usually exported by another service (either in the same remote container or in anotherPrajna remote container. 
 Each node runs multiple local instance of the functional delegates, each of which forms one partition of the dataset.
 The number of partitions of dataset is N * num , where N is the number of the nodes in the cluster, and num is the number of contracts 
 in the contract list. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. 
 </summary>
 <param name="server"> The servers infor from which the contracts are imported. </param>
 <param name="importNames"> The names of the contracts that are to be imported. </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.import(Prajna.Service.ContractServersInfo,System.String,Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Generate a distributed dataset by importing a customerized functional delegate from a local contract store. The imported functional delegate 
 is usually exported by another service (either in the same remote container or in anotherPrajna remote container. 
 Each node runs one local instance of the functional delegate, which forms one partition of the dataset.
 The number of partitions of dataset is N, where N is the number of the nodes in the cluster. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. 
 </summary>
 <param name="server"> The servers infor from which the contracts are imported. </param>
 <param name="importName"> The name of the contract that is attached to the sequence functional delegate. </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.identity(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Identity Mapping, the new DSet is the same as the old DSet, with an encode function installed.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.groupByValue``2(Prajna.Api.FSharp.DSet{System.Tuple{``0,``1}})">
<summary>
 Group all values that correspond to a similar key in a partition to a List function
</summary>
</member>
<member name="P:Prajna.Api.FSharp.DSet`1.PartitionFunc">
<summary>
 Get and set the partition function, the function takes a Key and an int32 which is the number of partitions in DSet, 
 and return the partition that the key is mapped to. 
 Note: it&apos;s only used in &quot;store&quot; so far, make it temporary for now. Will check whether it&apos;s worth exposing it to allow
       customized partition function here.
</summary>
</member>
<member name="P:Prajna.Api.FSharp.DSet`1.Action">
<summary>
 Action associated with the current DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,Prajna.Api.FSharp.DSet{`0})">
 <summary>
 Fold the entire DSet with a fold function, an aggregation function, and an initial state. The initial state is broadcasted to each partition. 
 Within each partition, the elements are folded into the state variable using 'folder' function. Then 'aggrFunc' is used to aggregate the resulting
 state variables from all partitions to a single state.
 </summary>
 <param name="folder"> 'State -> 'U -> 'State, update the state given the input elements </param>
 <param name="aggrFunc"> 'State -> 'State -> 'State, which aggregate the state from different partitions to a single state variable.</param>
 <param name="state"> initial state for each partition </param>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate returns true.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.executeN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Execute num distributed customerized functional delegates on each of the machine. 
 The functional delegate is running remotely on each node. If any node in the cluster is not responding, the functional delegates do not run on that node. </summary>
 <param name="num"> The number of instances run on each of the node. </param>
 <param name="funcN"> The customerized functional delegate that runs on each remote container, the input integer index (from 0) the instance of the functional delegate runs. </param>
 <remarks> Implemented via x.Source </remarks>
 <return> unit </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.execute(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Execute a distributed customerized functional delegate on each of the machine. 
 The functional delegate is running remotely on each node. If any node in the cluster is not responding, the functional delegate does not run on that node. </summary>
 <param name="func"> The customerized functional delegate that runs on each remote container. </param>
 <remarks> Implemented via x.Source </remarks>
 <return> unit </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.distributeN(System.Int32,System.Collections.Generic.IEnumerable{`0},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Span a sequence (dataset) to a distributed dataset by splitting the sequence to NUM * N partitions, with NUM being the number of partitions on each node, 
 and N being the number of nodes in the cluster. Each node get NUM partition of the dataset. 
 </summary>
 <param name="num"> Number of partitions in each node. </param>
 <param name="sourceSeq"> Source dataset. </param>
 <remarks> See code example DistributedKMeans. </remarks>
 <return> Generated dataset. </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.distribute(System.Collections.Generic.IEnumerable{`0},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Span a sequence (dataset) to a distributed dataset by splitting the sequence to N partitions, with N being the number of nodes in the cluster. 
 Each node get one partition of the dataset. The number of partitions of the distributed dataset is N, which is the number of the active nodes in the cluster. 
 </summary>
 <param name="sourceSeq"> Source dataset </param>
 <remarks> See code example DistributedKMeans </remarks>
 <return> Generated dataset. </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.crossJoinFold``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``2,Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Cross Join with Fold, for each entry in x:DSet&lt;'U> and x1:DSet&lt;'U1> apply mapFunc:'U->'U1->'U2, and foldFunc: 'S->'U2->'S
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:DSet&lt;'U> and each entry in x1:DSet&lt;'U1>  </param>
 <param name="foldFunc"> The fold function that is executed for each of the map result </param>
 <param name="x1"> The DSet&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.crossJoinChoose``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Cross Join with Filtering, for each entry in x:DSet&lt;'U> and x1:DSet&lt;'U1> apply mapFunc:'U->'U1->'U2 option. 
 Filter out all those result that returns None. 
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:DSet&lt;'U> and each entry in x1:DSet&lt;'U1>  </param>
 <param name="x1"> The DSet&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.crossJoin``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Prajna.Api.FSharp.DSet{`0},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Cross Join, for each entry in x:Dset&lt;'U> and x1:Dset&lt;'U1> apply mapFunc:'U->'U1->'U2
 The resultant set is the product of Dset&lt;'U> and Dset&lt;'U1>
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:Dset&lt;'U> and each entry in x1:Dset&lt;'U1>  </param>
 <param name="x1"> The Dset&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.count(Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Count the number of elements(rows) in the DSet </summary>
 <return> number of elments(rows) </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.collect``1(Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{``0}},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Applies the given function to each element of the dataset and concatenates all the results. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.choose``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Applies the given function to each element of the dataset. 
 The new dataset comprised of the results for each element where the function returns Some with some value.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.cacheInSSD(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Cache DSet content in SSD, in bytestream form. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.cacheInMemory(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Cache DSet content in RAM, in raw object form. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.bypassN(System.Int32,Prajna.Api.FSharp.DSet{`0})">
<summary>
 Bypass the Dset in n ways. One of the DSet is pulled, the other n - 1 DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.bypass4(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Bypass the Dset in 4 ways. One of the DSet is pulled, the other three DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.bypass3(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Bypass the Dset in 3 ways. One of the DSet is pulled, the other two DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.bypass2(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Bypass the Dset in 2 ways. One of the DSet is pulled, the other DSet will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.bypass(Prajna.Api.FSharp.DSet{`0})">
<summary>
 Bypass the Dset in 2 ways. One of the DSet is pulled, the other DSet will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.binSortP(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset across nodes in the cluster according to the setting specified by "param".
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.binSortN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset into 'numPartitions" partitions across nodes in the cluster.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.binSort(Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0},Prajna.Api.FSharp.DSet{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset across nodes in the cluster. The number of partitions remains unchanged.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.asyncMapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Control.FSharpAsync{``0}}}},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function is an async function, in which elements within the same collection are parallelly 
 executed with Async.Parallel.
 The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.asyncMap``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Control.FSharpAsync{``0}},Prajna.Api.FSharp.DSet{`0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function is an async function, in which elements within the same collection are parallelly 
 executed with Async.Parallel
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.UseConcurrentQueueCache">
 <summary>
 Change the cache to use Concurrent Queue. Note this function is different from CacheInRAM(), it doesn't attach a cache to the DSet, but rather, it changes the cache behavior of the current DSet. 
 This function should be used for receiving network DSet, either of .Mutlicast, .Partition, etc..
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.ToSeq">
<summary>
 Convert DSet to a sequence seq&lt;&apos;U&gt;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.StoreInternal(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Store a sequence to a persisted DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Store(System.Collections.Generic.IEnumerable{`0},System.Threading.CancellationToken)">
<summary>
 Store a sequence to a persisted DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Store(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Store a sequence to a persisted DSet
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Split4``4(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{`0,``1},Microsoft.FSharp.Core.FSharpFunc{`0,``2},Microsoft.FSharp.Core.FSharpFunc{`0,``3})">
 <summary>
 Correlated split a dataset to four, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Split3``3(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{`0,``1},Microsoft.FSharp.Core.FSharpFunc{`0,``2})">
 <summary>
 Correlated split a dataset to three, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Split2``2(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Core.FSharpFunc{`0,``1})">
 <summary>
 Correlated split a dataset to two, each of which is created by running a functional delegate that maps the element of the original dataset.
 The resultant datasets all have the same partition and collection structure of the original dataset. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SourceN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{`0}})">
 <summary> 
 Generate a distributed dataset through customerized seq functional delegates running on each of the machine. 
 Each node runs num local instance of the functional delegates, each of which forms one partition of the dataset.
 The number of partitions of dataset is N * num, where N is the number of the nodes in the cluster, and num is the number of partitions per node. 
 The NumReplications is 1. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. </summary>
 <param name="sourceNSeqFunc"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set. </param>
 <remarks> See code example DistributedLogAnalysis </remarks>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SourceI(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{`0}})">
 <summary> 
 Generate a distributed dataset through customerized seq functional delegates running on each of the machine. 
 The number of partitions of dataset is numPartitions. 
 If any node in the cluster is not responding, the partition may be rerun at a different node. </summary>
 <param name="sourceISeqFunc"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set, the input parameter is the index (0 based)of the partition.  </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Source(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{`0}})">
 <summary> 
 Generate a distributed dataset through a customerized seq functional delegate running on each of the machine. 
 Each node runs a local instance of the functional delegate, which generates a seq('U) that forms one partition of DSet('U).
 The number of partitions of DSet('U) is N, which is the number of the nodes in the cluster. The NumReplications is 1. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegate in that node. </summary>
 <param name="sourceSeqFun"> Customerized functional delegate that runs on each node, it generates one partition of the distributed data set. </param>
 <remarks> See code example DistributedLogAnalysis </remarks>
 <return> generated DSet('U) </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SendOverNetworkParam(Prajna.Core.DParam)">
 <summary> Send a DSet over network. </summary>
 <param name="param"> Optional control parameter. The relevant parameters are param.Cluster, which specifies that the cluster DSet is sent to. 
 and param.Mapping, which direct which node a certain partition is sent to. </param>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SendOverNetwork">
 <summary> Encode and send a DSet across network. </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SaveWithMonitor(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},Prajna.Core.StorageKind,System.String)">
<summary>
 Save the DSet to the storage specifed by storageKind with name &quot;name&quot;. 
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
 Note: make it public when we support more than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SaveToHDDWithMonitor(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Save the DSet to HDD. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SaveToHDDByNameWithMonitor(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 Save the DSet to HDD using &quot;name&quot;. This is an action.
 Attach a monitor function that select elements that will be fetched to local machine to be iterated by &apos;localIterFunc&apos;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SaveToHDDByName(System.String)">
<summary>
 Save the DSet to HDD using &quot;name&quot;. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SaveToHDD">
<summary>
 Save the DSet to HDD. This is an action.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.SaveToDStream(Prajna.Core.StorageKind,System.String)">
 <summary> 
 Save DSet to a persisted store with a certain name
 </summary>
 <param name="storageKind"> Type of storage that the DSet is stored </param>
 <param name="name"> Name of the new DSet that is persisted </param>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Save(Prajna.Core.StorageKind,System.String)">
<summary>
 Save the DSet to the storage specifed by storageKind with name &quot;name&quot;. This is an action.
 Note: make it public when we support more than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RowsSplit">
<summary>
 Reorganization collection of a dataset so that each collection has a single row. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RowsReorg(System.Int32)">
<summary>
 Reorganization collection of a dataset. 
 If numRows = 1, the dataset is split into one row per collection. 
 If numRows = Int32.MaxValue, the data set is merged so that all rows in a partition is grouped into a single collection. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RowsMergeAll">
<summary>
 merge all rows of a partition into a single collection object
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RepartitionToNodeParam(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RepartitionToNode">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RepartitionP(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster according to the setting specified by &quot;param&quot;.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.RepartitionN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset into &apos;numPartitions&quot; partitions across nodes in the cluster.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Repartition(Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32})">
<summary>
 Apply a partition function, repartition elements of dataset across nodes in the cluster. The number of partitions remains unchanged.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.ReorgWDegree(System.Int32)">
<summary>
 Reorganization collection in a dataset to accommodate a certain parallel execution degree. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Reduce(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,`0}})">
 <summary>
 Reduces the elements using the specified 'reducer' function
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Printfn``1(Microsoft.FSharp.Core.PrintfFormat{Microsoft.FSharp.Core.FSharpFunc{`0,``0},System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>
 Read DSet back to local machine and print each value. Caution: the iter function will be executed locally as the entire DSet is read back. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.PartitionInNodeParam(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32})">
<summary>
 Change Partition within a node
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.ParallelMapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{``0}}}})">
 <summary>
 Map DSet , in which func is an Task&lt;_> function that may contains asynchronous operation. 
 The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.ParallelMap``1(Microsoft.FSharp.Core.FSharpFunc{`0,System.Threading.Tasks.Task{``0}})">
 <summary>
 Map DSet , in which func is an Task&lt;_> function that may contains asynchronous operation. 
 You will need to start the 1st task in the mapping function. Prajna will not be able to start the task for you as the returned
 task may not be the a Task in the creation state. see: http://blogs.msdn.com/b/pfxteam/archive/2012/01/14/10256832.aspx 
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MulticastParam(Prajna.Core.DParam)">
 <summary> Multicast a DSet over network, replicate its content to all peers in the cluster. </summary>
 <param name="param"> Optional control parameter. The relevant parameters are param.Cluster, which specifies that the cluster DSet is sent to. 
 and param.Mapping, which direct which node a certain partition is sent to. </param>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Multicast">
 <summary> Multicast a DSet over network, replicate its content to all peers in the cluster. </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Mix4``3(Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1},Prajna.Api.FSharp.DSet{``2})">
 <summary> 
 Mixing four DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Mix3``2(Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1})">
 <summary> 
 Mixing three DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Mix2``1(Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Mixing two DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Mix``1(Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Mixing two DSets that have the same size and partition layout into a single DSet by operating a function on the individual data (row).
 </summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Merge(System.Collections.Generic.IEnumerable{Prajna.Api.FSharp.DSet{`0}})">
 <summary> 
 Merge the content of multiple dataset into a single dataset. The original dataset become partitions of the resultant dataset. 
 This can be considered as merge dataset by rows, and all dataset have the same column structure. </summary>
 <param name="source"> Source dataset </param>
 <return> Merged dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Mapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{`0,``0}}})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MapReducePWithPartitionFunction``3(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="param"> Controls the settings for the map reduce </param>
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="partFunc"> After map, used for user defined repartition </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MapReduceP``3(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="param"> Controls the settings for the map reduce </param>
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param>  
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MapReduceInRamPWithPartitionFunction``3(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
<summary>
 filter DSet by Key, Value 
 MapReduce Function
 Map: &apos;K,&apos;V -&gt; IEnumerable&lt;&apos;K1,&apos;V1&gt;
 Reduce &apos;K1, List (&apos;V1) -&gt; &lt;&apos;K2, &apos;V2 &gt;
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MapReduce``3(Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Collections.Generic.List{``1}},``2})">
 <summary> MapReduce, see http://en.wikipedia.org/wiki/MapReduce </summary> 
 <param name="mapFunc"> Mapping functional delegate that performs filtering and sorting </param>
 <param name="reduceFunc"> Reduce functional delegate that performs a summary operation </param>  
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MapImpl``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function will be applied per collection as the dataset is being distributedly iterated. 
 The entire dataset never materialize entirely. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.MapByCollection``1(Microsoft.FSharp.Core.FSharpFunc{`0[],``0[]})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each collection of the elements 
 of the dataset. In the input DSet, a parttition can have multiple collections, 
 the size of the which is determined by the SerializationLimit of the cluster.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Map4``4(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}}},Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1},Prajna.Api.FSharp.DSet{``2})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the four DSets pairwise
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Map3``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Prajna.Api.FSharp.DSet{``0},Prajna.Api.FSharp.DSet{``1})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the three DSets pairwise
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Map2``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Prajna.Api.FSharp.DSet{``0})">
<summary>
 Create a new DSet whose elements are the results of applying the given function to the corresponding elements of the two DSets pairwise
 The two DSet must have the same partition mapping structure and same number of element (e.g.), established via Split.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function will be applied per collection as the dataset is being distributedly iterated. 
 The entire dataset never materialize entirely. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.LocalIter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
 <summary>
 Read DSet back to local machine and apply a function on each value. Caution: the iter function will be executed locally as the entire DSet is read back. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.LoadSource">
 <summary>
 Trigger to load metadata. 
 </summary>
 <returns> Dataset with loaded metadata. </returns>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.LazySaveToHDDByName(System.String)">
<summary>
 Lazily save the DSet to HDD using &quot;name&quot;. 
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.LazySaveToHDD">
<summary>
 Lazily save the DSet to HDD.
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.LazySave(Prajna.Core.StorageKind,System.String)">
<summary>
 Lazily save the DSet to the storage specifed by storageKind with name &quot;name&quot;. 
 This is a lazy evaluation. This DSet must be a branch generated by Bypass or a child of such branch.
 The save action will be triggered when a pull happens on other branches generated by Bypass.
 Note: make it public when we support more than one storage kind
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Iter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Applies a function &apos;iterFunc&apos; to each element
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.InitS(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32},`0},System.Int32)">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate.
 </summary> 
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSize"> Size of each partition </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.InitN(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32},`0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32}})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate, using
 a given number of parallel execution per node.
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSizeFunc"> The functional delegate that returns the size of the partition,  the integer index passed to the function 
 indicates the partition. 
 </param> 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Init(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int32,System.Int32},`0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
 <summary>
 Create a distributed dataset on the distributed cluster, with each element created by a functional delegate.
 </summary> 
 <param name="initFunc"> The functional delegate that create each element in the dataset, the integer index passed to the function 
 indicates the partition, and the second integer passed to the function index (from 0) element within the partition. 
 </param> 
 <param name="partitionSizeFunc"> The functional delegate that returns the size of the partition,  the integer index passed to the function 
 indicates the partition </param> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.ImportN(Prajna.Service.ContractServersInfo,System.String[])">
 <summary> 
 Generate a distributed dataset by importing customerized functional delegates from a local contract store. The imported functional delegate 
 is usually exported by another service (either in the same remote container or in anotherPrajna remote container. 
 Each node runs multiple local instance of the functional delegates, each of which forms one partition of the dataset.
 The number of partitions of dataset is N * num , where N is the number of the nodes in the cluster, and num is the number of contracts 
 in the contract list. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. 
 </summary>
 <param name="server"> The servers infor from which the contracts are imported. </param>
 <param name="importNames"> The names of the contracts that are to be imported. </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Import(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Generate a distributed dataset by importing a customerized functional delegate from a local contract store. The imported functional delegate 
 is usually exported by another service (either in the same remote container or in anotherPrajna remote container. 
 Each node runs one local instance of the functional delegate, which forms one partition of the dataset.
 The number of partitions of dataset is N, where N is the number of the nodes in the cluster. 
 If any node in the cluster is not responding, the dataset does not contain the data resultant from the functional delegates in that node. 
 </summary>
 <param name="server"> The servers infor from which the contracts are imported. </param>
 <param name="importName"> The name of the contract that is attached to the sequence functional delegate. </param>
 <return> generated dataset </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.IfSourceIdentity">
<summary>
 Install an identity mapping if the current DSet is the source. This ensures that an encode function is installed on DSet. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Identity">
<summary>
 Identity Mapping, the new DSet is the same as the old DSet, with an encode function installed.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.GetNumberOfPartitions">
<summary>
 Get number of partitions. If partition has not been set, setup the partition
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.FoldWithCommonStatePerNode``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0)">
 <summary>
 Fold the entire DSet with a fold function, an aggregation function, and an initial state. The initial state is broadcasted to each node, and is shared
 across partitions, the elements are folded into the state variable using 'folder' function. Then 'aggrFunc' is used to aggregate the resulting
 state variables from all partitions to a single state.
 </summary>
 <param name="folder"> 'State -> 'U -> 'State, update the state given the input elements </param>
 <param name="aggrFunc"> 'State -> 'State -> 'State, which aggregate the state from different partitions to a single state variable.</param>
 <param name="state"> initial state for each partition </param>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{`0,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0)">
 <summary>
 Fold the entire DSet with a fold function, an aggregation function, and an initial state. The initial state is deserialized (separately) for each partition. 
 Within each partition, the elements are folded into the state variable using 'folder' function. Then 'aggrFunc' is used to aggregate the resulting
 state variables from all partitions to a single state.
 </summary>
 <param name="folder"> 'State -> 'U -> 'State, update the state given the input elements </param>
 <param name="aggrFunc"> 'State -> 'State -> 'State, which aggregate the state from different partitions to a single state variable.</param>
 <param name="state"> initial state for each partition </param>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.FilterImpl(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate returns true.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Creates a new dataset containing only the elements of the dataset for which the given predicate returns true.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.ExecuteN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit})">
 <summary> 
 Execute num distributed customerized functional delegates on each of the machine. 
 The functional delegate is running remotely on each node. If any node in the cluster is not responding, the functional delegates do not run on that node. </summary>
 <param name="num"> The number of instances run on each of the node. </param>
 <param name="funcN"> The customerized functional delegate that runs on each remote container, the input integer index (from 0) the instance of the functional delegate runs. </param>
 <remarks> Implemented via x.Source </remarks>
 <return> unit </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Execute(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary> 
 Execute a distributed customerized functional delegate on each of the machine. 
 The functional delegate is running remotely on each node. If any node in the cluster is not responding, the functional delegate does not run on that node. </summary>
 <param name="func"> The customerized functional delegate that runs on each remote container. </param>
 <remarks> Implemented via x.Source </remarks>
 <return> unit </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.EstablishMerge(System.Collections.Generic.IEnumerable{Prajna.Core.DSet})">
<summary>
 Establish a bypass dependency
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.EstablishHashJoin(Prajna.Core.DSet,Prajna.Core.DSet)">
<summary>
 Establish a hash join dependency
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.EstablishCrossJoin(Prajna.Core.DSet,Prajna.Core.DSet)">
<summary>
 Establish a cross join dependency
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.EstablishCorrelatedMix(System.Collections.Generic.IEnumerable{Prajna.Core.DSet})">
<summary>
 Establish a bypass dependency
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.EstablishBypass(System.Collections.Generic.IEnumerable{Prajna.Core.DSet})">
<summary>
 Establish a bypass dependency
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.EncodeTo">
<summary>
 Encode to a DStream
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.DistributeN(System.Int32,System.Collections.Generic.IEnumerable{`0})">
 <summary> 
 Span a sequence (dataset) to a distributed dataset by splitting the sequence to NUM * N partitions, with NUM being the number of partitions on each node, 
 and N being the number of nodes in the cluster. Each node get NUM partition of the dataset. 
 </summary>
 <param name="num"> Number of partitions in each node. </param>
 <param name="sourceSeq"> Source dataset. </param>
 <remarks> See code example DistributedKMeans. </remarks>
 <return> Generated dataset. </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Distribute(System.Collections.Generic.IEnumerable{`0})">
 <summary> 
 Span a sequence (dataset) to a distributed dataset by splitting the sequence to N partitions, with N being the number of nodes in the cluster. 
 Each node get one partition of the dataset. The number of partitions of the distributed dataset is N, which is the number of the active nodes in the cluster. 
 </summary>
 <param name="sourceSeq"> Source dataset </param>
 <remarks> See code example DistributedKMeans </remarks>
 <return> Generated dataset. </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Derived``1(Prajna.Core.DSetMetadataCopyFlag,System.String)">
<summary>
 Helper function, derive a DSet from the current DSet (used for .Filter, .Map, etc..)
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.CrossJoinFold``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``2,Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Cross Join with Fold, for each entry in x:DSet&lt;'U> and x1:DSet&lt;'U1> apply mapFunc:'U->'U1->'U2, and foldFunc: 'S->'U2->'S
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:DSet&lt;'U> and each entry in x1:DSet&lt;'U1>  </param>
 <param name="foldFunc"> The fold function that is executed for each of the map result </param>
 <param name="x1"> The DSet&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.CrossJoinChoose``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Cross Join with Filtering, for each entry in x:Dset&lt;'U> and x1:Dset&lt;'U1> apply mapFunc:'U->'U1->'U2 option. 
 Filter out all those result that returns None. 
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:Dset&lt;'U> and each entry in x1:Dset&lt;'U1>  </param>
 <param name="x1"> The Dset&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.CrossJoin``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Prajna.Api.FSharp.DSet{``0})">
 <summary> 
 Cross Join, for each entry in x:Dset&lt;'U> and x1:Dset&lt;'U1> apply mapFunc:'U->'U1->'U2
 The resultant set is the product of Dset&lt;'U> and Dset&lt;'U1>
 </summary>
 <param name="mapFunc"> The map function that is executed for the product of each entry in x:Dset&lt;'U> and each entry in x1:Dset&lt;'U1>  </param>
 <param name="x1"> The Dset&lt;'U1>. For performance purpose, it is advisable to assign the smaller DSet as x1. </param>
 <return> DSet </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Count">
 <summary> 
 Count the number of elements(rows) in the DSet </summary>
 <return> number of elments(rows) </return>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Collect``1(Microsoft.FSharp.Core.FSharpFunc{`0,System.Collections.Generic.IEnumerable{``0}})">
<summary>
 Applies the given function to each element of the dataset and concatenates all the results. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Choose``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Applies the given function to each element of the dataset. 
 The new dataset comprised of the results for each element where the function returns Some with some value.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.CacheInRAMList">
<summary>
 Cache the DSet in RAM for later data analytic job use 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.CacheInRAMEnumerable">
<summary>
 Cache the DSet in RAM for later data analytic job use 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.CacheInMemory">
<summary>
 Cache DSet content in memory, in raw object form. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.BypassN(System.Int32)">
<summary>
 Bypass the Dset in n ways. One of the DSet is pulled, the other n - 1 DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Bypass4">
<summary>
 Bypass the Dset in 4 ways. One of the DSet is pulled, the other three DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Bypass3">
<summary>
 Bypass the Dset in 3 ways. One of the DSet is pulled, the other two DSets will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Bypass2">
<summary>
 Bypass the Dset in 2 ways. One of the DSet is pulled, the other DSet will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Bypass">
<summary>
 Bypass the Dset in 2 ways. One of the DSet is pulled, the other DSet will be in push dataflow. 
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.Bypass(System.Int32)">
 <summary>
 Split the DSet in n+1 ways. One of the DSet is pulled, the other n DSet will in push dataflow. 
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.BinSortP(Prajna.Core.DParam,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset across nodes in the cluster according to the setting specified by "param".
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.BinSortN(System.Int32,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset into 'numPartitions" partitions across nodes in the cluster.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.BinSort(Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},System.Collections.Generic.IComparer{`0})">
 <summary> 
 Bin sort the DSet.
 Apply a partition function, repartition elements of dataset across nodes in the cluster. The number of partitions remains unchanged.
 Elements within each partition/bin are sorted using the 'comparer'.
 </summary> 
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.AsyncMapi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Control.FSharpAsync{``0}}}})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function is an async function, in which elements within the same collection are parallelly 
 executed with Async.Parallel.
 The first integer index passed to the function indicates the partition, and the second integer
 passed to the function index (from 0) element within the partition.
</summary>
</member>
<member name="M:Prajna.Api.FSharp.DSet`1.AsyncMap``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Creates a new dataset whose elements are the results of applying the given function to each of the elements 
 of the dataset. The given function is an async function, in which elements within the same collection are parallelly 
 executed with Async.Parallel
</summary>
</member>
<member name="T:Prajna.Api.FSharp.DSet`1">
<summary>
 Generic distributed dataset. If storing the content of DSet to a persisted store, it is highly advisable that &apos;U used is either of .Net system type, 
 or using a customized serializer/deserializer to serialize (&apos;U)[]. Otherwise, the stored data may not be retrievable as the BinaryFormatter may fail 
 to deserialize a class if the associated code has changed.
</summary>
</member>
<member name="T:Prajna.Core.AggregateFunction`1">
<summary>
 Prajna Aggregate functions
 func: State1 State2 -&gt; Aggregated State
</summary>
</member>
<member name="F:Prajna.Core.AssemblyCollection.bNewAssembly@">
<summary>
 If any new dependency has been added to the file.. 
</summary>
</member>
<member name="P:Prajna.Core.AssemblyCollection.bNewAssembly(System.Boolean)">
<summary>
 If any new dependency has been added to the file.. 
</summary>
</member>
<member name="P:Prajna.Core.AssemblyCollection.bNewAssembly">
<summary>
 If any new dependency has been added to the file.. 
</summary>
</member>
<member name="M:Prajna.Core.AssemblyCollection.TryRetrieveAssembly(System.String)">
<summary>
 Try retrieve Assembly
</summary>
</member>
<member name="M:Prajna.Core.AssemblyCollection.ReflectionOnlyLoadFrom(System.String,System.Byte[],System.Boolean)">
<summary>
 Overload Reflection.Assembly.ReflectionOnlyLoadFrom, so that each assembly is only attempted to be loaded once. 
</summary>
</member>
<member name="M:Prajna.Core.AssemblyCollection.GetAllAssemblies">
<summary>
 Get All Assemblies
</summary>
</member>
<member name="M:Prajna.Core.AssemblyCollection.AddAssembly(System.Reflection.Assembly)">
<summary>
 Add Assembly
</summary>
</member>
<member name="F:Prajna.Core.AssemblyEx.Hash@">
<summary>
 For .Net DLL, this can be the public Key token of the DLL. 
</summary>
</member>
<member name="P:Prajna.Core.AssemblyEx.Hash(System.Byte[])">
<summary>
 For .Net DLL, this can be the public Key token of the DLL. 
</summary>
</member>
<member name="P:Prajna.Core.AssemblyEx.Hash">
<summary>
 For .Net DLL, this can be the public Key token of the DLL. 
</summary>
</member>
<member name="M:Prajna.Core.AssemblyEx.Unpack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Unpack assembly from stream 
</summary>
</member>
<member name="M:Prajna.Core.AssemblyEx.Pack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Pack assembly to stream 
</summary>
</member>
<member name="M:Prajna.Core.AssemblyEx.Load">
<summary>
 Load Assembly
</summary>
</member>
<member name="M:Prajna.Core.AssemblyEx.GetAssembly(System.String,System.Byte[],Prajna.Core.AssemblyKind,System.Boolean)">
<summary>
 Is the assembly available locally?
</summary>
</member>
<member name="M:Prajna.Core.AssemblyEx.ConstructLocation``1(``0,System.Byte[])">
<summary>
 Construct folder name for assembly 
</summary>
</member>
<member name="M:Prajna.Core.AssemblyEx.ComputeHash">
<summary>
 Compute hash based on current file, the hash needs to exactly match what is implemented via Job: StreamToBlob 
</summary>
</member>
<member name="F:Prajna.Core.AsyncExecutionEngine.Token@">
<summary>
 A unique token that identify the job related to this instance of the AsyncExecutionEngine
</summary>
</member>
<member name="F:Prajna.Core.AsyncExecutionEngine.CurDSet@">
<summary>
 To identify current DSet
</summary>
</member>
<member name="F:Prajna.Core.AsyncExecutionEngine.CurTask@">
<summary>
 To identify current task
</summary>
</member>
<member name="P:Prajna.Core.AsyncExecutionEngine.Token">
<summary>
 A unique token that identify the job related to this instance of the AsyncExecutionEngine
</summary>
</member>
<member name="P:Prajna.Core.AsyncExecutionEngine.CurTask">
<summary>
 To identify current task
</summary>
</member>
<member name="P:Prajna.Core.AsyncExecutionEngine.CurDSet">
<summary>
 To identify current DSet
</summary>
</member>
<member name="M:Prajna.Core.AsyncExecutionEngine.WaitForAll(System.Int32)">
<summary>
 Execute all
</summary>
</member>
<member name="M:Prajna.Core.AsyncExecutionEngine.TryExecuteTasks(System.Int32)">
<summary>
 Try to execute the first task in the queue. 
</summary>
</member>
<member name="M:Prajna.Core.AsyncExecutionEngine.TryExecute">
<summary>
 Try execute the task in the queue, until we reach the limit
</summary>
</member>
<member name="M:Prajna.Core.AsyncExecutionEngine.FilterTask(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Threading.CancellationToken,Prajna.Core.AsyncExecutionEngine,System.Int32,Microsoft.FSharp.Control.FSharpAsync{System.Object},Microsoft.FSharp.Core.FSharpRef{System.Threading.Tasks.Task},Microsoft.FSharp.Core.FSharpRef{Prajna.Core.TaskState}},System.Boolean})">
<summary>
 Filter tasks
</summary>
</member>
<member name="M:Prajna.Core.AsyncExecutionEngine.ExamineExecutedTask(System.Int32)">
<summary>
 Try Execute
</summary>
</member>
<member name="M:Prajna.Core.AsyncExecutionEngine.AddTask(System.Threading.CancellationToken,System.Int32,Microsoft.FSharp.Control.FSharpAsync{System.Object})">
<summary>
 Add a task to the execution queue
</summary>
</member>
<member name="P:Prajna.Core.AsyncTaskQueue.IsEmpty">
<summary>
 Has all tasks been completed?
 This is equivalent to check that the task queue is empty &amp; no operation is being executed currently. 
</summary>
</member>
<member name="M:Prajna.Core.AsyncTaskQueue.WaitAll">
<summary>
 Wait for all task to be executed. 
</summary>
</member>
<member name="M:Prajna.Core.AsyncTaskQueue.TryExecute">
<summary>
 Last operation succeed, try execute another task 
</summary>
</member>
<member name="M:Prajna.Core.AsyncTaskQueue.ExecuteNext">
<summary>
 Continue with execution 
</summary>
</member>
<member name="M:Prajna.Core.AsyncTaskQueue.ExceptionContinuation(System.Exception)">
<summary>
 Exeception continuation, both case, remove task to unblock execution
</summary>
</member>
<member name="M:Prajna.Core.AsyncTaskQueue.CancelContinuation(System.OperationCanceledException)">
<summary>
 Cancellation continueation
</summary>
</member>
<member name="M:Prajna.Core.AsyncTaskQueue.AddRange(System.Collections.Generic.IEnumerable{System.Tuple{Prajna.Core.BlobMetadata,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}})">
<summary>
 Add a set of async task to queue
</summary>
</member>
<member name="T:Prajna.Core.AsyncTaskQueue">
<summary>
 Used for Async Traverse, 
 A AsyncTaskQueue wraps a series of Async Tasks, which is executed one after another, garantted in order.  
 Each task is of type 
</summary>
</member>
<member name="F:Prajna.Core.Blob.Index@">
<summary>
 Index of the array in the specific Blob type. 
</summary>
</member>
<member name="F:Prajna.Core.Blob.Stream@">
<summary>
 MemStream associated with blob
</summary>
</member>
<member name="F:Prajna.Core.Blob.Object@">
<summary>
 Object that is associated with the blob
</summary>
</member>
<member name="F:Prajna.Core.Blob.Hash@">
<summary>
 Hash of the blob
</summary>
</member>
<member name="F:Prajna.Core.Blob.Version@">
<summary>
 Version, assoicated with the underlying data version. 
</summary>
</member>
<member name="F:Prajna.Core.Blob.Name@">
<summary>
 Blob Name, which should correspond to the underlying data name, e.g., Cluster Name, DSet name, etc..
</summary>
</member>
<member name="P:Prajna.Core.Blob.Version(System.Int64)">
<summary>
 Version, assoicated with the underlying data version. 
</summary>
</member>
<member name="P:Prajna.Core.Blob.Stream(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 MemStream associated with blob
</summary>
</member>
<member name="P:Prajna.Core.Blob.Object(System.Object)">
<summary>
 Object that is associated with the blob
</summary>
</member>
<member name="P:Prajna.Core.Blob.Name(System.String)">
<summary>
 Blob Name, which should correspond to the underlying data name, e.g., Cluster Name, DSet name, etc..
</summary>
</member>
<member name="P:Prajna.Core.Blob.Index(System.Int32)">
<summary>
 Index of the array in the specific Blob type. 
</summary>
</member>
<member name="P:Prajna.Core.Blob.Hash(System.Byte[])">
<summary>
 Hash of the blob
</summary>
</member>
<member name="P:Prajna.Core.Blob.Version">
<summary>
 Version, assoicated with the underlying data version. 
</summary>
</member>
<member name="P:Prajna.Core.Blob.Stream">
<summary>
 MemStream associated with blob
</summary>
</member>
<member name="P:Prajna.Core.Blob.Object">
<summary>
 Object that is associated with the blob
</summary>
</member>
<member name="P:Prajna.Core.Blob.Name">
<summary>
 Blob Name, which should correspond to the underlying data name, e.g., Cluster Name, DSet name, etc..
</summary>
</member>
<member name="P:Prajna.Core.Blob.Index">
<summary>
 Index of the array in the specific Blob type. 
</summary>
</member>
<member name="P:Prajna.Core.Blob.Hash">
<summary>
 Hash of the blob
</summary>
</member>
<member name="M:Prajna.Core.Blob.StreamForWrite(System.Int64)">
<summary>
 Stream for write
</summary>
</member>
<member name="M:Prajna.Core.Blob.StreamForRead">
<summary>
 Stream for read
</summary>
</member>
<member name="M:Prajna.Core.Blob.GetHashForBlobType(Prajna.Tools.StreamBase{System.Byte},System.Int32,System.Int32)">
<summary>
 Turn stream to blob
</summary>
</member>
<member name="M:Prajna.Core.BlobAvailability.Unpack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Unpack to decode availability information
</summary>
</member>
<member name="M:Prajna.Core.BlobAvailability.Pack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Pack to encode availability information
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.UnregisterAndRemove(System.Guid)">
<summary>
 Unregister blobs for a certain jobID &amp; remove all entry of the cached blob trigger associated with the job 
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.ToArray">
<summary>
 Get the list of current members
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Store(System.Byte[],Prajna.Tools.StreamBase{System.Byte},System.Int64)">
<summary>
 Store object info into the Factory class, apply trigger if there are any function waiting to be executed. 
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Retrieve(System.Byte[])">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Remove(System.Byte[])">
<summary>
 Remove a certain entry
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Register(System.Guid,System.Byte[],Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Tools.StreamBase{System.Byte},System.Int64},Microsoft.FSharp.Core.Unit},System.Int64)">
<summary>
 Register object with a trigger function that will be executed when the object arrives. 
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Refresh(Microsoft.FSharp.Core.FSharpFunc{Prajna.Tools.StreamBase{System.Byte},System.Boolean},System.Int64)">
<summary>
 func: &apos;T -&gt; bool,   true: when object is still in use
 Evict all object if there is elapseSeconds passed when the object is not in use. 
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Refresh(System.Byte[])">
<summary>
 Refresh timer entry of an object
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.ReceiveWriteBlob(System.Byte[],System.Lazy{System.Byte[]},Prajna.Tools.StreamBase{System.Byte},System.Int64)">
<summary>
 Cache Information, used the existing object in Factory if it is there already
</summary>
</member>
<member name="M:Prajna.Core.BlobFactory.Evict(System.Int64)">
<summary>
 Evict object that hasn&apos;t been visited within the specified seconds
</summary>
</member>
<member name="T:Prajna.Core.BlobFactory">
<summary>
 The BlobFactory class implements cache that avoid instantiation of multiple Blob class, and save memory. 
</summary>
</member>
<member name="T:Prajna.Core.BlobMetadata">
<summary>
 BlobMetadata used in Job Execution. The class gets exposed because of use in abstract function. 
</summary>
</member>
<member name="M:Prajna.Core.CHT.GetPartitionMapping(System.UInt64,System.Int32,System.Int32)">
<summary>
 Get a partition mapping using Consistent Hash Table (CHT).
 contentKey is a hash value that identifies a certain content in Prajna, which randomize partition assignment for different content
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.toArray">
<summary>
 Get the list of current members
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Store(System.String,`0)">
<summary>
 Store object info into the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Retrieve(System.String)">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Resolve(System.String)">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Remove(System.String)">
<summary>
 Remove a certain entry
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Refresh(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},System.Int32)">
<summary>
 func: &apos;T -&gt; bool,   true: when object is still in use
 Evict all object if there is elapseSeconds passed when the object is not in use. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Refresh(System.String)">
<summary>
 Refresh timer entry of an object
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.GetOrAdd(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,`0})">
<summary>
 Get or add a entry
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.Evict(System.Int32)">
<summary>
 Evict object that hasn&apos;t been visited within the specified seconds
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`1.CacheUseOld(System.String,`0)">
<summary>
 Cache Information, used the existing object in Factory if it is there already
</summary>
</member>
<member name="T:Prajna.Core.CacheFactory`1">
<summary>
 The CacheFactory class implements cache that avoid instantiation of multiple Cluster class, and save memory. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.toArray">
<summary>
 Get the list of current members
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Store(`0,`1)">
<summary>
 Store object info into the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.RetrieveWithTimeStamp(`0)">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Retrieve(`0)">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Resolve(`0)">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Remove(`0)">
<summary>
 Remove a certain entry
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Refresh(Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean},System.Int32)">
<summary>
 func: &apos;T -&gt; bool,   true: when object is still in use
 Evict all object if there is elapseSeconds passed when the object is not in use. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Refresh(`0)">
<summary>
 Refresh timer entry of an object
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.GetOrAdd(`0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,`1})">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.EvictAndReturnEvictedItems(System.Int32)">
<summary>
 Evict object that hasn&apos;t been visited within the specified seconds
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.Evict(System.Int32)">
<summary>
 Evict object that hasn&apos;t been visited within the specified seconds
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.CacheUseOldIfNotNull(`0,`1)">
<summary>
 Cache Information, used the existing object in Factory if it is there already
</summary>
</member>
<member name="M:Prajna.Core.CacheFactory`2.CacheUseOld(`0,`1)">
<summary>
 Cache Information, used the existing object in Factory if it is there already
</summary>
</member>
<member name="T:Prajna.Core.CacheFactory`2">
<summary>
 The CacheFactory class implements cache that avoid instantiation of multiple Cluster class, and save memory.
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.ConstructKVCacheMask">
<summary>
 IndexByKey | ConcurrectDictionary | SortedRetrieve all need KV Cache
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.ConstructEnumerableCacheMask">
<summary>
 EnumerableRetrieve, no need for KV Cache
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.UnifiedCache">
<summary>
 One Cache spans all partition, if UnifiedCache is On, only one partition cache will be created for the entire DSet
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.SampledWithReplacement">
<summary>
 The data is sampled, with past sampling recorded. 
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.SortedRetrieve">
<summary>
 The cached data is sorted 
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.ConcurrectDictionary">
<summary>
 The cached data can be accessed via a Concurrent Dictionary
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.IndexByKey">
<summary>
 The cached data can be accessed via index
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.EnumerableRetrieve">
<summary>
 The cached data can be retrieved via a Enumerable Operator
</summary>
</member>
<member name="F:Prajna.Core.CacheKind.None">
<summary>
 No cached access
</summary>
</member>
<member name="T:Prajna.Core.CacheKind">
<summary>
 PrajnaCacheTye only kicks in for StorageType.RAM
 It is only used for in job DSet
</summary>
</member>
<member name="F:Prajna.Core.CacheTracker.CachedCollection@">
<summary>
 Store what object has been cached 
</summary>
</member>
<member name="P:Prajna.Core.CacheTracker.CachedCollection">
<summary>
 Store what object has been cached 
</summary>
</member>
<member name="T:Prajna.Core.CacheTracker">
 <summary>
 Track class that is being cached at PrajnaProgram
 </summary>
</member>
<member name="M:Prajna.Core.ClientController.UnSetRefreshDependency">
<summary>
 UnSet dep refresh
</summary>
</member>
<member name="M:Prajna.Core.ClientController.UnSetRefreshDSet">
<summary>
 UnSet DSet refresh
</summary>
</member>
<member name="M:Prajna.Core.ClientController.UnSetRefreshAssembly">
<summary>
 UnSet assembly refresh
</summary>
</member>
<member name="M:Prajna.Core.ClientController.SetRefreshDependency">
<summary>
 Set dep refresh
</summary>
</member>
<member name="M:Prajna.Core.ClientController.SetRefreshDSet">
<summary>
 Set DSet refresh
</summary>
</member>
<member name="M:Prajna.Core.ClientController.SetRefreshAssembly">
<summary>
 Set assembly refresh
</summary>
</member>
<member name="T:Prajna.Core.ClientController">
<summary>
 Networking between Client Nodes and Controller
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.GPUMemoryCapacity">
<summary>
 GPU memory capacity of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.GPUCores">
<summary>
 number of GPU cores of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.GPUType">
<summary>
 type of GPU, if exist of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.SSDCapacity">
<summary>
 Capacity of SSD of the remote node. 
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.SSDType">
<summary>
 type of SSD, if exist of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.NetworkSpeed">
<summary>
 Network speed 
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.NetworkMTU">
<summary>
 the maximum transmission unit (MTU) of networkk 
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.DriveSpace">
<summary>
 Usuable Disk of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.MemorySpace">
<summary>
 Usuable RAM of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.DiskCapacity">
<summary>
 Disk capacity of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.RamCapacity">
<summary>
 RAM capacity of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.ProcessorCount">
<summary>
 Number of cores of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.InternalIPAddress">
<summary>
 Internally visibe IP addresses of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.ExternalIPAddress">
<summary>
 Globally visibe IP addresses of the remote node
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.JobPortCur">
<summary>
 Machine Daemon Port
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.JobPortMax">
<summary>
 Machine Container Port range, maximum
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.JobPortMin">
<summary>
 Machine Container Port range, minimum
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.MachinePort">
<summary>
 Machine Daemon Port
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.MachineName">
<summary>
 Machine Host Name
</summary>
</member>
<member name="F:Prajna.Core.ClientInfo.MachineID">
<summary>
 A number uniquely identify a machine
</summary>
</member>
<member name="T:Prajna.Core.ClientInfo">
<summary>
 ClientInfo contains information of a Prajna remote node and its daemon. 
 Information below is exposed as F# is not capable of suppress comment on internal/private structure member. 
</summary>
</member>
<member name="M:Prajna.Core.ClientLauncher.Start(System.String[])">
<summary>
 Give a chance for all the launched task to be closed. 
</summary>
</member>
<member name="T:Prajna.Core.ClientMasterConfig">
<summary>
 Read in the master configuration file of Prajna client
 First line of the master configuration file should be:
 Version\tMasterName\tPort
 Each additional line has one executable
</summary>
</member>
<member name="M:Prajna.Core.ClientStatusEx.UpdateInfo(Prajna.Core.ClientInfoType,System.Byte[])">
<summary>
 Unpack status information for display by controller
</summary>
</member>
<member name="M:Prajna.Core.ClientStatusEx.RefreshNeeded(Prajna.Core.ClientInfoType)">
<summary>
 Compute which information needs to be sent by client nodes?
</summary>
</member>
<member name="M:Prajna.Core.ClientStatusEx.Pack(Prajna.Core.ClientInfoType)">
<summary>
 Packet status information to send to controller
</summary>
</member>
<member name="M:Prajna.Core.ClientStatusEx.GetStorageStatus">
<summary>
 Update  of client node
</summary>
</member>
<member name="F:Prajna.Core.Cluster.Connects@">
<summary>
 Get the current connected queue set 
</summary>
</member>
<member name="F:Prajna.Core.Cluster.Current@">
 <summary>
 Get, Set Current Cluster used by DSet, DStream, service launch, etc..
 </summary>
</member>
<member name="P:Prajna.Core.Cluster.Current(Microsoft.FSharp.Core.FSharpOption{Prajna.Core.Cluster})">
 <summary>
 Get, Set Current Cluster used by DSet, DStream, service launch, etc..
 </summary>
</member>
<member name="P:Prajna.Core.Cluster.VersionString">
<summary>
 Return version of the cluster as a printable string 
</summary>
</member>
<member name="P:Prajna.Core.Cluster.Version">
<summary>
 Return version of the cluster 
</summary>
</member>
<member name="P:Prajna.Core.Cluster.NumNodes">
<summary>
 Return number of nodes. 
</summary>
</member>
<member name="P:Prajna.Core.Cluster.Nodes">
 <summary>
 Return a list of node that form the cluster
 </summary>
</member>
<member name="P:Prajna.Core.Cluster.Name">
<summary>
 Return name of the cluster 
</summary>
</member>
<member name="P:Prajna.Core.Cluster.Current">
 <summary>
 Get, Set Current Cluster used by DSet, DStream, service launch, etc..
 </summary>
</member>
<member name="P:Prajna.Core.Cluster.Connects">
<summary>
 Get the current connected queue set 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.UseSingleNodeCluser(System.Int32)">
 <summary>
 Use a single node at the current cluser
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.UseSingleNodeCluser(System.String)">
 <summary>
 Use a single node at the current cluser
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.Unpack(Prajna.Tools.MemoryStreamB)">
<summary>
 Unpack cluster 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.UnRegisterOneCallback(System.Guid,System.String,System.Int64,System.Collections.Generic.IEnumerable{Prajna.Core.ControllerCommand})">
<summary>
 Unregister Callback
</summary>
</member>
<member name="M:Prajna.Core.Cluster.UnRegisterCallback(System.Guid,System.Collections.Generic.IEnumerable{Prajna.Core.ControllerCommand})">
<summary>
 Unregister Callback
</summary>
</member>
<member name="M:Prajna.Core.Cluster.ToString">
<summary>
 Show Cluster Information
</summary>
</member>
<member name="M:Prajna.Core.Cluster.Stop">
<summary>
 Stop all connnections and disconnect all clusters. 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.StartCluster(System.String)">
<summary>
 Load a cluster, start the connection to their nodes, and use it as the current cluster
</summary>
</member>
<member name="M:Prajna.Core.Cluster.Start(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Load a cluster, with optional a master (which may be queryed for cluster allocation), start the connection to their nodes, and use it as the current cluster
</summary>
</member>
<member name="M:Prajna.Core.Cluster.SplitByPeers``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Split a sequence by peer information only to multiple subsequences. 
 (Usually to be sent over the network). 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.SetCurrent(Prajna.Core.Cluster)">
 <summary>
 Set the default cluster used by DSet, DStream, service launch, etc..
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.RegisterCallback(System.Guid,System.String,System.Int64,System.Collections.Generic.IEnumerable{Prajna.Core.ControllerCommand},Prajna.Core.NetworkCommandCallback)">
<summary>
 Register Callback for Cluster
 commandset: a set of command (usually in the form of array) that the call back function will interpret
     Wildcard is allowed in the form of Verb.Unknown*_, _*Noun.Unknown
 Name, ver: 
     For each command, the Parsecommand will first read a string and a int64 parameter, 
     it will matches with callback.
         string*int64, wildcard is allowed in the form ofstring*0L, null*int64, or null*0L
</summary>
</member>
<member name="M:Prajna.Core.Cluster.Pack(Prajna.Tools.MemoryStreamB)">
<summary>
 Pack cluster to a byte stream
</summary>
</member>
<member name="M:Prajna.Core.Cluster.InitializeQueues">
<summary>
 Initialize write queues
</summary>
</member>
<member name="M:Prajna.Core.Cluster.GetSingleNodeCluster(System.Int32)">
 <summary>
 Construct a single node using the existing cluster information. 
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.GetSingleNodeCluster(System.String)">
 <summary>
 Construct a single node using the existing cluster information. 
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.GetNodeIDsWithResource(Prajna.Core.PartitionByKind)">
<summary>
 Return an array of ClientInfo[] * int[], in which the first is the information of the nodes (i.e., x.Nodes), the second is the resource of
 each node 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.GetCurrent">
 <summary>
 Get the default cluster used by DSet, DStream, service launch, etc..
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.GetCombinedCluster(System.Collections.Generic.IEnumerable{Prajna.Core.Cluster})">
 <summary>
 Construct a single node using the existing cluster information. 
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.EndCommunication">
<summary>
 EndCommunication: called to shutdown the communication pipes to clients 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.DisconnectAll">
<summary>
 Disconnect all peers. 
</summary>
</member>
<member name="M:Prajna.Core.Cluster.ConstructCluster(Prajna.Core.ClusterInfo)">
<summary>
 Construct a Cluster from ClusterInfo
</summary>
</member>
<member name="M:Prajna.Core.Cluster.ConnectAll">
<summary>
 Start connection to all peers
</summary>
</member>
<member name="M:Prajna.Core.Cluster.BeginCommunication">
<summary>
 BeginCommunication: always called to ensure proper initialization of cluster structure
</summary>
</member>
<member name="M:Prajna.Core.Cluster.#ctor(Microsoft.FSharp.Core.FSharpOption{System.String},Prajna.Core.LocalClusterConfig)">
 <summary>
 Construct a Cluster from a cluster description, with optionally a master node. 
 <param name="masterFile"> The master node may be used to query for the cluster used. </param>
 <param name="config">User supplied local cluster configuration</param>
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.#ctor(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
 <summary>
 Construct a Cluster from a cluster description, with optionally a master node. 
 <param name="masterFile"> The master node may be used to query for the cluster used. </param>
 <param name="cluster">
 It can either be 
 * a path to cluster file, which should be a .inf file contains the description of the cluster
 * or a string in the format "local" or "local[n]", which means a local cluster with 1 client or n clients respectively
   In this case, both the clients and containers are started as an AppDomain. 
   the system uses DeploymentSettings.LocalClusterNumJobPortsPerClient and DeploymentSettings.LocalClusterStartingPort. If these
   predefined ports are not accessible, the local cluster may not function properly. For user who wants to have full control
   of the configuration, please use the constructor that takes LocalClusterConfig as parameter
 </param>
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.#ctor(Prajna.Core.LocalClusterConfig)">
 <summary>
 Construct a Prajna Local cluster from configuration.
 <param name="config">User supplied local cluster configuration</param>
 </summary>
</member>
<member name="M:Prajna.Core.Cluster.#ctor(System.String)">
 <summary>
 Construct a Cluster from cluster description.
 <param name="cluster">
 It can either be 
 * a path to cluster file, which should be a .inf file contains the description of the cluster
 * or a string in the format "local" or "local[n]", which means a local cluster with 1 client or n clients respectively
   In this case, both the clients and containers are started as an AppDomain. 
   the system uses DeploymentSettings.LocalClusterNumJobPortsPerClient and DeploymentSettings.LocalClusterStartingPort. If these
   predefined ports are not accessible, the local cluster may not function properly. For user who wants to have full control
   of the configuration, please use the constructor that takes LocalClusterConfig as parameter
 </param>
 </summary>
</member>
<member name="T:Prajna.Core.Cluster">
 <summary> 
 Cluster represents a set of remote nodes in either a private cloud or a public cloud. It is the class that govern 
 which remote nodes that services, contracts and data analytical jobs are running upon. 
 </summary> 
</member>
<member name="M:Prajna.Core.ClusterFactory.StoreCluster(Prajna.Core.Cluster)">
<summary>
 Store Cluster Information
</summary>
</member>
<member name="M:Prajna.Core.ClusterFactory.GetOrAddCluster(System.String,System.Int64,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prajna.Core.Cluster})">
<summary>
 Get or add a cluster
</summary>
</member>
<member name="M:Prajna.Core.ClusterFactory.FindCluster(System.String,System.Int64)">
<summary>
 Try to Find a Cluster with (name, verNumber)
 Return cluster if found, 
 return null if not found. 
</summary>
</member>
<member name="M:Prajna.Core.ClusterFactory.CacheCluster(Prajna.Core.Cluster)">
<summary>
 Cache Cluster Information 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Unpack(System.Byte[])">
<summary>
 Unpack to cluster information. 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Unpack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Unpack the current cluster from MemStream
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.SaveShort">
<summary>
 Save the current ClusterInfoBase to file, with a shorter filename for easier manipulation. 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.SaveOld(System.String)">
<summary>
 Save the current ClusterInfoBase to file
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.SaveLst">
<summary>
 Save the current Client list, with default name
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.SaveLst(System.String)">
<summary>
 Save the current Client list 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Save">
<summary>
 It is OK if some of the cluster file can&apos;t be parsed
 Save the current ClusterInfoBase to file, with default name
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Save(System.String)">
<summary>
 New Cluster Format
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.ReadOld(System.String)">
<summary>
 Read the current cluster from file 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Read(System.String,System.DateTime)">
<summary>
 Read the current cluster 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Read(System.String)">
<summary>
 Read the current cluster from file 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Persist">
<summary>
 Save the current ClusterInfoBase if the current cluster doesn&apos;t exist 
 if the version is not specified (DateTime.MinValue), then search for the latst version of inf file for the same cluster (by name)
 If the info is the same, nothing to persist. Otherwise, create a new version. 
 If the version is specified, save it.
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.PeriodicClusterUpdate(System.Object)">
<summary>
 Should not be called, this feature is been deprecated. 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.Pack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Pack Cluster Information        
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.GetClusters(System.String)">
<summary>
 Query available clusters 
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.ConstructLstFilename">
<summary>
 Construct the name to save the cluster list
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.ConstructClusterInfoFilename">
<summary>
 Construct the name to save the cluster info
</summary>
</member>
<member name="M:Prajna.Core.ClusterInfo.ConstructClusterInfoFileNameWithVersion(System.String,System.DateTime)">
<summary>
 ver = DateTime.MinValue, just use a shorter filename for ease of remembering (don&apos;t save ver into filename)s
</summary>
</member>
<member name="M:Prajna.Core.ClusterJobInfo.GetCurPeerIndex">
<summary>
 Get the Index of the Current Peer
</summary>
</member>
<member name="T:Prajna.Core.ClusterJobInfo">
<summary>
 Information of Within Job cluster information. 
</summary>
</member>
<member name="T:Prajna.Core.ClusterJobInfoFactory">
<summary>
 Cache information. 
</summary>
</member>
<member name="T:Prajna.Core.Config">
<summary>
 Machine configuration
</summary>
</member>
<member name="M:Prajna.Core.ContainerAppDomainInfo.StartProgram(System.Object)">
<summary>
 Start task with Name and version, 
 this is usually called from another appdomain or exe
</summary>
</member>
<member name="M:Prajna.Core.ContainerJob.TryExecuteSingleJobAction">
<summary>
 Grab a single job action object, when secured, the cancellation of the underlying jobLifeCycle object will be delayed 
 until this action completes. 
</summary>
</member>
<member name="M:Prajna.Core.ContainerJob.EndContainerJob">
<summary>
 End container job
</summary>
</member>
<member name="T:Prajna.Core.ContainerJob">
<summary>
 Create a job for remote execution roster
</summary>
</member>
<member name="F:Prajna.Core.ControllerCommand.Noun">
<summary>
 Noun in the Prajna message
</summary>
</member>
<member name="F:Prajna.Core.ControllerCommand.Verb">
<summary>
 Verb in the Prajna message
</summary>
</member>
<member name="M:Prajna.Core.ControllerCommand.#ctor(Prajna.Core.ControllerVerb,Prajna.Core.ControllerNoun)">
<summary>
 Construct a Command word with a verb and a noun pair
</summary>
</member>
<member name="T:Prajna.Core.ControllerCommand">
<summary>
 Verb-Noun pair that forms one Prajna message. 
 Only advance programmer that need to write additional Prajna service should use this data structure
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Unknown">
<summary>
 Unknown
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.All">
<summary>
 All
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.ClientInfo">
<summary>
 ClientInfo
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.DistributedFunction">
<summary>
 DistributedFunction
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Contract">
<summary>
 Contract
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.QueryReply">
<summary>
 QueryReply
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Buffer">
<summary>
 Buffer
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Connection">
<summary>
 Connection
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Service">
<summary>
 Service
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Dependency">
<summary>
 Dependency
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.DStream">
<summary>
 DStream
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Program">
<summary>
 Program
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.GV">
<summary>
 GV
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Blob">
<summary>
 Blob
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Job">
<summary>
 Job
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Partition">
<summary>
 Partition
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Metadata">
<summary>
 Metadata
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.DSet">
<summary>
 DSet
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Assembly">
<summary>
 Assembly
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.Message">
<summary>
 Message
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.KeyValue">
<summary>
 KeyValue
</summary>
</member>
<member name="F:Prajna.Core.ControllerNoun.ClusterInfo">
<summary>
 ClusterInfo
</summary>
</member>
<member name="T:Prajna.Core.ControllerNoun">
<summary>
 Noun to be used for message passing between Prajna nodes
 Only advance programmer that need to write additional Prajna service should use this data structure
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Unknown">
<summary>
 Unknown
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Error">
<summary>
 Error
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Acknowledge">
<summary>
 Acnowledge
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Warning">
<summary>
 Warning
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Nothing">
<summary>
 Nothing
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Info">
<summary>
 Info
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Duplicate">
<summary>
 Duplicate
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Verbose">
<summary>
 Verbose
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.NonExist">
<summary>
 NonExist
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Exception">
<summary>
 Exception 
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.FailedPartition">
<summary>
 Failure/exception on a single partition (the job may still be able to execute on other node). 
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Cancel">
<summary>
 Cancel a Job
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Decrypt">
<summary>
 Decrypt
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.LimitSpeed">
<summary>
 LimitSpeed
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.FailedRegister">
<summary>
 Failed Registration
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ContainerInfo">
<summary>
 Information of the connecting container
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.FailedRequest">
<summary>
 FailedRequest
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.FailedReply">
<summary>
 FailedReply
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Register">
<summary>
 Register
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.TimeOut">
<summary>
 TimeOut
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ConfirmStop">
<summary>
 ConfirmStop
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Stop">
<summary>
 Stop
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Reply">
<summary>
 Reply
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Request">
<summary>
 Request
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Delete">
<summary>
 Delete
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.SyncClose">
<summary>
 SyncClose
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.SyncClosePartition">
<summary>
 SyncClosePartition
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.SyncWrite">
<summary>
 SyncWrite
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ReadToNetwork">
<summary>
 ReadToNetwork
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.WriteMetadata">
<summary>
 WriteMetadata
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.UpdateParam">
<summary>
 UpdateParam
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ReportClose">
<summary>
 ReportClose
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ReportPartition">
<summary>
 ReportPartition
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ConfirmClosePartition">
<summary>
 ConfirmClosePartition
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ConfirmClose">
<summary>
 ConfirmClose
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ClosePartition">
<summary>
 ClosePartition
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.InfoNode">
<summary>
 InfoNode
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Update">
<summary>
 Update
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Report">
<summary>
 Report
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Open">
<summary>
 Open
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.WriteGV">
<summary>
 WriteGV
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Fold">
<summary>
 Fold
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Forward">
<summary>
 Forward
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Ready">
<summary>
 Ready
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Link">
<summary>
 Link
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ConfirmStart">
<summary>
 ConfirmStart
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Start">
<summary>
 Start
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Availability">
<summary>
 Availability
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Use">
<summary>
 Use
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ReplicateClose">
<summary>
 ReplicateClose
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.ReplicateWrite">
<summary>
 ReplicateWrite
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.WriteAndReplicate">
<summary>
 WriteAndReplicate
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Close">
<summary>
 Close
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Write">
<summary>
 Write
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Read">
<summary>
 Read
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Echo2Return">
<summary>
 Echo2Return
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Echo2">
<summary>
 Echo2
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.EchoReturn">
<summary>
 EchoReturn
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Echo">
<summary>
 Echo
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.List">
<summary>
 List
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Store">
<summary>
 Store
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Set">
<summary>
 Set
</summary>
</member>
<member name="F:Prajna.Core.ControllerVerb.Get">
<summary>
 Get 
</summary>
</member>
<member name="T:Prajna.Core.ControllerVerb">
<summary>
 Verb to be used for message passing between Prajna nodes
 Only advance programmer that need to write additional Prajna service should use this data structure
</summary>
</member>
<member name="M:Prajna.Core.CorrelatedMix2FunctionWrapper`3.WrapperDerivedExecuteFunc(System.Int32,System.Int32)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="M:Prajna.Core.CorrelatedMix3FunctionWrapper`4.WrapperDerivedExecuteFunc(System.Int32,System.Int32)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="M:Prajna.Core.CorrelatedMix4FunctionWrapper`5.WrapperDerivedExecuteFunc(System.Int32,System.Int32)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="F:Prajna.Core.DJobInstance.RemappingCommandCallback@">
<summary>
 Call back function used by Execute New Mapping, set this call back to have customized command to send to DSet.
 Parameter: peeri: int, send the command to ith peer
            peeriPartitionArray: int[], the command applies to the following partitions. 
            dset : the command applies to the following DSet
</summary>
</member>
<member name="F:Prajna.Core.DJobInstance.bMetaDataSet@">
<summary>
 allow information to be captured on peer failure in the DSet 
</summary>
</member>
<member name="P:Prajna.Core.DJobInstance.bMetaDataSet(System.Boolean)">
<summary>
 allow information to be captured on peer failure in the DSet 
</summary>
</member>
<member name="P:Prajna.Core.DJobInstance.RemappingCommandCallback(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.NetworkCommandQueue,System.Int32,System.Int32[],Prajna.Core.DSet},Microsoft.FSharp.Core.Unit})">
<summary>
 Call back function used by Execute New Mapping, set this call back to have customized command to send to DSet.
 Parameter: peeri: int, send the command to ith peer
            peeriPartitionArray: int[], the command applies to the following partitions. 
            dset : the command applies to the following DSet
</summary>
</member>
<member name="P:Prajna.Core.DJobInstance.bMetaDataSet">
<summary>
 allow information to be captured on peer failure in the DSet 
</summary>
</member>
<member name="P:Prajna.Core.DJobInstance.RemappingCommandCallback">
<summary>
 Call back function used by Execute New Mapping, set this call back to have customized command to send to DSet.
 Parameter: peeri: int, send the command to ith peer
            peeriPartitionArray: int[], the command applies to the following partitions. 
            dset : the command applies to the following DSet
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.SetMetaDataAvailability(System.Boolean[],System.Boolean[])">
<summary>
 Peer availability and fail pattern, bMetaRead, bPeerF should be an array of the size of the cluster 
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.SentCmd(System.Int32,System.Int32)">
<summary>
 We have sent request to peeri for parti
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.RetrieveOneMetaData(System.Guid)">
<summary>
 Retrieve meta data of DSet
 Please note that if there are metadata of multiple DSet to be retired, the RetrieveMetaData call for job should be used instead. 
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.RetrieveMetaDataCallback(Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64)">
<summary>
 Callback function used during metadata retrieval phase
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.RemappingCommandForRead(Prajna.Core.NetworkCommandQueue,System.Int32,System.Int32[],Prajna.Core.DSet)">
<summary>
 an example of a remapping command. 
 Parameter: peeri: int, send the command to ith peer
            peeriPartitionArray: int[], the command applies to the following partitions. 
            dset : the command applies to the following DSet
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.Remapping">
<summary>
 Find new peers that will be assigned with partitions, send those partition information. 
 Return :
      True: there are pending remapping command to be sentout. 
      False: there is no remapping command pending. 
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.ProcessedPartition(System.Int32,System.Int32,System.Int32)">
<summary>
 A peer encounter some error in processing parti
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.PeerCmdComplete(System.Int32)">
<summary>
 Indicate a Close, Partition or equivalent command has received from a peer, and the job requested from the peer has been completed. 
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.NotExistPartitions(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 peeri sends feedback that it doesn&apos;t have a set of partitions. 
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.InitiatePartitionStatus">
<summary>
 Initiate Partition Status to ready to communicate to other peer owned by DSet
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.ExecuteNewMapping(System.Collections.Generic.List{System.Int32}[])">
<summary>
 Send outgoing DSet command. 
 Return :
      True: there are pending remapping command to be sentout. 
      False: there is no remapping command pending. 
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.ClearConnectionState">
<summary>
 Connection state
</summary>
</member>
<member name="M:Prajna.Core.DJobInstance.AllDSetsRead">
<summary>
 Have we read all DSets? 
</summary>
</member>
<member name="F:Prajna.Core.DParam.Mapping@">
<summary>
 A null mapping matrix should only be used for ClusterReplicationType.ClusterReplicate mode, in which a partition can be attached to any peer
</summary>
</member>
<member name="F:Prajna.Core.DParam.PeerRcvdSpeedLimit@">
<summary>
 Flow control, limits the total bytes send out to PeerRcvdSpeedLimit
 If it is communicating with N peer, each peer, the sending queue limit is PeerRcvdSpeedLimit/N
</summary>
</member>
<member name="F:Prajna.Core.DParam.ConfirmDelivery@">
<summary>
 ConfirmDelivery = true:
 Turn on logic that will deliver elem to an alternate peer if the current peer is not live. 
 The logic is disabled at the moment. 
</summary>
</member>
<member name="F:Prajna.Core.DParam.Password@">
<summary>
 Password that will be hashed and used for triple DES encryption and decryption of data. 
</summary>
</member>
<member name="F:Prajna.Core.DParam.PostGroupByReserialization@">
<summary>
 In BinSort/MapReduce, indicate the collection size after the a collection of data is received from network  
</summary>
</member>
<member name="F:Prajna.Core.DParam.PreGroupByReserialization@">
<summary>
 In BinSort/MapReduce, indicate whether need to regroup collection before sending a collection of data across network 
</summary>
</member>
<member name="F:Prajna.Core.DParam.bParitionerSet@">
<summary>
 Partitioner wraps in two entity, 
 TypeOfPartitioner &amp; NumPartitions
</summary>
</member>
<member name="P:Prajna.Core.DParam.bParitionerSet(System.Boolean)">
<summary>
 Partitioner wraps in two entity, 
 TypeOfPartitioner &amp; NumPartitions
</summary>
</member>
<member name="P:Prajna.Core.DParam.Version(System.DateTime)">
<summary>
 Get and Set version 
</summary>
</member>
<member name="P:Prajna.Core.DParam.TypeOfLoadBalancer(Prajna.Core.LoadBalanceAlgorithm)">
<summary>
 Get or Set Load Balancer
 Note that the change will affect Partitioner
</summary>
</member>
<member name="P:Prajna.Core.DParam.StorageType(Prajna.Core.StorageKind)">
<summary>
 Storage Type, which include StorageMedia and IndexMethod
</summary>
</member>
<member name="P:Prajna.Core.DParam.SerializationLimit(System.Int32)">
<summary>
 Number of record in a collection during data analytical jobs. 
 This parameter will not change number of record in an existing collection of a DSet. To change the 
 number of record of an existing collection, please use RowsReorg(). 
</summary>
</member>
<member name="P:Prajna.Core.DParam.SendingQueueLimit(System.Int32)">
<summary>
 Sender flow control, DSet/DStream limits the total sending queue to SendingQueueLimit
 If it is communicating with N peer, each peer, the sending queue limit is SendingQueueLimit/N
</summary>
</member>
<member name="P:Prajna.Core.DParam.PreGroupByReserialization(System.Int32)">
<summary>
 In BinSort/MapReduce, indicate whether need to regroup collection before sending a collection of data across network 
</summary>
</member>
<member name="P:Prajna.Core.DParam.PostGroupByReserialization(System.Int32)">
<summary>
 In BinSort/MapReduce, indicate the collection size after the a collection of data is received from network  
</summary>
</member>
<member name="P:Prajna.Core.DParam.PeerRcvdSpeedLimit(System.Int64)">
<summary>
 Flow control, limits the total bytes send out to PeerRcvdSpeedLimit
 If it is communicating with N peer, each peer, the sending queue limit is PeerRcvdSpeedLimit/N
</summary>
</member>
<member name="P:Prajna.Core.DParam.Password(System.String)">
<summary>
 Password that will be hashed and used for triple DES encryption and decryption of data. 
</summary>
</member>
<member name="P:Prajna.Core.DParam.NumReplications(System.Int32)">
<summary>
 Required number of replications for durability
</summary>
</member>
<member name="P:Prajna.Core.DParam.NumPartitions(System.Int32)">
<summary>
 Number of partitions  
</summary>
</member>
<member name="P:Prajna.Core.DParam.Name(System.String)">
<summary>
 Get and Set name 
</summary>
</member>
<member name="P:Prajna.Core.DParam.MaxDownStreamAsyncTasks(System.Int32)">
<summary>
 Maximum number of tasks that can be pending in a downstream direction per partition
</summary>
</member>
<member name="P:Prajna.Core.DParam.MaxCollectionTaskTimeout(System.Int32)">
<summary>
 Maximum amount of time a single task can run without considered as failed. 
</summary>
</member>
<member name="P:Prajna.Core.DParam.Mapping(System.Int32[][])">
<summary>
 A null mapping matrix should only be used for ClusterReplicationType.ClusterReplicate mode, in which a partition can be attached to any peer
</summary>
</member>
<member name="P:Prajna.Core.DParam.IsPartitionByKey(System.Boolean)">
<summary>
 Is the partition of DSet formed by a key function that maps a data item to an unique partition
</summary>
</member>
<member name="P:Prajna.Core.DParam.ConfirmDelivery(System.Boolean)">
<summary>
 ConfirmDelivery = true:
 Turn on logic that will deliver elem to an alternate peer if the current peer is not live. 
 The logic is disabled at the moment. 
</summary>
</member>
<member name="P:Prajna.Core.DParam.Cluster(Prajna.Core.Cluster)">
<summary>
 Get and Set Cluster 
</summary>
</member>
<member name="P:Prajna.Core.DParam.CacheType(Prajna.Core.CacheKind)">
<summary>
 Retrieve the Index Type alone
</summary>
</member>
<member name="P:Prajna.Core.DParam.bParitionerSet">
<summary>
 Partitioner wraps in two entity, 
 TypeOfPartitioner &amp; NumPartitions
</summary>
</member>
<member name="P:Prajna.Core.DParam.VersionString">
<summary>
 Represent version in a string for display 
</summary>
</member>
<member name="P:Prajna.Core.DParam.Version">
<summary>
 Get and Set version 
</summary>
</member>
<member name="P:Prajna.Core.DParam.TypeOfLoadBalancer">
<summary>
 Get or Set Load Balancer
 Note that the change will affect Partitioner
</summary>
</member>
<member name="P:Prajna.Core.DParam.StorageType">
<summary>
 Storage Type, which include StorageMedia and IndexMethod
</summary>
</member>
<member name="P:Prajna.Core.DParam.StorageMedia">
<summary>
 Retrieve the Storage Media Type alone
</summary>
</member>
<member name="P:Prajna.Core.DParam.SerializationLimit">
<summary>
 Number of record in a collection during data analytical jobs. 
 This parameter will not change number of record in an existing collection of a DSet. To change the 
 number of record of an existing collection, please use RowsReorg(). 
</summary>
</member>
<member name="P:Prajna.Core.DParam.SendingQueueLimit">
<summary>
 Sender flow control, DSet/DStream limits the total sending queue to SendingQueueLimit
 If it is communicating with N peer, each peer, the sending queue limit is SendingQueueLimit/N
</summary>
</member>
<member name="P:Prajna.Core.DParam.PreGroupByReserialization">
<summary>
 In BinSort/MapReduce, indicate whether need to regroup collection before sending a collection of data across network 
</summary>
</member>
<member name="P:Prajna.Core.DParam.PostGroupByReserialization">
<summary>
 In BinSort/MapReduce, indicate the collection size after the a collection of data is received from network  
</summary>
</member>
<member name="P:Prajna.Core.DParam.PeerRcvdSpeedLimit">
<summary>
 Flow control, limits the total bytes send out to PeerRcvdSpeedLimit
 If it is communicating with N peer, each peer, the sending queue limit is PeerRcvdSpeedLimit/N
</summary>
</member>
<member name="P:Prajna.Core.DParam.Password">
<summary>
 Password that will be hashed and used for triple DES encryption and decryption of data. 
</summary>
</member>
<member name="P:Prajna.Core.DParam.NumReplications">
<summary>
 Required number of replications for durability
</summary>
</member>
<member name="P:Prajna.Core.DParam.NumPartitions">
<summary>
 Number of partitions  
</summary>
</member>
<member name="P:Prajna.Core.DParam.Name">
<summary>
 Get and Set name 
</summary>
</member>
<member name="P:Prajna.Core.DParam.MaxDownStreamAsyncTasks">
<summary>
 Maximum number of tasks that can be pending in a downstream direction per partition
</summary>
</member>
<member name="P:Prajna.Core.DParam.MaxCollectionTaskTimeout">
<summary>
 Maximum amount of time a single task can run without considered as failed. 
</summary>
</member>
<member name="P:Prajna.Core.DParam.Mapping">
<summary>
 A null mapping matrix should only be used for ClusterReplicationType.ClusterReplicate mode, in which a partition can be attached to any peer
</summary>
</member>
<member name="P:Prajna.Core.DParam.IsPartitionByKey">
<summary>
 Is the partition of DSet formed by a key function that maps a data item to an unique partition
</summary>
</member>
<member name="P:Prajna.Core.DParam.IsCached">
<summary>
 Do we need to cache the specific DStream/DSet
</summary>
</member>
<member name="P:Prajna.Core.DParam.ConfirmDelivery">
<summary>
 ConfirmDelivery = true:
 Turn on logic that will deliver elem to an alternate peer if the current peer is not live. 
 The logic is disabled at the moment. 
</summary>
</member>
<member name="P:Prajna.Core.DParam.Cluster">
<summary>
 Get and Set Cluster 
</summary>
</member>
<member name="P:Prajna.Core.DParam.CacheType">
<summary>
 Retrieve the Index Type alone
</summary>
</member>
<member name="M:Prajna.Core.DParam.ReplicateBaseMetadata(Prajna.Core.DParam)">
<summary>
 Copy metadata
</summary>
</member>
<member name="M:Prajna.Core.DParam.GetCluster">
<summary>
 Get Current Cluster associated with the object, if the current cluster is not set, use the default cluster 
</summary>
</member>
<member name="M:Prajna.Core.DParam.EncodeStorageFlag">
<summary>
 Encode Storage flag 
</summary>
</member>
<member name="M:Prajna.Core.DParam.#ctor(Prajna.Core.DParam)">
<summary>
 Construct a DParam object based on a prior template 
</summary>
</member>
<member name="M:Prajna.Core.DParam.#ctor">
<summary>
 Construct a empty DParam object
</summary>
</member>
<member name="T:Prajna.Core.DParam">
<summary>
 DParam, setting parameters for DSet mapping
 Base of PrajnaDistributed Object
</summary>
</member>
<member name="F:Prajna.Core.DSet.SyncEncode@">
<summary>
 Encode a collection of data
</summary>
</member>
<member name="F:Prajna.Core.DSet.TimeoutSleep@">
<summary>
 Sleep (in ms) if Timeout is triggered
</summary>
</member>
<member name="F:Prajna.Core.DSet.TimeoutLimit@">
<summary>
 Timeout limit (in second, if still can&apos;t write any parition )
</summary>
</member>
<member name="F:Prajna.Core.DSet.TimeoutMultiple@">
<summary>
 Timeout Multiple, timeout throttling &amp; error flagging is triggered if SerializationLimit * TimeoutMultiple can&apos;t be sent out 
</summary>
</member>
<member name="F:Prajna.Core.DSet.MinValidResponded@">
<summary>
 For Metadata read, # of valid response that need before we consider the metadata to be valid 
 If the # is minus, it is considered a percentage number of the cluster. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.MinNodeResponded@">
<summary>
 For Metadata read, # of nodes that need to respond before we consider the metadata to be valid 
 If the # is minus, it is considered a percentage number of the cluster. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.MappingStreamLength@">
<summary>
 A mapping matrix indicates Length of stream in each partition
</summary>
</member>
<member name="F:Prajna.Core.DSet.MappingNumElems@">
<summary>
 A mapping matrix indicates number of Key Values in each partition
</summary>
</member>
<member name="F:Prajna.Core.DSet.MetaDataVersion@">
<summary>
 DSet&apos;s meta data may have a version. The version is associated with DSet######.meta and records system&apos;s status of a current DSet
 ( e.g., whether passed integrity check, whether has index, change of mapping, etc.. )
</summary>
</member>
<member name="F:Prajna.Core.DSet.NumParallelExecution@">
<summary>
 Maximum number of parallel threads that will execute the data analytic jobs in a remote container. 
 If 0, the remote container will determine the number of parallel threads used according to its computation and memory resource
 available. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.ChildDSet@">
<summary>
 Downstream dependency
</summary>
</member>
<member name="F:Prajna.Core.DSet.DependencyDownstream@">
<summary>
 Downstream dependency
</summary>
</member>
<member name="F:Prajna.Core.DSet.Dependency@">
<summary>
 Required number of replication for durability
 Upstream dependency
</summary>
</member>
<member name="F:Prajna.Core.DSet.PartionBy@">
<summary>
 Specify what resource that the DSet is using (RAM, SSD, HDD or Uniform ) when construction the partitioning function. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.MaxWait@">
<summary>
 Maximum time to wait for execution of a certain command (in second)
</summary>
</member>
<member name="F:Prajna.Core.DSet.rcvdSerialInitialValue">
<summary>
 Used to establish a serial # within each partition
</summary>
</member>
<member name="F:Prajna.Core.DSet.partitionSerialConfirmed">
<summary>
 Used to establish a serial # within each partition
</summary>
</member>
<member name="F:Prajna.Core.DSet.partitionSerial">
<summary>
 Used to establish a serial # within each partition
</summary>
</member>
<member name="F:Prajna.Core.DSet.partitionPending">
<summary>
 Outstanding command in partitioning. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.partitionProgress">
<summary>
 Partition Progress monitoring. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.partitionCheckmark">
<summary>
 Partition Progress monitoring. 
</summary>
</member>
<member name="F:Prajna.Core.DSet.deliveryQueue">
<summary>
 A dictionary that holds key, values that is used to confirm the successful store of DSet. 
 If a certain peer becomes unavailable, we may choose to redelivery the elem
 Key: byte[], hash (Fletcher64 currently) of the elem stream to be stored. 
 Value: &lt; Time: in CLock.ElapsedTicks, 
          parti: partition value (used for redelivery
          byte[]: the byte sent by the network queue 
          int: count of delivery )
</summary>
</member>
<member name="M:Prajna.Core.DSet.sizeInBytes(Prajna.Core.DSet)">
 <summary> 
 The storage footprint of the DSet. This function can only be used for Source/Destination DSet that is persisted, it will return Int64.MinValue for other DSet. </summary>
 <return> storage footprint in bytes. </return>
</member>
<member name="P:Prajna.Core.DSet.TimeoutSleep(System.Int32)">
<summary>
 Sleep (in ms) if Timeout is triggered
</summary>
</member>
<member name="P:Prajna.Core.DSet.TimeoutMultiple(System.Int32)">
<summary>
 Timeout Multiple, timeout throttling &amp; error flagging is triggered if SerializationLimit * TimeoutMultiple can&apos;t be sent out 
</summary>
</member>
<member name="P:Prajna.Core.DSet.TimeoutLimit(System.Int32)">
<summary>
 Timeout limit (in second, if still can&apos;t write any parition )
</summary>
</member>
<member name="P:Prajna.Core.DSet.SyncEncode(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte}},Microsoft.FSharp.Core.Unit},System.Tuple{System.Threading.ManualResetEvent,System.Boolean}}}})">
<summary>
 Encode a collection of data
</summary>
</member>
<member name="P:Prajna.Core.DSet.PartionBy(Prajna.Core.PartitionByKind)">
<summary>
 Specify what resource that the DSet is using (RAM, SSD, HDD or Uniform ) when construction the partitioning function. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.NumParallelExecution(System.Int32)">
<summary>
 Maximum number of parallel threads that will execute the data analytic jobs in a remote container. 
 If 0, the remote container will determine the number of parallel threads used according to its computation and memory resource
 available. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.NumActiveConnection(System.Int32)">
<summary>
 Number of active outgoing connection from this node in the DSet
</summary>
</member>
<member name="P:Prajna.Core.DSet.Name(System.String)">
<summary>
 Get or set the name of DSet
</summary>
</member>
<member name="P:Prajna.Core.DSet.MinValidResponded(System.Int32)">
<summary>
 For Metadata read, # of valid response that need before we consider the metadata to be valid 
 If the # is minus, it is considered a percentage number of the cluster. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.MinNodeResponded(System.Int32)">
<summary>
 For Metadata read, # of nodes that need to respond before we consider the metadata to be valid 
 If the # is minus, it is considered a percentage number of the cluster. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.MetaDataVersion(System.Int32)">
<summary>
 DSet&apos;s meta data may have a version. The version is associated with DSet######.meta and records system&apos;s status of a current DSet
 ( e.g., whether passed integrity check, whether has index, change of mapping, etc.. )
</summary>
</member>
<member name="P:Prajna.Core.DSet.MaxWait(System.Double)">
<summary>
 Maximum time to wait for execution of a certain command (in second)
</summary>
</member>
<member name="P:Prajna.Core.DSet.MappingStreamLength(System.Int64[][])">
<summary>
 A mapping matrix indicates Length of stream in each partition
</summary>
</member>
<member name="P:Prajna.Core.DSet.MappingNumElems(System.Int32[][])">
<summary>
 A mapping matrix indicates number of Key Values in each partition
</summary>
</member>
<member name="P:Prajna.Core.DSet.IsSource(System.Boolean)">
<summary>
 IsSource = True, Trigger Load Metadata
</summary>
</member>
<member name="P:Prajna.Core.DSet.FirstCommand(System.Boolean[])">
<summary>
 Whether it is the first command of this peer
</summary>
</member>
<member name="P:Prajna.Core.DSet.DependencyDownstream(Prajna.Core.DSetForwardDependency)">
<summary>
 Downstream dependency
</summary>
</member>
<member name="P:Prajna.Core.DSet.Dependency(Prajna.Core.DSetDependencyType)">
<summary>
 Required number of replication for durability
 Upstream dependency
</summary>
</member>
<member name="P:Prajna.Core.DSet.ContentKey(System.UInt64)">
<summary>
 Set a content key for DSet that governs partition mapping, 
 For two DSets that have the same content key, a single key will be mapped uniquely to a partition
</summary>
</member>
<member name="P:Prajna.Core.DSet.ChildDSet(Prajna.Core.DependentDSet)">
<summary>
 Downstream dependency
</summary>
</member>
<member name="M:Prajna.Core.DSet.length(Prajna.Core.DSet)">
 <summary> 
 The number of values in the DSet. This function can only be used for Source/Destination DSet that is persisted, it will return Int64.MinValue for other DSet. </summary>
 <return> number of values </return>
</member>
<member name="P:Prajna.Core.DSet.TimeoutSleep">
<summary>
 Sleep (in ms) if Timeout is triggered
</summary>
</member>
<member name="P:Prajna.Core.DSet.TimeoutMultiple">
<summary>
 Timeout Multiple, timeout throttling &amp; error flagging is triggered if SerializationLimit * TimeoutMultiple can&apos;t be sent out 
</summary>
</member>
<member name="P:Prajna.Core.DSet.TimeoutLimit">
<summary>
 Timeout limit (in second, if still can&apos;t write any parition )
</summary>
</member>
<member name="P:Prajna.Core.DSet.SyncEncode">
<summary>
 Encode a collection of data
</summary>
</member>
<member name="P:Prajna.Core.DSet.SizeInBytes">
 <summary>
 Get the size of all key-values or blobs in DSet
 </summary>
</member>
<member name="P:Prajna.Core.DSet.RcvdSerialInitialValue">
<summary>
 Initial Receiving Serial Value of a peer before the first command of this DSet (usually SET DSet) is issued. 
 Checking this value can indicate whether any command has been received from the server. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.PartionBy">
<summary>
 Specify what resource that the DSet is using (RAM, SSD, HDD or Uniform ) when construction the partitioning function. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.NumParallelExecution">
<summary>
 Maximum number of parallel threads that will execute the data analytic jobs in a remote container. 
 If 0, the remote container will determine the number of parallel threads used according to its computation and memory resource
 available. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.NumActiveConnection">
<summary>
 Number of active outgoing connection from this node in the DSet
</summary>
</member>
<member name="P:Prajna.Core.DSet.Name">
<summary>
 Get or set the name of DSet
</summary>
</member>
<member name="P:Prajna.Core.DSet.MinValidResponded">
<summary>
 For Metadata read, # of valid response that need before we consider the metadata to be valid 
 If the # is minus, it is considered a percentage number of the cluster. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.MinNodeResponded">
<summary>
 For Metadata read, # of nodes that need to respond before we consider the metadata to be valid 
 If the # is minus, it is considered a percentage number of the cluster. 
</summary>
</member>
<member name="P:Prajna.Core.DSet.MetaDataVersion">
<summary>
 DSet&apos;s meta data may have a version. The version is associated with DSet######.meta and records system&apos;s status of a current DSet
 ( e.g., whether passed integrity check, whether has index, change of mapping, etc.. )
</summary>
</member>
<member name="P:Prajna.Core.DSet.MaxWait">
<summary>
 Maximum time to wait for execution of a certain command (in second)
</summary>
</member>
<member name="P:Prajna.Core.DSet.MappingStreamLength">
<summary>
 A mapping matrix indicates Length of stream in each partition
</summary>
</member>
<member name="P:Prajna.Core.DSet.MappingNumElems">
<summary>
 A mapping matrix indicates number of Key Values in each partition
</summary>
</member>
<member name="P:Prajna.Core.DSet.Length">
 <summary>
 Get the number of key-values or blobs in DSet. .Length can be applied to either 1) source DSet (metadata is read via .LoadSource()), 
 2) intermediate DSet which is derived from source DSet, 
 or 3) destination DSet after save operation has succeeded. 
 </summary>
</member>
<member name="P:Prajna.Core.DSet.FirstCommand">
<summary>
 Whether it is the first command of this peer
</summary>
</member>
<member name="P:Prajna.Core.DSet.DependencyDownstream">
<summary>
 Downstream dependency
</summary>
</member>
<member name="P:Prajna.Core.DSet.Dependency">
<summary>
 Required number of replication for durability
 Upstream dependency
</summary>
</member>
<member name="P:Prajna.Core.DSet.ContentKey">
<summary>
 Set a content key for DSet that governs partition mapping, 
 For two DSets that have the same content key, a single key will be mapped uniquely to a partition
</summary>
</member>
<member name="P:Prajna.Core.DSet.ChildDSet">
<summary>
 Downstream dependency
</summary>
</member>
<member name="M:Prajna.Core.DSet.WriteCommon(System.Int32,System.Int32,Prajna.Tools.StreamBase{System.Byte},Prajna.Core.ControllerVerb)">
<summary>
 Common Write Routine for DSets. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.WriteAndReplicate(System.Int32,System.Int32,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Write and replicate peer data to the DSet
</summary>
</member>
<member name="M:Prajna.Core.DSet.Write(System.Int32,System.Int32,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Write certain data to the DSet
</summary>
</member>
<member name="M:Prajna.Core.DSet.Unpack(Prajna.Tools.StreamBase{System.Byte},System.Boolean)">
<summary>
 Deserialization of DSet 
</summary>
</member>
<member name="M:Prajna.Core.DSet.TryLoadDSetMetadata(System.Boolean)">
<summary>
 Try Load Metadata, search local metadata store to find the latest metadata file 
</summary>
</member>
<member name="M:Prajna.Core.DSet.TryExecuteSingleJobAction">
<summary>
 Grab a single job action object, when secured, the cancellation of the underlying jobLifeCycle object will be delayed 
 until this action completes. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.SyncInit(Prajna.Core.JobInformation,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object},Microsoft.FSharp.Core.Unit})">
<summary>
 Implement init for source
</summary>
</member>
<member name="M:Prajna.Core.DSet.SyncExecuteDownstreamImpl(Prajna.Core.JobInformation,System.Int32,Prajna.Core.BlobMetadata,System.Object)">
<summary>
 Iterate Children, in downstream direction. 
 The downstream iteration has a push model, in which BlobMetadata*Object are pushed down for result
</summary>
</member>
<member name="M:Prajna.Core.DSet.SyncEncodeImpl(Prajna.Core.JobInformation,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte}},Microsoft.FSharp.Core.Unit})">
<summary>
 Encode a collection of data
</summary>
</member>
<member name="M:Prajna.Core.DSet.SetupPartitionMappingImpl">
<summary>
 Setup partition mapping for use in save
 derivatives &amp; version information
</summary>
</member>
<member name="M:Prajna.Core.DSet.SetupDependencyHashImpl">
<summary>
 Setup Dependency hash
</summary>
</member>
<member name="M:Prajna.Core.DSet.SendCancelWriteToNetwork">
<summary>
 Sending cancellation to all other peers. 
 Job should not be cancelled at that time
</summary>
</member>
<member name="M:Prajna.Core.DSet.SaveToMetaData(System.String,Prajna.Core.DSetMetadataStorageFlag)">
<summary>
 Save the Meta Data of DSet to a file 
</summary>
</member>
<member name="M:Prajna.Core.DSet.SaveToMetaData(System.IO.Stream,Prajna.Core.DSetMetadataStorageFlag)">
<summary>
 Save the Meta Data of DSet to a stream
</summary>
</member>
<member name="M:Prajna.Core.DSet.SaveMetadata">
<summary>
 Save Metadata
</summary>
</member>
<member name="M:Prajna.Core.DSet.RootPath">
<summary>
 The root path information for the metadata, used for all DSet of different version.
</summary>
</member>
<member name="M:Prajna.Core.DSet.RootMetadataPath">
<summary>
 Root metadata path
</summary>
</member>
<member name="M:Prajna.Core.DSet.RetrieveFolderRecursive(System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Byte[]}})">
<summary>
 store a seq&lt;string, byte[]&gt; (e.g., that is retrieved from DSet.toSeq() 
 to a local folder. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.RequiredNodes(System.Int32)">
<summary>
 Translate required numeber of nodes, such as MinNodeResponded, MinValidResponded to a number based
 on cluster size. if v&gt;0, v is # of nodes, if v&lt;0, v is interpretted as percentage #
</summary>
</member>
<member name="M:Prajna.Core.DSet.ReportPartition(System.Int32,System.Tuple{System.Int32,System.Int32,System.Int64}[])">
<summary>
 Give a Report that for peeri.
 activePartition is an array, where the two element in the array is parti, numElems written in partition i. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.ReportDSet(System.Int32,System.Tuple{System.Int32,System.Int32,System.Int64}[],System.Boolean)">
<summary>
 Give a Report that for peeri.
 activePartition is an array, where the two element in the array is parti, numElems written in partition i. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.ReplicationAnalysis">
<summary>
 Replication Analysis
 Return: true: no error
         false: some error
</summary>
</member>
<member name="M:Prajna.Core.DSet.PrecodeDependentObjsImpl">
<summary>
 Only bypass has only parents as its dependency
</summary>
</member>
<member name="M:Prajna.Core.DSet.PathInfo">
<summary>
 The path information for the metadata
</summary>
</member>
<member name="M:Prajna.Core.DSet.Pack(Prajna.Tools.StreamBase{System.Byte},Microsoft.FSharp.Core.FSharpOption{Prajna.Core.DSetMetadataStorageFlag},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Serialization of dset to Memory Stream, couldn&apos;t figure out the best way for customized serialization of compact in F#
 so I wrote my own function of pack &amp; unpack. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.OnCancelWriteJob">
<summary>
 Finalize write
</summary>
</member>
<member name="M:Prajna.Core.DSet.MetadataFilename">
<summary>
 DSet metadata name
</summary>
</member>
<member name="M:Prajna.Core.DSet.LoadMetadata(Prajna.Tools.MemoryStreamB,System.Boolean)">
<summary>
 Try Load Metadata, search local metadata store to find the latest metadata file 
</summary>
</member>
<member name="M:Prajna.Core.DSet.IsTimeout(System.Int32)">
<summary>
 Is a certain partition timeout, this is defined as no write operation to queue 
 for TimeoutLimit second. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.InterpretStorageFlag(System.Int32)">
<summary>
 Decode Storage flag 
 Return: (bPassword, bConfirmDelivery )
</summary>
</member>
<member name="M:Prajna.Core.DSet.Initialize">
<summary>
 Initialize connect to all peers that needed for DSet operation. 
 This is an internal function that should be called once per each DSet. 
 Main function is to SetupPartitionMapping. If the partition mapping is already available (e.g., read in), 
 don&apos;t call this function. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.HashNameVersion">
<summary>
 Bind Hash only to the name &amp; version of the DSet (used for persisted DSet only). 
</summary>
</member>
<member name="M:Prajna.Core.DSet.GracefulWaitForReprot(System.Double)">
<summary>
 End Partition parti peeri
 Graceful shutdown:
 Wait for clients to shut down, i.e., to receive a confirmation of (Report, DSet) or (ReportClose, DSet)
 maxWait: maximum wait for time, in seconds. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.GetSerialForWrite(System.Int32,System.Int32)">
<summary>
 Serial Number Used for parition parti 
</summary>
</member>
<member name="M:Prajna.Core.DSet.FolderRecursiveSeq(System.String,System.String,System.IO.SearchOption)">
<summary>
 Turn a local or network folder into seq&lt;string, byte[]&gt; to be fed into DSet.store
 sPattern, sOption is the search pattern and option used in Directory.GetFiles
</summary>
</member>
<member name="M:Prajna.Core.DSet.EndWriteToNetwork(System.Double)">
<summary>
 EndStore: called to end storing operation of a DSet to cloud
</summary>
</member>
<member name="M:Prajna.Core.DSet.EndWriteJob">
<summary>
 Normal ending of a write job 
</summary>
</member>
<member name="M:Prajna.Core.DSet.EndParition(System.Int32,System.Int32)">
<summary>
 End partition parti peeri
</summary>
</member>
<member name="M:Prajna.Core.DSet.System-IComparable`1-CompareTo(Prajna.Core.DSet)">
<summary>
 Defining IComparable interface of DSet
</summary>
</member>
<member name="M:Prajna.Core.DSet.ClearTimeout(System.Int32)">
<summary>
 Any write operation will trigger ClearTimeout()
</summary>
</member>
<member name="M:Prajna.Core.DSet.ChangeSerializationLimitImpl(System.Int32)">
<summary>
 Number of record in a collection during data analytical jobs 
</summary>
</member>
<member name="M:Prajna.Core.DSet.CancelWriteByException(System.Exception)">
<summary>
 Cancel by Exception
</summary>
</member>
<member name="M:Prajna.Core.DSet.CanWrite(System.Int32)">
<summary>
 CanWrite: can we write to partition i, and which peer should it be write to?
 Return: a list of peer idx that it should write to. 
     [| -1 |] : all peers are blocked, please check later to write. 
     [| Int32.MinValue |] : no peer can be found to write this partition, the caller may want to raise an exception. 
     one peer for P2PReplicate or ClusterReplicate, a list of peers for DirectReplicate
</summary>
</member>
<member name="M:Prajna.Core.DSet.BeginWriteToNetwork">
<summary>
 BeginStore: called to begin storing operation of a DSet to cloud. 
</summary>
</member>
<member name="M:Prajna.Core.DSet.AsyncInit(Prajna.Core.JobInformation,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object},Microsoft.FSharp.Core.Unit})">
<summary>
 Implement init for source
</summary>
</member>
<member name="M:Prajna.Core.DSet.AggregateSegmentByPeer(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32,System.Int64,System.Int32}})">
<summary>
 AggregateSegmentByPeer will processing series of:
     peeri, parti, serial, numElems
 into 
     Array of peers (numPeers items ), each element with
         Array of parti, with serial:numElems[] that are continuous. 
</summary>
</member>
<member name="T:Prajna.Core.DSet">
<summary>
 DSet is a distributed data set. It is one of the central entity in Prajna. 
 Please use the generic version of this class. 
</summary>
</member>
<member name="F:Prajna.Core.DSetAction.FurtherDSetCallback@">
<summary>
 Additional Callback 
</summary>
</member>
<member name="F:Prajna.Core.DSetAction.TimeoutVal@">
<summary>
 Timeout value 
</summary>
</member>
<member name="F:Prajna.Core.DSetAction.FuncArgument@">
<summary>
 Prajna function argument, in a serialized memory stream
</summary>
</member>
<member name="F:Prajna.Core.DSetAction.Verb@">
<summary>
 Prajna command argument
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.Verb(Prajna.Core.ControllerVerb)">
<summary>
 Prajna command argument
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.TimeoutVal(System.Int64)">
<summary>
 Timeout value 
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.Params(System.Collections.Generic.IEnumerable{Prajna.Core.DSet})">
<summary>
 Set Multiple Parameters
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.Param(Prajna.Core.DSet)">
<summary>
 Add one Prajna job parameter
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.Job(Prajna.Core.Job)">
<summary>
 Hold a Job object
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.FurtherDSetCallback(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64,Prajna.Core.Cluster},System.Boolean})">
<summary>
 Additional Callback 
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.FuncArgument(Prajna.Tools.MemoryStreamB)">
<summary>
 Prajna function argument, in a serialized memory stream
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.Verb">
<summary>
 Prajna command argument
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.TimeoutVal">
<summary>
 Timeout value 
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.ParameterList">
<summary>
 Get Prajna Job parameters
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.Job">
<summary>
 Hold a Job object
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.FurtherDSetCallback">
<summary>
 Additional Callback 
</summary>
</member>
<member name="P:Prajna.Core.DSetAction.FuncArgument">
<summary>
 Prajna function argument, in a serialized memory stream
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.TryExecuteSingleJobAction">
<summary>
 Grab a single job action object, when secured, the cancellation of the underlying jobLifeCycle object will be delayed 
 until this action completes. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.SendCancelJobToAllPeers">
<summary>
 Send Cancel JOb to all peers. This action is executed when cancellation happen (whether by a certain peer or by user )
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.RetrieveMetaData">
<summary>
 Retrieve Metadata of all source DSetS. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.ReleaseAllJobResource">
<summary>
 ToDo:
     Specifically release all resource that is hold by the current job. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.RegisterGVCallback(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64,Prajna.Core.Cluster},System.Boolean}})">
<summary>
 Register call back for GV
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.OrderlyEndAction">
<summary>
 Marked the action as normally complete (not cancelled). 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.InitializeJob">
<summary>
 InitializeGlobalJob set up one Prajna Job to be used across multiple DSetActions. 
 In such a case, the programmer should define all actions to be executed, before actually calling the action to maximize execution efficiency
 Initialize Job 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.GetJobInstance(Prajna.Core.DSet)">
<summary>
 Get a job instance associated with a particular DSet
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.GVCallback(Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64,Prajna.Core.Cluster)">
<summary>
 Process GV Call back 
 Return: true -&gt; Command has been parsed. 
         false -&gt; Command has not been parsed, subsequent callback should handle the command. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.EndRegister">
<summary>
 Called to shutdown the reading data from Prajna, note that normally, the read operation is 
 graceful shutdown automatically. EndRead is not absolutely necessary to be called. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.EndAction">
<summary>
 This action done at the end of the Job 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.DSetCallback(Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64,Prajna.Core.Cluster)">
<summary>
 Process DSet Call back 
 Return: 1st param true -&gt; Command has been parsed. 
                   false -&gt; Command has not been parsed, subsequent callback should handle the command. 
         2nd param true -&gt; Command has been processed
                   false -&gt; Command has been blocked. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.CloseAndUnregister">
<summary>
 This is used as an example if DSetAction is to be derived. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.BeginRegister">
<summary>
 Register call back for all DSet involved
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.BaseEndAction">
<summary>
 This is used as an example if DSetAction is to be derived. 
</summary>
</member>
<member name="M:Prajna.Core.DSetAction.BaseBeginAction(Prajna.Core.TaskLaunchMode)">
<summary>
 This is used as an example if DSetAction is to be derived. 
</summary>
</member>
<member name="T:Prajna.Core.DSetAction">
<summary>
 DSetAction is a wrapper class to perform action on one set of DSet. 
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.CrossJoinFrom">
<summary>
 Cross join two DSets 
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.HashJoinFrom">
<summary>
 Hash join two DSets
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.DecodeFrom">
<summary>
 Decode from another stream
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.Bypass">
<summary>
 Bypass: one parentDSet with multiple side streams, the first DSet on the list is the parentDSet
 while the rest are considered siblings. 
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.WildMixFrom">
<summary>
 Wild Mix: the upper parents sends information through repartitioning function, may cross network 
 If the information is within the same node, the information is pushed down to the 1st DSet straightforward, 
 If the information is sent across the network, the information is sent to the 2nd DSet, which will merge with the 1st DSet in some later time.
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.MixFrom">
<summary>
 MixInNode: the upper parents send information through repartitioning function, doesn&apos;t across networkk
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.MergeFrom">
<summary>
 MergeFrom mix multiple upstream DSet, the downstream DSet has number of partitions equal to the sum of all partitions of upstream DSet. 
 Merge should only be used in pull dataflow. 
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.CorrelatedMixFrom">
<summary>
 CorrelatedMix is inverse of DistributeForward, in which the downstream DSet will mix data from multiple upstream sources
 Each upstream DSet should have the same number of partitions. 
 CorrelatedMix should only be used in pull dataflow. 
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.Passthrough">
<summary>
 Passthrough is a common type of dependency, with only a single parentDSet with same partition mapping structure
 Partition Mapping, Content Key of the derived DSet is inheritted from the patent DSet
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.Source">
<summary>
 Source will generate data by calling the map function. It is used to implement DSet.init. 
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType.StandAlone">
<summary>
 The current DSet doesn&apos;t depend on other DSet, it is a source or sink
</summary>
</member>
<member name="T:Prajna.Core.DSetDependencyType">
<summary>
 For backward dependency, trace back on what other DStream/DObject that this DSet depends upon
</summary>
</member>
<member name="M:Prajna.Core.DSetEnumerator`1.GetCurrent">
<summary>
 After an enumerator is created or after the Reset method is called, the MoveNext method must be called to advance 
 the enumerator to the first element of the dataset before reading the value of the Current property; otherwise, 
 Current is undefined.
</summary>
</member>
<member name="M:Prajna.Core.DSetEnumerator`1.EndRead">
<summary>
 Called to shutdown the reading data from Prajna, note that normally, the read operation is 
 graceful shutdown automatically. EndRead is not absolutely necessary to be called. 
</summary>
</member>
<member name="M:Prajna.Core.DSetEnumerator`1.DoMoveNext">
<summary>
 MoveNext method must be called to advance the enumerator to the first element of the dataset before reading the 
 value of the Current property; otherwise, current is undefined.
</summary>
</member>
<member name="M:Prajna.Core.DSetEnumerator`1.BeginRead">
<summary>
 Start retrieving data from Prajna, the call will block until MetaData of DSet is retrieved
</summary>
</member>
<member name="T:Prajna.Core.DSetEnumerator`1">
<summary>
 DSet is a distributed key-value set
 It is one of the foundation class in Prajna for computing. 
 The design of DSet follows HashMultiMap, which is a cascade Dictionary that allows multiple values per key
</summary>
</member>
<member name="T:Prajna.Core.DSetFlag">
<summary>
 DSetFlag Controlling behavior of the DSet at host
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.CrossJoinTo">
<summary>
 Cross join two DSets 
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.HashJoinTo">
<summary>
 Hash join two DSets
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.SaveTo">
<summary>
 Save to another stream, the DSet is a destination DSet
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.EncodeTo">
<summary>
 Encode to another stream
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.DistributeForward">
<summary>
 Distribute DSet to multiple DSet
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.WildMixTo">
<summary>
 Wild Mix: the upper parents sends information through repartitioning function, may cross network 
 If the information is within the same node, the information is pushed down to the dependentDSet, 
 If the information is sent across the network, the information is sent to the DependentDStream. 
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.MixTo">
<summary>
 Mix within node, the upper parents send information through repartitioning function, doesn&apos;t across networkk
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.MergeTo">
<summary>
 MergeTo mix multiple upstream DSet, the downstream DSet has number of partitions equal to the sum of all partitions of upstream DSet. 
 Merge should only be used in pull dataflow. 
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.CorrelatedMixTo">
<summary>
 CorrelatedMix is inverse of DistributeForward, in which the downstream DSet will mix data from multiple upstream sources
 Each upstream DSet should have the same number of partitions. 
 CorrelatedMix should only be used in pull dataflow. 
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.Passforward">
<summary>
 Send DSet downward
</summary>
</member>
<member name="T:Prajna.Core.DSetForwardDependency.Discard">
<summary>
 no action, if content is pushed downstream, it will be discarded here
</summary>
</member>
<member name="F:Prajna.Core.DSetPeer.streamLength">
<summary>
 sream size
</summary>
</member>
<member name="F:Prajna.Core.DSetPeer.partitionSize">
<summary>
 partition size
</summary>
</member>
<member name="F:Prajna.Core.DSetPeer.peerEndPartition">
<summary>
 peer that has sent endPartition command
</summary>
</member>
<member name="F:Prajna.Core.DSetPeer.peerWriteDSet">
<summary>
 peer that has written to DSet
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.WriteDSetMetadata">
<summary>
 parti.ToString(&quot;00000000&quot;)+&quot;.dat&quot;
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.Unpack``1(Prajna.Tools.StreamBase{System.Byte},``0,Prajna.Core.NetworkCommandQueue,System.Guid)">
<summary>
 Deserlization of dset
 A copy of input stream ms is made so that if the deserialization is unsuccessful with some missing argument, the missing argument be requested from communication partner. 
 After that, the ms stream can be attempted to be unpacked again. 
 Rewritten to use the DSet.Unpack
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.TryReplicate">
<summary>
 Try to sent out replication stream
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.SyncReadChunkImpl(Prajna.Core.JobInformation,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte}},Microsoft.FSharp.Core.Unit})">
<summary>
 Read one chunk in async work format. 
 Return: Async&lt;byte[]&gt;, if return null, then the operation reads the end of stream of partition parti. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.RemoveInactiveQueues">
<summary>
 Check for active quueues. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.RemoveCommandQueue(Prajna.Core.NetworkCommandQueue)">
<summary>
 Remove a Command Queue
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.ReadyStoreStreamArray">
<summary>
 Open a partition for read
 Return: True: first time that the store stream is used
         False: not first time. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.ReadFromMetaData(System.String,Prajna.Core.NetworkCommandQueue,System.Guid)">
<summary>
 Read from Meta Data file
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.ReadFromMetaData(System.IO.Stream,Prajna.Core.NetworkCommandQueue,System.Guid)">
<summary>
 Read from Meta Data file
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.PrepareReplicationWrite``1(``0)">
<summary>
 BeginReplicationWrite: called to begin replication operation of a DSet
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.PartitionExist(System.Int32[])">
<summary>
 Is a certain partition exist?
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.MetaDataName">
<summary>
 Construct meta Data name.
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.GetStorageProvider">
<summary>
 Construct storage provider if not exist   
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.GetHashProvider(System.Int32)">
<summary>
 Setup Hash Provider
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.GetAesAlg(System.Int32)">
<summary>
 Setup Hash Provider
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.EndReplicate(Prajna.Core.NetworkCommandQueue,System.Int32,System.Collections.Generic.Dictionary{System.Object,Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Boolean}})">
<summary>
 EndStore: called to end storing operation of a DSet to cloud
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.EndPartition``1(Prajna.Tools.StreamBase{System.Byte},Prajna.Core.NetworkCommandQueue,System.Int32,``0)">
<summary>
 EndPartition: mark the end of partition i. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.EmptyPartition(System.Int32)">
<summary>
 Test for Empty Partition 
 Return: true for partition with 0 keys
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.ComputeActivePartition``1(``0)">
<summary>
 Based on the connection queue that is still alive, compute active partition 
 queue: the calling queue, so that queue is being closed. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.CloseNonActiveStreams``1(``0)">
<summary>
 Compute active partitions, close streams that are no longer active (i.e., all peers that potentially can write to the partition has called close)
 Return: 
     bool[] indicating whether a partition is still active. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.CloseDSet(System.Guid,Prajna.Tools.StreamBase{System.Byte},Prajna.Core.NetworkCommandQueue,System.Boolean,System.Collections.Generic.Dictionary{System.Object,Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Boolean}})">
<summary>
 Close DSet
 bReplicate = true,  ReplicateClose, DSet is called (from other peer)
            = false, Close, DSet is called (from host) 
 no need to further call to ReplicateClose. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.AsyncReadChunk(Prajna.Core.JobInformation,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,Prajna.Tools.MemoryStreamB},Microsoft.FSharp.Core.Unit})">
<summary>
 Read one chunk in async work format. 
 Return: Async&lt;byte[]&gt;, if return null, then the operation reads the end of stream of partition parti. 
</summary>
</member>
<member name="M:Prajna.Core.DSetPeer.AddCommandQueue(Prajna.Core.NetworkCommandQueue)">
<summary>
 Add a Command Queue, check if this is from host
</summary>
</member>
<member name="T:Prajna.Core.DSetPeer">
<summary>
 DSetPeer acts either as source and/or destination DSet. It has dependancyType of StandAlone. Only DSetPeer is allowed to interact with Source Stream or Sinks.
 DSetPeer does not have function attached to it. Function must be installed on an upstream/downstream DSet, which can be an identity DSet. 
</summary>
</member>
<member name="M:Prajna.Core.DSetTaskRead.RetrieveMetaData">
<summary>
 Retrieve meta data
</summary>
</member>
<member name="T:Prajna.Core.DSetTaskRead">
<summary>
 DSetTaskRead is a wrapper class to perform task control (e.g., readback metadata, map peer to DSet
</summary>
</member>
<member name="F:Prajna.Core.DStream.QueueNumberForOutgoingTasks@">
<summary>
 Encode from another object
</summary>
</member>
<member name="F:Prajna.Core.DStream.DependencyDownstream@">
<summary>
 Forward Dependency
</summary>
</member>
<member name="F:Prajna.Core.DStream.Dependency@">
<summary>
 Dependency
</summary>
</member>
<member name="P:Prajna.Core.DStream.QueueNumberForOutgoingTasks(System.Int32)">
<summary>
 Encode from another object
</summary>
</member>
<member name="P:Prajna.Core.DStream.DependencyDownstream(Prajna.Core.DStreamForwardDependencyType)">
<summary>
 Forward Dependency
</summary>
</member>
<member name="P:Prajna.Core.DStream.Dependency(Prajna.Core.DStreamDependencyType)">
<summary>
 Dependency
</summary>
</member>
<member name="P:Prajna.Core.DStream.QueueNumberForOutgoingTasks">
<summary>
 Encode from another object
</summary>
</member>
<member name="P:Prajna.Core.DStream.DependencyDownstream">
<summary>
 Forward Dependency
</summary>
</member>
<member name="P:Prajna.Core.DStream.Dependency">
<summary>
 Dependency
</summary>
</member>
<member name="M:Prajna.Core.DStream.Unpack``1(Prajna.Tools.StreamBase{System.Byte},``0)">
<summary>
 Deserialization of DStream 
</summary>
</member>
<member name="M:Prajna.Core.DStream.SyncSendPeer``1(Prajna.Core.JobInformation,``0,Prajna.Core.BlobMetadata,System.Object,System.Int32)">
<summary>
 Sync Send Peer operation 
 This may have problem as if there is no flow control to slow down the sending client, very long queue can pile up at network, which 
 will exhuast memory of the machine. 
 SyncSendPeer needs to be threadsafe, and we assume that synchronization is done via peerQueue.ToSend
 HZ Li: make SyncSendPeer to be threadsafe to ensure flow control works correctly
 if there is no flow control, receiver&apos;s receive TCP buffer may be full and sender need to retransmit packages and reset the connection eventally. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.SyncPreCloseAllStreamsImpl(Prajna.Core.JobInformation)">
<summary>
 For Sync End wait
</summary>
</member>
<member name="M:Prajna.Core.DStream.SyncIterateDownstream(Prajna.Core.JobInformation,System.Int32,Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte},System.Int32)">
<summary>
 Iterate Children, in downstream direction. 
 The downstream iteration has a push model, in which BlobMetadata*Object are pushed down for result
 No function is attached at the end. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.SyncFlushPartitionTask(System.Int32,System.Int32)">
<summary>
 Flush task 
</summary>
</member>
<member name="M:Prajna.Core.DStream.SyncExecuteDownstreamImpl(Prajna.Core.JobInformation,System.Int32,Prajna.Core.BlobMetadata,System.Object)">
<summary>
 SourceStream: the current DStream doesn&apos;t depend on other DSet, it is a source 
 Push down operation
</summary>
</member>
<member name="M:Prajna.Core.DStream.SyncCloseFromPeer(Prajna.Core.NetworkCommandQueue,System.Int32,System.Guid)">
<summary>
 Flush all write, and then confirmed to the source 
 Lock is installed so even if closeFromPeer is called multiple times, it is only flushed once. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.SetupDependencyHashImpl">
<summary>
 Setup Dependency hash
</summary>
</member>
<member name="M:Prajna.Core.DStream.SendAcrossNetwork">
<summary>
 Constract a receiving DStream, and send the content of the current DStream across network. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.ResetForRead">
<summary>
 Reset the stream to be read again
</summary>
</member>
<member name="M:Prajna.Core.DStream.ProcessJobCommand(Prajna.Core.SingleJobActionContainer,Prajna.Core.NetworkCommandQueue,Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte},System.Guid)">
<summary>
 Process incoming command
 Return: 
     false: blocking, need to resend the command at a later time
     true: command processed. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.ProcessCallback(Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid)">
<summary>
 All downstream operation completed? 
 Process feedback of the outgoing command. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.PrecodeDependentObjsImpl">
<summary>
 Encode from another object
 Passthrough
</summary>
</member>
<member name="M:Prajna.Core.DStream.Pack(Prajna.Tools.StreamBase{System.Byte},Microsoft.FSharp.Core.FSharpOption{Prajna.Core.DStreamMetadataStorageFlag})">
<summary>
 Serialization of DStream metadata to Memory Stream. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.GetWriteBufferAndPos(System.Object)">
<summary>
 Get the buffer of write object 
</summary>
</member>
<member name="M:Prajna.Core.DStream.GetHashProvider(System.Int32)">
<summary>
 Setup Hash Provider
</summary>
</member>
<member name="M:Prajna.Core.DStream.GetCryptoProvider``1(System.Int32,``0)">
<summary>
 Setup Crytography provider if not there. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.GetAesAlg(System.Int32)">
<summary>
 Setup Hash Provider
</summary>
</member>
<member name="M:Prajna.Core.DStream.EncryptBuffer(System.Int32,System.String,Prajna.Tools.StreamBase{System.Byte},System.Int32,System.Int32)">
<summary>
 If password is not null, apply encryption 
</summary>
</member>
<member name="M:Prajna.Core.DStream.DecodeDownStreamDepedency(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Passthrough to another stream
</summary>
</member>
<member name="M:Prajna.Core.DStream.DStreamCallback(Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64)">
<summary>
 Parse echoing from DStream from a container to other container
</summary>
</member>
<member name="M:Prajna.Core.DStream.CopyFromUpStream(Prajna.Core.DStream)">
<summary>
 Copy DSet meta data from another DSet
</summary>
</member>
<member name="M:Prajna.Core.DStream.CloseStreamForWrite(System.Int32)">
<summary>
 parti.ToString(&quot;00000000&quot;)+&quot;.dat&quot;
</summary>
</member>
<member name="M:Prajna.Core.DStream.AsyncPackageToSend(Prajna.Core.BlobMetadata,System.Object,System.Guid)">
<summary>
 Push down operation
</summary>
</member>
<member name="M:Prajna.Core.DStream.#ctor(Prajna.Core.DistributedObject)">
<summary>
 inherit dstream from another DistributedObject 
</summary>
</member>
<member name="M:Prajna.Core.DStream.#ctor">
<summary>
 Construct a DStream using the default cluster, the name and version is randomly generated. 
</summary>
</member>
<member name="M:Prajna.Core.DStream.#ctor(Prajna.Core.Cluster)">
<summary>
 Construct a DStream spanned across a cluster, the name and version is randomly generated. 
</summary>
</member>
<member name="T:Prajna.Core.DStream">
<summary>
 DStream is a distributed byte[] stream, a central entity in DSet. 
</summary>
</member>
<member name="T:Prajna.Core.DStreamDependencyType.MulticastFromNetwork">
<summary>
 Get a blob via multicast from network, compared with ReceiveFromNetwork, the main difference is that the Mapping is Full at the receiver
</summary>
</member>
<member name="T:Prajna.Core.DStreamDependencyType.ReceiveFromNetwork">
<summary>
 Get a blob from network
</summary>
</member>
<member name="T:Prajna.Core.DStreamDependencyType.PassFrom">
<summary>
 Passthrough
</summary>
</member>
<member name="T:Prajna.Core.DStreamDependencyType.SaveFrom">
<summary>
 Save to another stream, the DSet is a destination DSet
</summary>
</member>
<member name="T:Prajna.Core.DStreamDependencyType.EncodeFrom">
<summary>
 Encode from another object
</summary>
</member>
<member name="T:Prajna.Core.DStreamDependencyType.SourceStream">
<summary>
 SourceStream: the current DStream doesn&apos;t depend on other DSet, it is a source 
</summary>
</member>
<member name="F:Prajna.Core.DStreamFactory.collectionByJob">
<summary>
 A collection of DStream that serves as the network interface for intercommunication between Jobs. 
 The entry is indexed by jobID, while each entry holds a timestamp (in ticks of int64), of the recent input from that job. 
 That way, we can detect inactive jobs and cancel them later. 
</summary>
</member>
<member name="T:Prajna.Core.DStreamForwardDependencyType.MulticastToNetwork">
<summary>
 Multicast a blob to all destinations in the Mapping
</summary>
</member>
<member name="T:Prajna.Core.DStreamForwardDependencyType.SendToNetwork">
<summary>
 Send a blob to network
</summary>
</member>
<member name="T:Prajna.Core.DStreamForwardDependencyType.PassTo">
<summary>
 Passthrough to another stream
</summary>
</member>
<member name="T:Prajna.Core.DStreamForwardDependencyType.DecodeTo">
<summary>
 DecodeTo another object
</summary>
</member>
<member name="T:Prajna.Core.DStreamForwardDependencyType.SinkStream">
<summary>
 SourceStream: the current DStream doesn&apos;t depend on other DSet, it is a source 
</summary>
</member>
<member name="F:Prajna.Core.DebugMode.LaunchInEither">
<summary>
 Launch container based on the Debug flag in the main module. 
</summary>
</member>
<member name="F:Prajna.Core.DebugMode.LaunchInRelease">
<summary>
 Always launch container in Release Mode. 
</summary>
</member>
<member name="F:Prajna.Core.DebugMode.LaunchInDebug">
<summary>
 Always launch container in Debug Mode. 
</summary>
</member>
<member name="T:Prajna.Core.DebugMode">
<summary>
 Control the launch of container in Debug or Release mode. 
</summary>
</member>
<member name="T:Prajna.Core.DependentDObject">
<summary>
 Dependency of PrajnaObject to construct link between DSet
</summary>
</member>
<member name="T:Prajna.Core.DependentDSet">
<summary>
 Dependency between DSet
</summary>
</member>
<member name="T:Prajna.Core.DependentDStream">
<summary>
 Dependency between DStream and DSet
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxWaitToEndJobInMilliseconds@">
<summary>
 If a job is idle for this much time, it is considered to have problems, and may be cancelled. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.AppDomainUnloadWaitTime@">
<summary>
 The wait time for unload an appdomain that is hosting a daemon or container.
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ContainerMaxWaitForJobToFinish@">
<summary>
 The time interval that the container will wait for a analytical job to complete
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ContainerCheckClientLivenessInterval@">
<summary>
 The time interval that the container will check the liveness of the host client
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LocalClusterTraceLevel@">
<summary>
 Default Trace Level to start Local Cluster
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LocalClusterNumJobPortsPerClient@">
<summary>
 Waiting for thread to terminate
 Default values for local cluster
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.CmdQueueRcvdBufSize@">
<summary>
 receive buffer size of each NetworkCommandQueue
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxSendRcvdSegSize@">
<summary>
 Maximum size of content each async send &amp; recevie can get
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TCPRcvBufSize@">
<summary>
 TCP receiving buffer size
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TCPSendBufSize@">
<summary>
 JinL to SanjeevM: Please review the following parameter 
 should this parameter be scaled according to number of connections? If there are thousands of connections, will the TCP Send/Receive buffer take too large a size?
 TCP sending buffer size
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.EnvStringGetJobDirectory@">
<summary>
 Use curJob.EnvVars.Add( envvar, DeploymentSettings.EnvStringGetJobDirectory) 
 to setup environment string in relationship to the JobDirectory of the remote container. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.EnvStringSetJobDirectory@">
<summary>
 Use curJob.EnvVars.Add(DeploymentSettings.EnvStringSetJobDirectory, depDirname ) to set the JobDirectory of remote container, where curJob is the current JobDependency object. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.OneWaitForAllJobsDone@">
<summary>
 One Wait for all jobs done 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxWaitForAllJobsDone@">
<summary>
 Wait for all jobs done (10hours)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.SleepMSBeforeUnloadAppDomain@">
<summary>
 Sleep Time before unloading appdomain
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.CheckSyncStatusInterval@">
<summary>
 Timer to show sync status
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.PeerMonitorInterval@">
<summary>
 Monitoring for RcvdPeerClose &amp; SendPeerConfirmed (in seconds)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.CollectionTaskTimeout@">
<summary>
 Single Task timeout (max time a single task can execute)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.SingleTaskTimeout@">
<summary>
 Single Task timeout (max time a single task can execute)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MonitorClientBlockingTime@">
<summary>
 Monitor Blocking on the client connecting socket
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MonitorPeerBlockingTime@">
<summary>
 Monitor Blocking on the peer connecting socket
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MonitorDownstreamTaskQueues@">
<summary>
 Warning on long blocking send socket (in seconds)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.WarningLongBlockingSendSocketInMilliseconds@">
<summary>
 Warning on long blocking send socket (in milliseconds)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NetworkActivityMonitorIntervalInMs@">
<summary>
 Monitor Interval for Network Status
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.StandardOutputMonitorIntervalInMs@">
<summary>
 Monitor Interval for StandardError 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.StandardErrorMonitorIntervalInMs@">
<summary>
 Monitor Interval for StandardError 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.AppDomainJobLimit@">
<summary>
 App domain jobs that can be executed in parallel. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ExeJobLimit@">
<summary>
 Separate Exe Jobs that can be executed in parallel
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LightJobLimit@">
<summary>
 Light CPU load jobs that can be executed in parallel 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TotalJobLimit@">
<summary>
 Total Job allowed for Prajna
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelWaitHandle@">
<summary>
 Trace level for WaitHandle
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelSeqFunction@">
<summary>
 Trace Level to Monitor Seq Function
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelBlobValidateHash@">
<summary>
 Validate Hash 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelBlobIO@">
<summary>
 Travel Level for Blob Send/Receive 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ExecutionLevelTouchAssembly@">
<summary>
 Whether we will touch file when dependency/assembly is copied as a SHA256 named file in the remote node. 
 set the parameter to LogLevel.Info will touch dependecy/assembly when they are written. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelStartJob@">
<summary>
 Trace Level for Starting job
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelEveryNetworkIO@">
<summary>
 Trace level for network IO
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelEveryJobBlob@">
<summary>
 Trace Level for Blob Rcvd
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelBlobRcvd@">
<summary>
 Trace Level for Blob Rcvd
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelBlobSend@">
<summary>
 Trace Level for Blob Send
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TraceLevelBlobAvailability@">
<summary>
 Travel Level for Blob Availability 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.IntervalToReconnectDaemonInMs@">
<summary>
 Gap to reconnect to a certain daemon, &lt;0: do not reconnect, 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MonitorIntervalTaskQueueInMs@">
<summary>
 Monitor Interval for Task Queue Status 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutServiceStopInMs@">
<summary>
 Timeout for waiting a service to stop
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.SleepIntervalServiceStopInMs@">
<summary>
 Timeout for waiting a service to stop
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutJobFlushMilliseconds@">
<summary>
 Maximum timeout to Flush the task queue and wait for job to end
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutJobStartTimeSkewAmongPeers@">
<summary>
 Maximum time to wait before the a job start in the current peer (in second)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.WarningJobStartTimeSkewAmongPeers@">
<summary>
 Maximum time to wait before the a job start in the current peer (in second)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutWaitDefaultJobInfo@">
<summary>
 Timeout to wait for DefaultJobInfo in DStream to be filled (in milliseconds) 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutJobPortReservation@">
<summary>
 Timeout for reserve job port
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.RemoteContainerEstablishmentTimeoutLimit@">
<summary>
 Timeout when trying to setup a remote container (in seconds). The default value is 30 seconds. If the remote execution roster is particularly large, 
 e.g., including data files of multi-gigabyte in size, the program should enlarge this timeout value so that there is time to send the entire remote execution roster 
 to the remote node. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutGetRemoteStorageInfo@">
<summary>
 --------------------------
 Various Timeout value
 --------------------------
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.GCMode@">
<summary>
 Garbage Collection Level 
 0: no garbage collection
 1: GC.Collect(1) when no IO activity 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NumObjectsPerJob@">
<summary>
 --------------------------
 Job control parameter
 --------------------------
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.IOThreadPiority@">
<summary>
 --------------------------
 IO Thread parameter
 --------------------------
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxBytesPerPartitionBeforeBlocking@">
<summary>
 Monitor Flow Control 
 --------------------------
 Flow Control Parameter
 --------------------------
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NumNetworkThreads@">
<summary>
 Number of threads for network processing
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.BufferListBufferSize@">
<summary>
 The buffer size of buffers in shared memory pool used by BufferListStream
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.InitBufferListNumBuffers@">
<summary>
 The initial # of buffers for shared memory pool used by BufferListStream
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NetworkSARecvQSize@">
<summary>
 The size of network socket async event args queue for receiving
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NetworkSASendQSize@">
<summary>
 The size of network socket async event args queue for sending
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NetworkCmdRecvQSize@">
<summary>
 The size of network command queue for receiving
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NetworkCmdSendQSize@">
<summary>
 The size of network command queue for sending
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.InitNetworkSocketAsyncEventArgBuffers@">
<summary>
 The initial # of buffers in SocketAsyncEventArg stack
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.NetworkSocketAsyncEventArgBufferSize@">
<summary>
 The buffer size used by SocketAsyncEventArgs
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxNetworkStackMemoryPercentage@">
<summary>
 Maximum network stack memory (total across all connections) as percentage of total (as percent)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxNetworkStackMemory@">
<summary>
 Maximum network stack memory (total across all connections), 0 means unbounded (in bytes)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxSendingQueueLimit@">
<summary>
 JinL to SanjeevM: can you please provide explanation for the following three parameters? 
 Maximum combined buffer devoted to sending queue (in bytes) 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxDownStreamAsyncTasks@">
<summary>
 Maximum Asynchronous Tasks that are allowed to pending in downstream. 
 This is to avoid memory exhaustion if too many tasks are pending 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LongGCInterval@">
<summary>
 Long Garbage Collect Interval (ms)
 If there is always activity for this duration, a deep GC should be exected 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ShortGCInterval@">
<summary>
 Short Garbage Collect Interval (ms)
 If there is always activity for this duration, at least one shallow GC should be exected 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DefaultGroupBySerialization@">
<summary>
 default group by size used in DSet
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ParallelJobsPerCore@">
<summary>
 Control Default Number of Jobs to be executed related to core
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ClientExtensionExcutable@">
<summary>
 Client Extension Process that host unsafe unmanaged code
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.bSaveInitialMetadata@">
<summary>
 Save Initial Metadata?
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TrackSeenKeyValue@">
<summary>
 Track seen partitions
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DefaultIOQueueReadUnblocking@">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DefaultIOMaxQueue@">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DefaultCacheSerializationLimit@">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DefaultSerializationLimit@">
<summary>
 Default SerializationLimit for a DSet
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutForWaitAny@">
<summary>
 WaitAny time for the execution engine
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaxMemoryLimitInMB@">
<summary>
 Maximum Memory 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.MaximumWorkingSet@">
<summary>
 Maximum working set
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.PlatformFlag@">
<summary>
 Whether x86 or x64 bit 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LoadCustomAssebly@">
<summary>
 Whether this is a separate process (AppDomain/Application) 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeoutBeforeDisconnect@">
<summary>
 Final Timeout before disconnect
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.TimeOutAction@">
<summary>
 Timeout for an action (second)
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.SleepTimeJobLoop@">
<summary>
 Sleep time for the main loop in Job. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.IOThreadMonitorTimeSpan@">
<summary>
 Inactive time for monitoring of main thread. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ClientInactiveTimeSpan@">
<summary>
 Inactive time for monitoring of main thread. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.RemappingIntervalInMillisecond@">
<summary>
 Remapping interval (in  sec ), that the host will seek to find a new peer to assign a partition. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.SecondsAfterCloseAfterFlush@">
<summary>
 Second after CloseAfterFlush 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ClusterProcessingAcknoledgementInterval@">
<summary>
 Interval that we will process acknowledgement command (in microsecond). 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.JobIP@">
<summary>
 Port range for JobPort
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DSetPeerTimeout@">
<summary>
 remove inactive DSet Peer after 600 seconds 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LogFileRetained@">
<summary>
 Number of log files to be kept at the remote node. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DataFolder@">
<summary>
 Directory at remote node that holds Prajna data files
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.StatusUseAllDrivesForData@">
<summary>
 Are we using all drives 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.HashFolder@">
<summary>
 Directory at remote node that holds strong hashed file of the remote execution roster. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LocalFolder@">
<summary>
 Directory at remote node that holds Prajna operating state. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.GetAllDrives@">
<summary>
 Get all data drives
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.IsDataDrive@">
<summary>
 Is data drive 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.ExcludedDrives@">
<summary>
 A set of drives to be excluded for data storage
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.AllowAppDomain@">
<summary>
 Whether to launch remote container in App Domain 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.bDaemonRelayForJobAllowed@">
<summary>
 Whether daemon is allowed to relay for job, if false, each job must secure a job port. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.DefaultLaunchBehavior@">
<summary>
 Control whether determiate remote container of different versions. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.LaunchDebugMode@">
<summary>
 Control the launch of container in Debug or Release mode. 
</summary>
</member>
<member name="F:Prajna.Core.DeploymentSettings.RunningOnMono@">
<summary>
 Running on Mono
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.bSaveInitialMetadata(System.Boolean)">
<summary>
 Save Initial Metadata?
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.bDaemonRelayForJobAllowed(System.Boolean)">
<summary>
 Whether daemon is allowed to relay for job, if false, each job must secure a job port. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.WarningLongBlockingSendSocketInMilliseconds(System.Double)">
<summary>
 Warning on long blocking send socket (in milliseconds)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.WarningJobStartTimeSkewAmongPeers(System.Double)">
<summary>
 Maximum time to wait before the a job start in the current peer (in second)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TrackSeenKeyValue(System.Boolean)">
<summary>
 Track seen partitions
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelWaitHandle(Prajna.Tools.LogLevel)">
<summary>
 Trace level for WaitHandle
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelStartJob(Prajna.Tools.LogLevel)">
<summary>
 Trace Level for Starting job
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelSeqFunction(Prajna.Tools.LogLevel)">
<summary>
 Trace Level to Monitor Seq Function
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelEveryNetworkIO(Prajna.Tools.LogLevel)">
<summary>
 Trace level for network IO
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelEveryJobBlob(Prajna.Tools.LogLevel)">
<summary>
 Trace Level for Blob Rcvd
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobValidateHash(Prajna.Tools.LogLevel)">
<summary>
 Validate Hash 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobSend(Prajna.Tools.LogLevel)">
<summary>
 Trace Level for Blob Send
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobRcvd(Prajna.Tools.LogLevel)">
<summary>
 Trace Level for Blob Rcvd
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobIO(Prajna.Tools.LogLevel)">
<summary>
 Travel Level for Blob Send/Receive 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobAvailability(Prajna.Tools.LogLevel)">
<summary>
 Travel Level for Blob Availability 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TotalJobLimit(System.Int32)">
<summary>
 Total Job allowed for Prajna
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeoutBeforeDisconnect(System.Double)">
<summary>
 Final Timeout before disconnect
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutWaitDefaultJobInfo(System.Double)">
<summary>
 Timeout to wait for DefaultJobInfo in DStream to be filled (in milliseconds) 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutServiceStopInMs(System.Int32)">
<summary>
 Timeout for waiting a service to stop
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutJobStartTimeSkewAmongPeers(System.Double)">
<summary>
 Maximum time to wait before the a job start in the current peer (in second)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutJobPortReservation(System.Double)">
<summary>
 Timeout for reserve job port
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutJobFlushMilliseconds(System.Int32)">
<summary>
 Maximum timeout to Flush the task queue and wait for job to end
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutGetRemoteStorageInfo(System.Double)">
<summary>
 --------------------------
 Various Timeout value
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutForWaitAny(System.Int32)">
<summary>
 WaitAny time for the execution engine
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutAction(System.Int64)">
<summary>
 Timeout for an action (second)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TCPSendBufSize(System.Int32)">
<summary>
 JinL to SanjeevM: Please review the following parameter 
 should this parameter be scaled according to number of connections? If there are thousands of connections, will the TCP Send/Receive buffer take too large a size?
 TCP sending buffer size
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TCPRcvBufSize(System.Int32)">
<summary>
 TCP receiving buffer size
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.StatusUseAllDrivesForData(System.Boolean)">
<summary>
 Are we using all drives 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.StandardOutputMonitorIntervalInMs(System.Int32)">
<summary>
 Monitor Interval for StandardError 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.StandardErrorMonitorIntervalInMs(System.Int32)">
<summary>
 Monitor Interval for StandardError 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SleepMSBeforeUnloadAppDomain(System.Int32)">
<summary>
 Sleep Time before unloading appdomain
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SleepIntervalServiceStopInMs(System.Int32)">
<summary>
 Timeout for waiting a service to stop
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SingleTaskTimeout(System.Int32)">
<summary>
 Single Task timeout (max time a single task can execute)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ShortGCInterval(System.Double)">
<summary>
 Short Garbage Collect Interval (ms)
 If there is always activity for this duration, at least one shallow GC should be exected 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.RemoteContainerEstablishmentTimeoutLimit(System.Int64)">
<summary>
 Timeout when trying to setup a remote container (in seconds). The default value is 30 seconds. If the remote execution roster is particularly large, 
 e.g., including data files of multi-gigabyte in size, the program should enlarge this timeout value so that there is time to send the entire remote execution roster 
 to the remote node. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.PeerMonitorInterval(System.Double)">
<summary>
 Monitoring for RcvdPeerClose &amp; SendPeerConfirmed (in seconds)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ParallelJobsPerCore(System.Double)">
<summary>
 Control Default Number of Jobs to be executed related to core
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.OneWaitForAllJobsDone(System.Int32)">
<summary>
 One Wait for all jobs done 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NumObjectsPerJob(System.Int32)">
<summary>
 --------------------------
 Job control parameter
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NumNetworkThreads(System.Int32)">
<summary>
 Number of threads for network processing
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkSocketAsyncEventArgBufferSize(System.Int32)">
<summary>
 The buffer size used by SocketAsyncEventArgs
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkSASendQSize(System.Int32)">
<summary>
 The size of network socket async event args queue for sending
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkSARecvQSize(System.Int32)">
<summary>
 The size of network socket async event args queue for receiving
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkCmdSendQSize(System.Int32)">
<summary>
 The size of network command queue for sending
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkCmdRecvQSize(System.Int32)">
<summary>
 The size of network command queue for receiving
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkActivityMonitorIntervalInMs(System.Int64)">
<summary>
 Monitor Interval for Network Status
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorPeerBlockingTime(System.Double)">
<summary>
 Monitor Blocking on the peer connecting socket
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorIntervalTaskQueueInMs(System.Int32)">
<summary>
 Monitor Interval for Task Queue Status 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorDownstreamTaskQueues(System.Double)">
<summary>
 Warning on long blocking send socket (in seconds)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorClientBlockingTime(System.Double)">
<summary>
 Monitor Blocking on the client connecting socket
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxWaitToEndJobInMilliseconds(System.Int32)">
<summary>
 If a job is idle for this much time, it is considered to have problems, and may be cancelled. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxWaitForAllJobsDone(System.Int32)">
<summary>
 Wait for all jobs done (10hours)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxSendingQueueLimit(System.Int32)">
<summary>
 JinL to SanjeevM: can you please provide explanation for the following three parameters? 
 Maximum combined buffer devoted to sending queue (in bytes) 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxSendRcvdSegSize(System.Int32)">
<summary>
 Maximum size of content each async send &amp; recevie can get
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxNetworkStackMemoryPercentage(System.Double)">
<summary>
 Maximum network stack memory (total across all connections) as percentage of total (as percent)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxNetworkStackMemory(System.Int32)">
<summary>
 Maximum network stack memory (total across all connections), 0 means unbounded (in bytes)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxMemoryLimitInMB(System.Int64)">
<summary>
 Maximum Memory 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxDownStreamAsyncTasks(System.Int32)">
<summary>
 Maximum Asynchronous Tasks that are allowed to pending in downstream. 
 This is to avoid memory exhaustion if too many tasks are pending 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxBytesPerPartitionBeforeBlocking(System.Int64)">
<summary>
 Monitor Flow Control 
 --------------------------
 Flow Control Parameter
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LongGCInterval(System.Double)">
<summary>
 Long Garbage Collect Interval (ms)
 If there is always activity for this duration, a deep GC should be exected 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LogFileRetained(System.Int32)">
<summary>
 Number of log files to be kept at the remote node. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LocalClusterTraceLevel(Prajna.Tools.LogLevel)">
<summary>
 Default Trace Level to start Local Cluster
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LoadCustomAssebly(System.Boolean)">
<summary>
 Whether this is a separate process (AppDomain/Application) 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LightJobLimit(System.Int32)">
<summary>
 Light CPU load jobs that can be executed in parallel 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LaunchDebugMode(Prajna.Core.DebugMode)">
<summary>
 Control the launch of container in Debug or Release mode. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.JobIP(System.String)">
<summary>
 Port range for JobPort
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IsDataDrive(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean})">
<summary>
 Is data drive 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IntervalToReconnectDaemonInMs(System.Int32)">
<summary>
 Gap to reconnect to a certain daemon, &lt;0: do not reconnect, 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.InitNetworkSocketAsyncEventArgBuffers(System.Int32)">
<summary>
 The initial # of buffers in SocketAsyncEventArg stack
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.InitBufferListNumBuffers(System.Int32)">
<summary>
 The initial # of buffers for shared memory pool used by BufferListStream
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IOThreadPiority(System.Threading.ThreadPriority)">
<summary>
 --------------------------
 IO Thread parameter
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.GetAllDrives(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{System.String}})">
<summary>
 Get all data drives
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.GCMode(Prajna.Core.GCMode)">
<summary>
 Garbage Collection Level 
 0: no garbage collection
 1: GC.Collect(1) when no IO activity 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ExecutionLevelTouchAssembly(Prajna.Tools.LogLevel)">
<summary>
 Whether we will touch file when dependency/assembly is copied as a SHA256 named file in the remote node. 
 set the parameter to LogLevel.Info will touch dependecy/assembly when they are written. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ExeJobLimit(System.Int32)">
<summary>
 Separate Exe Jobs that can be executed in parallel
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.EnvStringSetJobDirectory(System.String)">
<summary>
 Use curJob.EnvVars.Add(DeploymentSettings.EnvStringSetJobDirectory, depDirname ) to set the JobDirectory of remote container, where curJob is the current JobDependency object. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.EnvStringGetJobDirectory(System.String)">
<summary>
 Use curJob.EnvVars.Add( envvar, DeploymentSettings.EnvStringGetJobDirectory) 
 to setup environment string in relationship to the JobDirectory of the remote container. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultSerializationLimit(System.Int32)">
<summary>
 Default SerializationLimit for a DSet
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultLaunchBehavior(Prajna.Core.TaskLaunchMode)">
<summary>
 Control whether determiate remote container of different versions. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultIOQueueReadUnblocking(System.Int32)">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultIOMaxQueue(System.Int32)">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultGroupBySerialization(System.Int32)">
<summary>
 default group by size used in DSet
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultCacheSerializationLimit(System.Int32)">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DSetPeerTimeout(System.Int32)">
<summary>
 remove inactive DSet Peer after 600 seconds 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.CollectionTaskTimeout(System.Int32)">
<summary>
 Single Task timeout (max time a single task can execute)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.CmdQueueRcvdBufSize(System.Int32)">
<summary>
 receive buffer size of each NetworkCommandQueue
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ClientExtensionExcutable(System.String)">
<summary>
 Client Extension Process that host unsafe unmanaged code
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.CheckSyncStatusInterval(System.Double)">
<summary>
 Timer to show sync status
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.BufferListBufferSize(System.Int32)">
<summary>
 The buffer size of buffers in shared memory pool used by BufferListStream
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.AppDomainJobLimit(System.Int32)">
<summary>
 App domain jobs that can be executed in parallel. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.AllowAppDomain(System.Boolean)">
<summary>
 Whether to launch remote container in App Domain 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.bSaveInitialMetadata">
<summary>
 Save Initial Metadata?
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.bDaemonRelayForJobAllowed">
<summary>
 Whether daemon is allowed to relay for job, if false, each job must secure a job port. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.WarningLongBlockingSendSocketInMilliseconds">
<summary>
 Warning on long blocking send socket (in milliseconds)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.WarningJobStartTimeSkewAmongPeers">
<summary>
 Maximum time to wait before the a job start in the current peer (in second)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TrackSeenKeyValue">
<summary>
 Track seen partitions
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelWaitHandle">
<summary>
 Trace level for WaitHandle
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelStartJob">
<summary>
 Trace Level for Starting job
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelSeqFunction">
<summary>
 Trace Level to Monitor Seq Function
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelEveryNetworkIO">
<summary>
 Trace level for network IO
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelEveryJobBlob">
<summary>
 Trace Level for Blob Rcvd
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobValidateHash">
<summary>
 Validate Hash 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobSend">
<summary>
 Trace Level for Blob Send
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobRcvd">
<summary>
 Trace Level for Blob Rcvd
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobIO">
<summary>
 Travel Level for Blob Send/Receive 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TraceLevelBlobAvailability">
<summary>
 Travel Level for Blob Availability 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TotalJobLimit">
<summary>
 Total Job allowed for Prajna
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeoutBeforeDisconnect">
<summary>
 Final Timeout before disconnect
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutWaitDefaultJobInfo">
<summary>
 Timeout to wait for DefaultJobInfo in DStream to be filled (in milliseconds) 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutServiceStopInMs">
<summary>
 Timeout for waiting a service to stop
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutJobStartTimeSkewAmongPeers">
<summary>
 Maximum time to wait before the a job start in the current peer (in second)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutJobPortReservation">
<summary>
 Timeout for reserve job port
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutJobFlushMilliseconds">
<summary>
 Maximum timeout to Flush the task queue and wait for job to end
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutGetRemoteStorageInfo">
<summary>
 --------------------------
 Various Timeout value
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutForWaitAny">
<summary>
 WaitAny time for the execution engine
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TimeOutAction">
<summary>
 Timeout for an action (second)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TCPSendBufSize">
<summary>
 JinL to SanjeevM: Please review the following parameter 
 should this parameter be scaled according to number of connections? If there are thousands of connections, will the TCP Send/Receive buffer take too large a size?
 TCP sending buffer size
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.TCPRcvBufSize">
<summary>
 TCP receiving buffer size
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.StatusUseAllDrivesForData">
<summary>
 Are we using all drives 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.StandardOutputMonitorIntervalInMs">
<summary>
 Monitor Interval for StandardError 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.StandardErrorMonitorIntervalInMs">
<summary>
 Monitor Interval for StandardError 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SleepTimeJobLoop">
<summary>
 Sleep time for the main loop in Job. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SleepMSBeforeUnloadAppDomain">
<summary>
 Sleep Time before unloading appdomain
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SleepIntervalServiceStopInMs">
<summary>
 Timeout for waiting a service to stop
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SingleTaskTimeout">
<summary>
 Single Task timeout (max time a single task can execute)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ShortGCInterval">
<summary>
 Short Garbage Collect Interval (ms)
 If there is always activity for this duration, at least one shallow GC should be exected 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.SecondsAfterCloseAfterFlush">
<summary>
 Second after CloseAfterFlush 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.RunningOnMono">
<summary>
 Running on Mono
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.RemoteContainerEstablishmentTimeoutLimit">
<summary>
 Timeout when trying to setup a remote container (in seconds). The default value is 30 seconds. If the remote execution roster is particularly large, 
 e.g., including data files of multi-gigabyte in size, the program should enlarge this timeout value so that there is time to send the entire remote execution roster 
 to the remote node. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.RemappingIntervalInMillisecond">
<summary>
 Remapping interval (in  sec ), that the host will seek to find a new peer to assign a partition. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.PlatformFlag">
<summary>
 Whether x86 or x64 bit 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.PeerMonitorInterval">
<summary>
 Monitoring for RcvdPeerClose &amp; SendPeerConfirmed (in seconds)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ParallelJobsPerCore">
<summary>
 Control Default Number of Jobs to be executed related to core
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.OneWaitForAllJobsDone">
<summary>
 One Wait for all jobs done 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NumObjectsPerJob">
<summary>
 --------------------------
 Job control parameter
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NumNetworkThreads">
<summary>
 Number of threads for network processing
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkSocketAsyncEventArgBufferSize">
<summary>
 The buffer size used by SocketAsyncEventArgs
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkSASendQSize">
<summary>
 The size of network socket async event args queue for sending
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkSARecvQSize">
<summary>
 The size of network socket async event args queue for receiving
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkCmdSendQSize">
<summary>
 The size of network command queue for sending
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkCmdRecvQSize">
<summary>
 The size of network command queue for receiving
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.NetworkActivityMonitorIntervalInMs">
<summary>
 Monitor Interval for Network Status
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorPeerBlockingTime">
<summary>
 Monitor Blocking on the peer connecting socket
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorIntervalTaskQueueInMs">
<summary>
 Monitor Interval for Task Queue Status 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorDownstreamTaskQueues">
<summary>
 Warning on long blocking send socket (in seconds)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MonitorClientBlockingTime">
<summary>
 Monitor Blocking on the client connecting socket
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaximumWorkingSet">
<summary>
 Maximum working set
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxWaitToEndJobInMilliseconds">
<summary>
 If a job is idle for this much time, it is considered to have problems, and may be cancelled. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxWaitForAllJobsDone">
<summary>
 Wait for all jobs done (10hours)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxSendingQueueLimit">
<summary>
 JinL to SanjeevM: can you please provide explanation for the following three parameters? 
 Maximum combined buffer devoted to sending queue (in bytes) 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxSendRcvdSegSize">
<summary>
 Maximum size of content each async send &amp; recevie can get
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxNetworkStackMemoryPercentage">
<summary>
 Maximum network stack memory (total across all connections) as percentage of total (as percent)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxNetworkStackMemory">
<summary>
 Maximum network stack memory (total across all connections), 0 means unbounded (in bytes)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxMemoryLimitInMB">
<summary>
 Maximum Memory 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxDownStreamAsyncTasks">
<summary>
 Maximum Asynchronous Tasks that are allowed to pending in downstream. 
 This is to avoid memory exhaustion if too many tasks are pending 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.MaxBytesPerPartitionBeforeBlocking">
<summary>
 Monitor Flow Control 
 --------------------------
 Flow Control Parameter
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LongGCInterval">
<summary>
 Long Garbage Collect Interval (ms)
 If there is always activity for this duration, a deep GC should be exected 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LogFileRetained">
<summary>
 Number of log files to be kept at the remote node. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LocalFolder">
<summary>
 Directory at remote node that holds Prajna operating state. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LocalClusterTraceLevel">
<summary>
 Default Trace Level to start Local Cluster
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LocalClusterNumJobPortsPerClient">
<summary>
 Waiting for thread to terminate
 Default values for local cluster
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LoadCustomAssebly">
<summary>
 Whether this is a separate process (AppDomain/Application) 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LightJobLimit">
<summary>
 Light CPU load jobs that can be executed in parallel 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.LaunchDebugMode">
<summary>
 Control the launch of container in Debug or Release mode. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.JobIP">
<summary>
 Port range for JobPort
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IsDataDrive">
<summary>
 Is data drive 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IntervalToReconnectDaemonInMs">
<summary>
 Gap to reconnect to a certain daemon, &lt;0: do not reconnect, 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.InitNetworkSocketAsyncEventArgBuffers">
<summary>
 The initial # of buffers in SocketAsyncEventArg stack
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.InitBufferListNumBuffers">
<summary>
 The initial # of buffers for shared memory pool used by BufferListStream
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IOThreadPiority">
<summary>
 --------------------------
 IO Thread parameter
 --------------------------
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.IOThreadMonitorTimeSpan">
<summary>
 Inactive time for monitoring of main thread. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.HashFolder">
<summary>
 Directory at remote node that holds strong hashed file of the remote execution roster. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.GetAllDrives">
<summary>
 Get all data drives
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.GCMode">
<summary>
 Garbage Collection Level 
 0: no garbage collection
 1: GC.Collect(1) when no IO activity 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ExecutionLevelTouchAssembly">
<summary>
 Whether we will touch file when dependency/assembly is copied as a SHA256 named file in the remote node. 
 set the parameter to LogLevel.Info will touch dependecy/assembly when they are written. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ExeJobLimit">
<summary>
 Separate Exe Jobs that can be executed in parallel
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ExcludedDrives">
<summary>
 A set of drives to be excluded for data storage
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.EnvStringSetJobDirectory">
<summary>
 Use curJob.EnvVars.Add(DeploymentSettings.EnvStringSetJobDirectory, depDirname ) to set the JobDirectory of remote container, where curJob is the current JobDependency object. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.EnvStringGetJobDirectory">
<summary>
 Use curJob.EnvVars.Add( envvar, DeploymentSettings.EnvStringGetJobDirectory) 
 to setup environment string in relationship to the JobDirectory of the remote container. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultSerializationLimit">
<summary>
 Default SerializationLimit for a DSet
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultLaunchBehavior">
<summary>
 Control whether determiate remote container of different versions. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultIOQueueReadUnblocking">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultIOMaxQueue">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultGroupBySerialization">
<summary>
 default group by size used in DSet
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DefaultCacheSerializationLimit">
<summary>
 ReSerialization For Cache
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DataFolder">
<summary>
 Directory at remote node that holds Prajna data files
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.DSetPeerTimeout">
<summary>
 remove inactive DSet Peer after 600 seconds 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ContainerMaxWaitForJobToFinish">
<summary>
 The time interval that the container will wait for a analytical job to complete
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ContainerCheckClientLivenessInterval">
<summary>
 The time interval that the container will check the liveness of the host client
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.CollectionTaskTimeout">
<summary>
 Single Task timeout (max time a single task can execute)
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.CmdQueueRcvdBufSize">
<summary>
 receive buffer size of each NetworkCommandQueue
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ClusterProcessingAcknoledgementInterval">
<summary>
 Interval that we will process acknowledgement command (in microsecond). 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ClientInactiveTimeSpan">
<summary>
 Inactive time for monitoring of main thread. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.ClientExtensionExcutable">
<summary>
 Client Extension Process that host unsafe unmanaged code
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.CheckSyncStatusInterval">
<summary>
 Timer to show sync status
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.BufferListBufferSize">
<summary>
 The buffer size of buffers in shared memory pool used by BufferListStream
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.AppDomainUnloadWaitTime">
<summary>
 The wait time for unload an appdomain that is hosting a daemon or container.
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.AppDomainJobLimit">
<summary>
 App domain jobs that can be executed in parallel. 
</summary>
</member>
<member name="P:Prajna.Core.DeploymentSettings.AllowAppDomain">
<summary>
 Whether to launch remote container in App Domain 
</summary>
</member>
<member name="M:Prajna.Core.DeploymentSettings.IsDataDriveImpl(System.String)">
<summary>
 Is data drive 
</summary>
</member>
<member name="M:Prajna.Core.DeploymentSettings.GetFirstDataDriveImpl">
<summary>
 Get first data drives
</summary>
</member>
<member name="T:Prajna.Core.DeploymentSettings">
<summary>
 A set of default parameter that controls Prajna execution behavior
</summary>
</member>
<member name="T:Prajna.Core.DepositFunctionWrapper`2">
<summary>
 ----------------------------------------------------------------------------------------------------------------------------------------------
 Used for Cross Join
 ----------------------------------------------------------------------------------------------------------------------------------------------
 It uses three functions:
 DepositFunc parti (meta, o): 
     Deposit outer object before loop of inner object starts
 MapFunc (meta, o) 
     Execute inner cross join loop, note here the object is further wrapped as (parti, o) to pass the parti information. 
 ExecuteFunc parti (meta, o)
     Final function for cross join, after all the partition has been executed upon. 
</summary>
</member>
<member name="T:Prajna.Core.DetailedConfig">
 <summary> 
 Detailed Machine configuration. The detailed config takes more time to execute (e.g., using system memory object, and initialization takes around 500ms, 
 The code should not be executed at client for job
 !!! Wish !!! For F#, please only instantiated the static object when the object is used, rather than initiated all objects in the file. 
 </summary>
</member>
<member name="F:Prajna.Core.DistributedObject.NetworkReady@">
<summary>
 Setup network before remote job
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.bRcvdPeer@">
<summary>
 Two dimension array
 bRcvdPeer.[peeri].[parti] = true, has receive some command from peeri on partition i. 
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.PreBegin@">
<summary>
 Begining of a job
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.ResetAll@">
<summary>
 Clear all resources used in job
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.PostCloseAllStreams@">
<summary>
 Final clean up job resources
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.WaitForCloseAllStreamsViaHandle@">
<summary>
 wait for all streams to confirm closing
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.SyncPreCloseAllStreams@">
<summary>
 Close all streams at the end of job
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.SyncDecodeToDownstream@">
<summary>
 Iterate operation downstream, the synchronous interface.
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.SyncIterate@">
<summary>
 Iterate operation upstream
 Return: 
     _, true: iterate operation completes
     handle, false: iterate operation wait on a certain handle
     null, false: iterate operation complete one step, to execute again. 
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.JobMapping@">
<summary>
 Get current mapping
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.GetParentMapping@">
<summary>
 Internal function to derive partition mapping 
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.SetupPartitionMapping@">
<summary>
 Function to setup partition. 
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.bValidMetadata@">
<summary>
 Is the metadata of the current DObject valid
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.InitializePartition@">
<summary>
 Initialize partition
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.FullMappingI@">
<summary>
 Get a full mapping
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.bEncodeMapping@">
<summary>
 Should this Mapping be encoded?
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.Clock@">
<summary>
 a stop watch for timeout management. 
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.ClockFrequency@">
<summary>
 internal clock frequency
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.SetupDependencyHash@">
<summary>
 Setup dependency hash
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.PrecodeDependentObjs@">
<summary>
 encode object links. 
</summary>
</member>
<member name="F:Prajna.Core.DistributedObject.Blob@">
 <summary> 
 Blob that represent the coded stream of the current object. It is used to speed up serialization (i.e., if the Hash exists, we assume 
 that the DistributedObject has been serialized and coded in the current form). If you have changed any internal operation of the DistributedObject, 
 e.g., mapping, closure, please explicitly set the Blob to null, which force a reserialization of the current object.  
 </summary>
</member>
<member name="P:Prajna.Core.DistributedObject.bValidMetadata(System.Boolean)">
<summary>
 Is the metadata of the current DObject valid
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.bRcvdPeer(System.Boolean[][])">
<summary>
 Two dimension array
 bRcvdPeer.[peeri].[parti] = true, has receive some command from peeri on partition i. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.bEncodeMapping(System.Boolean)">
<summary>
 Should this Mapping be encoded?
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.WaitForCloseAllStreamsViaHandle(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Tools.WaitHandleCollection,Prajna.Core.JobInformation,System.DateTime},Microsoft.FSharp.Core.Unit})">
<summary>
 wait for all streams to confirm closing
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SyncPreCloseAllStreams(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.Unit})">
<summary>
 Close all streams at the end of job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SyncIterate(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object},Microsoft.FSharp.Core.Unit},System.Tuple{System.Threading.ManualResetEvent,System.Boolean}}}})">
<summary>
 Iterate operation upstream
 Return: 
     _, true: iterate operation completes
     handle, false: iterate operation wait on a certain handle
     null, false: iterate operation complete one step, to execute again. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SyncDecodeToDownstream(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.BlobMetadata,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.Unit}}}})">
<summary>
 Iterate operation downstream, the synchronous interface.
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SetupPartitionMapping(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Function to setup partition. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SetupDependencyHash(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Setup dependency hash
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.ResetAll(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.Unit})">
<summary>
 Clear all resources used in job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.PrecodeDependentObjs(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{Prajna.Core.DependentDObject}})">
<summary>
 encode object links. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.PreBegin(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.JobInformation,Prajna.Core.TraverseDirection},Microsoft.FSharp.Core.Unit})">
<summary>
 Begining of a job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.PostCloseAllStreams(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.Unit})">
<summary>
 Final clean up job resources
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.NumPartitions(System.Int32)">
<summary>
 Get num of partitions
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.NetworkReady(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.JobInformation,Microsoft.FSharp.Core.Unit})">
<summary>
 Setup network before remote job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.JobMapping(System.Int32[])">
<summary>
 Get current mapping
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.InitializePartition(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Initialize partition
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.GetParentMapping(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prajna.Core.ParentMapping})">
<summary>
 Internal function to derive partition mapping 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.FullMappingI(System.Int32[])">
<summary>
 Get a full mapping
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.Blob(Prajna.Core.Blob)">
 <summary> 
 Blob that represent the coded stream of the current object. It is used to speed up serialization (i.e., if the Hash exists, we assume 
 that the DistributedObject has been serialized and coded in the current form). If you have changed any internal operation of the DistributedObject, 
 e.g., mapping, closure, please explicitly set the Blob to null, which force a reserialization of the current object.  
 </summary>
</member>
<member name="P:Prajna.Core.DistributedObject.bValidMetadata">
<summary>
 Is the metadata of the current DObject valid
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.bRcvdPeer">
<summary>
 Two dimension array
 bRcvdPeer.[peeri].[parti] = true, has receive some command from peeri on partition i. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.bEncodeMapping">
<summary>
 Should this Mapping be encoded?
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.WaitForCloseAllStreamsViaHandle">
<summary>
 wait for all streams to confirm closing
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SyncPreCloseAllStreams">
<summary>
 Close all streams at the end of job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SyncIterate">
<summary>
 Iterate operation upstream
 Return: 
     _, true: iterate operation completes
     handle, false: iterate operation wait on a certain handle
     null, false: iterate operation complete one step, to execute again. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SyncDecodeToDownstream">
<summary>
 Iterate operation downstream, the synchronous interface.
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SetupPartitionMapping">
<summary>
 Function to setup partition. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.SetupDependencyHash">
<summary>
 Setup dependency hash
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.ResetAll">
<summary>
 Clear all resources used in job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.PrecodeDependentObjs">
<summary>
 encode object links. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.PreBegin">
<summary>
 Begining of a job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.PostCloseAllStreams">
<summary>
 Final clean up job resources
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.NumPartitions">
<summary>
 Get num of partitions
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.NetworkReady">
<summary>
 Setup network before remote job
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.JobMapping">
<summary>
 Get current mapping
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.InitializePartition">
<summary>
 Initialize partition
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.GetParentMapping">
<summary>
 Internal function to derive partition mapping 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.FullMappingI">
<summary>
 Get a full mapping
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.ClockFrequency">
<summary>
 internal clock frequency
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.Clock">
<summary>
 a stop watch for timeout management. 
</summary>
</member>
<member name="P:Prajna.Core.DistributedObject.Blob">
 <summary> 
 Blob that represent the coded stream of the current object. It is used to speed up serialization (i.e., if the Hash exists, we assume 
 that the DistributedObject has been serialized and coded in the current form). If you have changed any internal operation of the DistributedObject, 
 e.g., mapping, closure, please explicitly set the Blob to null, which force a reserialization of the current object.  
 </summary>
</member>
<member name="M:Prajna.Core.DistributedObject.UpdateBaseMetadata(Prajna.Core.DistributedObject)">
<summary>
 Copy metadata
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.SyncDecodeToDownstreamImpl(Prajna.Core.JobInformation,System.Int32,Prajna.Core.BlobMetadata,System.Object)">
<summary>
 Iterate operation downstream, the synchronous interface.   
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.ResetAllImpl(Prajna.Core.JobInformation)">
<summary>
 Clear all resources used in job
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.PreBeginImpl(Prajna.Core.JobInformation,Prajna.Core.TraverseDirection)">
<summary>
 Begining of a job
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.PeekBase(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Flat mapping 
 Undetermined mapping, the mapping should be resolved when x.GetMapping() is called. 
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.PartitionFileName(System.Int32)">
<summary>
 Is all downstream task completed?
 Name of the partition file 
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.PartiMapping(System.Int32)">
<summary>
 Obtain the mapping matrix for partition i. 
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.NetworkReadyImpl(Prajna.Core.JobInformation)">
<summary>
 Setup network before remote job
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.MappingToString">
<summary>
 Mapping information will be generated. 
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.GetMapping">
<summary>
 Retrieve the current mapping
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.GetFullMappingI">
<summary>
 Get a full mapping of node i
 If x.Cluster is not set, the call will result in an exception. 
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.GetFullMapping">
<summary>
 Get a full mapping for the class
 If x.Cluster or partition information is not set, the call will result in an exception.
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.ConstructDSetPath">
<summary>
 Construct the path of DSet. 
</summary>
</member>
<member name="M:Prajna.Core.DistributedObject.ConstructDSetPath(System.String,System.Int64)">
<summary>
 static member of constructing the path of DSet
</summary>
</member>
<member name="T:Prajna.Core.DistributedObject">
<summary>
 Base of DStream/DSet, all exposed functions in this class is internal function to be executed 
 during a data analytical jobs. They shoould not be used by programmer. 
</summary>
</member>
<member name="M:Prajna.Core.Environment.Init">
<summary>
 Initialize Prajna Environment for running Prajna program
 Currently, under the following scenario, Environment.Init() should be called explicitly by users:
 1）Local cluster is used
 2) Distributed function is used. 
</summary>
</member>
<member name="M:Prajna.Core.Environment.Cleanup">
<summary>
 Cleanup Prajna Environment for running Prajna program
</summary>
</member>
<member name="T:Prajna.Core.Environment">
<summary>
 Represent Prajna Environment for running Prajna program
</summary>
</member>
<member name="M:Prajna.Core.ExecutedTaskHolder.RegisterConnectionsWithTasks">
 <summary>
 Register the client queue with task (after AppDomain/Exe is launched. 
 </summary>
</member>
<member name="M:Prajna.Core.ExecutedTaskHolder.NewConnectedQueue(Prajna.Core.NetworkCommandQueue)">
 <summary>
 A new client queue is connected to the task. 
 </summary>
</member>
<member name="M:Prajna.Core.ExecutedTaskHolder.ForceTerminate">
 <summary>
 Force terminating all tasks of an executing job. 
 Currently, this is executed when we detect a new version (of different signature) of task. 
 </summary>
</member>
<member name="M:Prajna.Core.ExecutedTaskHolder.CloseConnectedQueue(Prajna.Core.NetworkCommandQueue)">
 <summary>
 Deregister client queue. 
 Return: 
     true: if the removal causes the last queue to be disconnected from the client. 
     false: there is other queue connected, or the deregister doesnot trigger removal operation. 
 </summary>
</member>
<member name="M:Prajna.Core.Function.RepartitionWithinNode``1(Prajna.Core.Partitioner,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32})">
<summary>
 Regroup is used to redefine &apos;K[] and &apos;V[] with a new serialization limit. 
</summary>
</member>
<member name="M:Prajna.Core.Function.Regroup``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
<summary>
 Regroup is used to redefine &apos;K[] and &apos;V[] with a new serialization limit. 
</summary>
</member>
<member name="M:Prajna.Core.Function.ParallelTaskExecution``1(System.Threading.Tasks.Task{``0}[])">
<summary>
 Execution of Tasks, handle cases where some task get cancelled during execution
</summary>
</member>
<member name="M:Prajna.Core.Function.ParallelMappingValueFunction``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Threading.Tasks.Task{``2}})">
<summary>
 Parallel mapping function for value only, we used task to get a timeout 
</summary>
</member>
<member name="M:Prajna.Core.Function.ParallelMappingIFunction``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}}}})">
<summary>
 Parallel mapping function, Parallel.For is used to execute the mapping in parallel fashion
</summary>
</member>
<member name="M:Prajna.Core.Function.ParallelMappingFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Parallel mapping function, Parallel.For is used to execute the mapping in parallel fashion
</summary>
</member>
<member name="M:Prajna.Core.Function.MappingValueFunction``3(Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Mapping Values
</summary>
</member>
<member name="M:Prajna.Core.Function.MappingIFunction``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}})">
<summary>
 Mapping Both Key &amp; Values, with partition &amp; serial information
</summary>
</member>
<member name="M:Prajna.Core.Function.MappingFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Mapping Both Key &amp; Values
</summary>
</member>
<member name="M:Prajna.Core.Function.MappingCollectionFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0[],``1[]})">
<summary>
 Mapping Both Key &amp; Values
</summary>
</member>
<member name="M:Prajna.Core.Function.GroupByValueFunction``2">
<summary>
 Group by value, within partition only 
</summary>
</member>
<member name="M:Prajna.Core.Function.GroupByValueCollectionFunction``2">
<summary>
 Group by value, within partition only 
</summary>
</member>
<member name="M:Prajna.Core.Function.FilteringKeyFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
<summary>
 It is a contract that keyArray and valueArray will not be null. 
</summary>
</member>
<member name="M:Prajna.Core.Function.FilteringFunction``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
<summary>
 Filtering of Key &amp; Value, 
</summary>
</member>
<member name="M:Prajna.Core.Function.CollectFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
<summary>
 Filtering of Key &amp; Value, 
</summary>
</member>
<member name="M:Prajna.Core.Function.ChooseFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Filtering of Key &amp; Value, 
</summary>
</member>
<member name="M:Prajna.Core.Function.AsyncMappingValueFunction``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Async mapping function, using Async.Parallel to execute the mapping
</summary>
</member>
<member name="M:Prajna.Core.Function.AsyncMappingIFunction``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}}}})">
<summary>
 Async mapping function, using Async.Parallel to execute the mapping, with partition &amp; serial information
</summary>
</member>
<member name="M:Prajna.Core.Function.AsyncMappingFunction``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Async mapping function, using Async.Parallel to execute the mapping
</summary>
</member>
<member name="T:Prajna.Core.FunctionKind">
<summary>
 FunctionType is a one byte mask defines the type of the 
 function, 
</summary>
</member>
<member name="M:Prajna.Core.FunctionPartition`1.WrapperFunc(Prajna.Core.Partitioner,Microsoft.FSharp.Core.FSharpFunc{`0,System.Int32},Prajna.Core.BlobMetadata,`0[])">
<summary>
 Wrapper Mapping Function for Init, which is a DSet with DSetDependencyType.Source 
 The calling signature should be parti, serial, 0, null, null (numElems and o and v are not used). 
 The return signature should be (parti, serial, numElems, ko, vo) in which SerializationLimit worth of objects are generated.
 The InitFunc will be called for ( parti, serial) to generate the object associated with the serialization
 The InitFunc signals the end when it sends parti, serial, numElems, null, null
</summary>
</member>
<member name="T:Prajna.Core.FunctionWrapperMapKeyValue`2">
<summary>
 Wrapper function: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;K*&apos;V&gt; -&gt; DSet&lt;&apos;K*&apos;V1&gt;
</summary>
</member>
<member name="T:Prajna.Core.FunctionWrapperMap`1">
<summary>
 Wrapper function: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
</summary>
</member>
<member name="F:Prajna.Core.FunctionWrapperPartition`2.CallNullAtFinal@">
<summary>
 Control whether UseFunc is called at final, with null key &amp; value array parameter. 
</summary>
</member>
<member name="P:Prajna.Core.FunctionWrapperPartition`2.CallNullAtFinal(System.Boolean)">
<summary>
 Control whether UseFunc is called at final, with null key &amp; value array parameter. 
</summary>
</member>
<member name="P:Prajna.Core.FunctionWrapperPartition`2.CallNullAtFinal">
<summary>
 Control whether UseFunc is called at final, with null key &amp; value array parameter. 
</summary>
</member>
<member name="M:Prajna.Core.FunctionWrapperPartition`2.WrapperMapFunc(Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="T:Prajna.Core.FunctionWrapperPartition`2">
<summary>
 Mapping function wrapper: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
 This function specifically allows repartition 
 Note that repartition function does not do row reorg, i.e., SerializationLimit will be ignored and always treated as 0. 
 The main reason is that repartition will result in deposit of keys to differnt queue, and it will be a mess to reshuffle keys here. 
</summary>
</member>
<member name="T:Prajna.Core.FunctionWrapperSet`2">
<summary>
 --------------------------------------------------------------------------------------------------------------------------------
 Wrapper function: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
</summary>
</member>
<member name="T:Prajna.Core.FunctionWrapperValue`3">
<summary>
 Wrapper function: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;K*&apos;V&gt; -&gt; DSet&lt;&apos;K*&apos;V1&gt;
</summary>
</member>
<member name="F:Prajna.Core.FunctionWrapper`2.UseFunc@">
<summary>
 Wrapped UseFunc, with (int * int64 * &apos;K[] * &apos;V[] ) -&gt; ( int * int64 * &apos;K1[] * &apos;V1[] )
</summary>
</member>
<member name="F:Prajna.Core.FunctionWrapper`2.CallNullAtFinal@">
<summary>
 Control whether UseFunc is called at final, with null key &amp; value array parameter. 
</summary>
</member>
<member name="P:Prajna.Core.FunctionWrapper`2.UseFunc(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,`0[]},System.Tuple{Prajna.Core.BlobMetadata,`1[]}})">
<summary>
 Wrapped UseFunc, with (int * int64 * &apos;K[] * &apos;V[] ) -&gt; ( int * int64 * &apos;K1[] * &apos;V1[] )
</summary>
</member>
<member name="P:Prajna.Core.FunctionWrapper`2.CallNullAtFinal(System.Boolean)">
<summary>
 Control whether UseFunc is called at final, with null key &amp; value array parameter. 
</summary>
</member>
<member name="P:Prajna.Core.FunctionWrapper`2.UseFunc">
<summary>
 Wrapped UseFunc, with (int * int64 * &apos;K[] * &apos;V[] ) -&gt; ( int * int64 * &apos;K1[] * &apos;V1[] )
</summary>
</member>
<member name="P:Prajna.Core.FunctionWrapper`2.CallNullAtFinal">
<summary>
 Control whether UseFunc is called at final, with null key &amp; value array parameter. 
</summary>
</member>
<member name="M:Prajna.Core.FunctionWrapper`2.WrapperMapFunc(Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="F:Prajna.Core.GCPolicy.LastGC@">
<summary>
 Last time GC.Collect() is called. 
</summary>
</member>
<member name="F:Prajna.Core.GCPolicy.LastGCAtNoActivity@">
<summary>
 Last time GC.Collect() is called with no activity with full GC
</summary>
</member>
<member name="F:Prajna.Core.GCPolicy.GCCount@">
<summary>
 For GC statistics
</summary>
</member>
<member name="P:Prajna.Core.GCPolicy.LastGCAtNoActivity(System.DateTime)">
<summary>
 Last time GC.Collect() is called with no activity with full GC
</summary>
</member>
<member name="P:Prajna.Core.GCPolicy.LastGC(System.DateTime)">
<summary>
 Last time GC.Collect() is called. 
</summary>
</member>
<member name="P:Prajna.Core.GCPolicy.GCCount(System.Int32)">
<summary>
 For GC statistics
</summary>
</member>
<member name="P:Prajna.Core.GCPolicy.LastGCAtNoActivity">
<summary>
 Last time GC.Collect() is called with no activity with full GC
</summary>
</member>
<member name="P:Prajna.Core.GCPolicy.LastGC">
<summary>
 Last time GC.Collect() is called. 
</summary>
</member>
<member name="P:Prajna.Core.GCPolicy.GCCount">
<summary>
 For GC statistics
</summary>
</member>
<member name="M:Prajna.Core.GCPolicy.TryGCCollect1(System.Boolean)">
<summary>
 Try to schedule for a GC collection. 
 bActivity: whether any IO or operation at the moment
 Return: GC executed or not. 
</summary>
</member>
<member name="M:Prajna.Core.GCPolicy.TryGCCollect(System.Boolean)">
<summary>
 A more lazy GC policy, only initiated GC during no IO activity, and no more than 1 non blocking GC at a LongGCInterval. 
</summary>
</member>
<member name="M:Prajna.Core.GCPolicy.GetGCStatisticsInfo">
<summary>
 GC Statistics 
 Return avg &amp; maximum time GC executes. 
</summary>
</member>
<member name="M:Prajna.Core.GCPolicy.GetGCStatistics">
<summary>
 GC Statistics 
</summary>
</member>
<member name="M:Prajna.Core.GCPolicy.CallGCCollect(System.Int32)">
<summary>
 Call a GC collection 
 Activity level: 0, no activity, garbage collection performed on all levels. 
                 1, always activity, short internal, perform a shallow garbage collection
                 2, always activity, medium interval, perform a medium garbage collection
                 3, always activity, long interval, a full garbage collection is executed
</summary>
</member>
<member name="T:Prajna.Core.GCPolicy">
<summary>
 Class to implement Garbage Collection Policy for Prajna 
</summary>
</member>
<member name="T:Prajna.Core.GF2wInt">
<summary>
 A Galois Field with datatype &apos;D and primitive Polynomial p and keysize s
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.toArray">
<summary>
 Get the list of current members
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Store(System.Byte[],`0)">
<summary>
 Store object info into the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Retrieve(System.Byte[])">
<summary>
 Retrieve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Resolve(System.Byte[])">
<summary>
 Resolve object info from the Factory class. 
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Remove(System.Byte[])">
<summary>
 Remove a certain entry
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Refresh(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},System.Int32)">
<summary>
 func: &apos;T -&gt; bool,   true: when object is still in use
 Evict all object if there is elapseSeconds passed when the object is not in use. 
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Refresh(System.Byte[])">
<summary>
 Refresh timer entry of an object
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.Evict(System.Int32)">
<summary>
 Evict object that hasn&apos;t been visited within the specified seconds
</summary>
</member>
<member name="M:Prajna.Core.HashCacheFactory`1.CacheUseOld(System.Byte[],`0)">
<summary>
 Cache Information, used the existing object in Factory if it is there already
</summary>
</member>
<member name="T:Prajna.Core.HashCacheFactory`1">
<summary>
 The CacheFactory class implements cache that avoid instantiation of multiple Cluster class, and save memory. 
</summary>
</member>
<member name="T:Prajna.Core.HomeInClient">
<summary>
 Socket communication module of the PrajnaClient &amp; Controller
</summary>
</member>
<member name="M:Prajna.Core.HomeInServer.TakeSnapShot(System.DateTime)">
<summary>
 Take a snap shot of the current valid clients. 
</summary>
</member>
<member name="M:Prajna.Core.HomeInServer.SaveSnapShot">
<summary>
 Take a snap shot of the current valid clients, and put them in a snap shot file. 
</summary>
</member>
<member name="T:Prajna.Core.ILocalCluster">
<summary>
 interface for local cluster
</summary>
</member>
<member name="F:Prajna.Core.InitFunctionWrapper`1.PartitionSizeFunc@">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.InitFunctionWrapper`1.PartitionSizeFunc(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.InitFunctionWrapper`1.PartitionSizeFunc">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="M:Prajna.Core.InitFunctionWrapper`1.WrapperInitFunc(Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind)">
<summary>
 Wrapper Mapping Function for Init, which is a DSet with DSetDependencyType.Source 
 The calling signature should be parti, serial, 0, null, null (numElems and o and v are not used). 
 The return signature should be (parti, serial, numElems, ko, vo) in which SerializationLimit worth of objects are generated.
 The InitFunc will be called for ( parti, serial) to generate the object associated with the serialization
 The InitFunc signals the end when it sends parti, serial, numElems, null, null
</summary>
</member>
<member name="T:Prajna.Core.InitFunctionWrapper`1">
<summary>
 Mapping function wrapper: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
</summary>
</member>
<member name="F:Prajna.Core.Job.NodeInfo@">
<summary>
 Node Information within a job. 
</summary>
</member>
<member name="F:Prajna.Core.Job.BlobSync@">
<summary>
 Blob sync method
</summary>
</member>
<member name="F:Prajna.Core.Job.JobDependecyObjec@">
<summary>
 Linked job dependency object. 
</summary>
</member>
<member name="F:Prajna.Core.Job.IsContainer@">
<summary>
 Is the job to launch a container 
</summary>
</member>
<member name="F:Prajna.Core.Job.Blobs@">
<summary>
 Blobs associated with the current job
</summary>
</member>
<member name="F:Prajna.Core.Job.BlobStartSerial@">
<summary>
 Start Blob Serial Number that will define this 
</summary>
</member>
<member name="F:Prajna.Core.Job.JobAsmBinding@">
<summary>
 Assembly bindings for the job
</summary>
</member>
<member name="F:Prajna.Core.Job.JobConfiguration@">
<summary>
 Configuration for the job 
</summary>
</member>
<member name="F:Prajna.Core.Job.JobEnvVars@">
<summary>
 Environment Variables for the job
</summary>
</member>
<member name="F:Prajna.Core.Job.JobDirectory@">
<summary>
 The Job Directory, if empty use default directory
</summary>
</member>
<member name="F:Prajna.Core.Job.JobDependencies@">
<summary>
 Job File Dependencies
</summary>
</member>
<member name="F:Prajna.Core.Job.Assemblies@">
<summary>
 Assemblies 
</summary>
</member>
<member name="F:Prajna.Core.Job.DStreams@">
<summary>
 DStreams object used for the job
</summary>
</member>
<member name="F:Prajna.Core.Job.PassthroughDSet@">
<summary>
 PassthroughDSet are the set that exists for the duration of the job only
</summary>
</member>
<member name="F:Prajna.Core.Job.DstDSet@">
<summary>
 DstDSet are the set of DSets that has persist content after the completion of the current job
</summary>
</member>
<member name="F:Prajna.Core.Job.SrcDSetNumValidResponse@">
<summary>
 Number of peer responded with SrcDSet request, as the SrcDSet may differ from peers
</summary>
</member>
<member name="F:Prajna.Core.Job.SrcDSetNumResponded@">
<summary>
 Number of peer responded with SrcDSet request, as the SrcDSet may differ from peers
</summary>
</member>
<member name="F:Prajna.Core.Job.SrcDSet@">
<summary>
 SrcDSet are the set of DSets that exist before the execution of the current job. 
</summary>
</member>
<member name="F:Prajna.Core.Job.TypeOf@">
<summary>
 Prajna Task Type
</summary>
</member>
<member name="F:Prajna.Core.Job.Clusters@">
<summary>
 All Clusters to be used in the current job. 
</summary>
</member>
<member name="F:Prajna.Core.Job.OutgoingQueuesToPeerNumber@">
<summary>
 Given a queue information, lookup the peer number
 OutgoingQueuesToPeerNumber is constructed one time during job launch, no multithread issue here. 
</summary>
</member>
<member name="F:Prajna.Core.Job.ClustersInfo@">
<summary>
 Information of the clusters that uses the Job
</summary>
</member>
<member name="F:Prajna.Core.Job.JobPort@">
<summary>
 Job port to be used by remote execution container
</summary>
</member>
<member name="F:Prajna.Core.Job.TryExecuteSingleJobActionFunc@">
<summary>
 Obtain a SingleJobActionApp object that is used for controlling the lifecycle of a job
 This function is set by DSetAction
</summary>
</member>
<member name="F:Prajna.Core.Job.JobID@">
<summary>
 Job ID, uniquely identify the job, inserted on 9/2015
 Job ID is initiated in DSetAction. 
</summary>
</member>
<member name="F:Prajna.Core.Job.LaunchMode@">
<summary>
 Whether the job needs to be launched, a few action, e.g., &quot;stop service&quot; don&apos;t attempt to launch a new job
</summary>
</member>
<member name="F:Prajna.Core.Job.Version@">
<summary>
 Version of Job is a 64bit integer, coded through hash of assemblies. 
 The idea is that the Job can persist 
</summary>
</member>
<member name="F:Prajna.Core.Job.IsJobHolder@">
<summary>
 A Job Holder contains Assembly &amp; dependent files, a non job holder doesn&apos;t have those components. 
</summary>
</member>
<member name="F:Prajna.Core.Job.ContainerJobCollection@">
<summary>
 ContainerJobCollection contains a list of DLLs signature of the current job. 
 Each signature is the signature of a collection of DLLs that is used by the current program. 
 It is used to track DLLs being loaded into the current AppDomain, and will usually only increase. 
 They will be released by Cleanup
</summary>
</member>
<member name="P:Prajna.Core.Job.Version(System.DateTime)">
<summary>
 Version of Job is a 64bit integer, coded through hash of assemblies. 
 The idea is that the Job can persist 
</summary>
</member>
<member name="P:Prajna.Core.Job.TypeOf(Prajna.Core.JobTaskKind)">
<summary>
 Prajna Task Type
</summary>
</member>
<member name="P:Prajna.Core.Job.TryExecuteSingleJobActionFunc(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prajna.Core.SingleJobActionApp})">
<summary>
 Obtain a SingleJobActionApp object that is used for controlling the lifecycle of a job
 This function is set by DSetAction
</summary>
</member>
<member name="P:Prajna.Core.Job.SrcDSetNumValidResponse(System.Collections.Generic.List{System.Int32})">
<summary>
 Number of peer responded with SrcDSet request, as the SrcDSet may differ from peers
</summary>
</member>
<member name="P:Prajna.Core.Job.SrcDSetNumResponded(System.Collections.Generic.List{System.Int32})">
<summary>
 Number of peer responded with SrcDSet request, as the SrcDSet may differ from peers
</summary>
</member>
<member name="P:Prajna.Core.Job.SrcDSet(System.Collections.Generic.List{Prajna.Core.DSet})">
<summary>
 SrcDSet are the set of DSets that exist before the execution of the current job. 
</summary>
</member>
<member name="P:Prajna.Core.Job.PassthroughDSet(System.Collections.Generic.List{Prajna.Core.DSet})">
<summary>
 PassthroughDSet are the set that exists for the duration of the job only
</summary>
</member>
<member name="P:Prajna.Core.Job.Params(System.Collections.Generic.IEnumerable{System.Object})">
<summary>
 Set Multiple Parameters
</summary>
</member>
<member name="P:Prajna.Core.Job.Param(System.Object)">
<summary>
 Add one Prajna job parameter
</summary>
</member>
<member name="P:Prajna.Core.Job.OutgoingQueuesToPeerNumber(System.Collections.Generic.Dictionary{Prajna.Core.NetworkCommandQueue,System.Int32})">
<summary>
 Given a queue information, lookup the peer number
 OutgoingQueuesToPeerNumber is constructed one time during job launch, no multithread issue here. 
</summary>
</member>
<member name="P:Prajna.Core.Job.NodeInfo(System.Collections.Concurrent.ConcurrentDictionary{System.Int64,Prajna.Core.NodeWithInJobInfo})">
<summary>
 Node Information within a job. 
</summary>
</member>
<member name="P:Prajna.Core.Job.LaunchMode(Prajna.Core.TaskLaunchMode)">
<summary>
 Whether the job needs to be launched, a few action, e.g., &quot;stop service&quot; don&apos;t attempt to launch a new job
</summary>
</member>
<member name="P:Prajna.Core.Job.JobPort(System.UInt16)">
<summary>
 Job port to be used by remote execution container
</summary>
</member>
<member name="P:Prajna.Core.Job.JobID(System.Guid)">
<summary>
 Job ID, uniquely identify the job, inserted on 9/2015
 Job ID is initiated in DSetAction. 
</summary>
</member>
<member name="P:Prajna.Core.Job.JobDirectory(System.String)">
<summary>
 The Job Directory, if empty use default directory
</summary>
</member>
<member name="P:Prajna.Core.Job.JobDependecyObjec(Prajna.Core.JobDependencies)">
<summary>
 Linked job dependency object. 
</summary>
</member>
<member name="P:Prajna.Core.Job.JobConfiguration(System.String)">
<summary>
 Configuration for the job 
</summary>
</member>
<member name="P:Prajna.Core.Job.JobAsmBinding(Microsoft.FSharp.Core.FSharpOption{Prajna.Tools.AssemblyBinding})">
<summary>
 Assembly bindings for the job
</summary>
</member>
<member name="P:Prajna.Core.Job.IsJobHolder(System.Boolean)">
<summary>
 A Job Holder contains Assembly &amp; dependent files, a non job holder doesn&apos;t have those components. 
</summary>
</member>
<member name="P:Prajna.Core.Job.IsContainer(System.Boolean)">
<summary>
 Is the job to launch a container 
</summary>
</member>
<member name="P:Prajna.Core.Job.DstDSet(System.Collections.Generic.List{Prajna.Core.DSet})">
<summary>
 DstDSet are the set of DSets that has persist content after the completion of the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.DStreams(System.Collections.Generic.List{Prajna.Core.DStream})">
<summary>
 DStreams object used for the job
</summary>
</member>
<member name="P:Prajna.Core.Job.ClustersInfo(System.Collections.Generic.List{Prajna.Core.ClusterJobInfo})">
<summary>
 Information of the clusters that uses the Job
</summary>
</member>
<member name="P:Prajna.Core.Job.Clusters(System.Collections.Generic.List{Prajna.Core.Cluster})">
<summary>
 All Clusters to be used in the current job. 
</summary>
</member>
<member name="P:Prajna.Core.Job.Blobs(Prajna.Core.Blob[])">
<summary>
 Blobs associated with the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.BlobSync(Prajna.Core.BlobSyncMethod)">
<summary>
 Blob sync method
</summary>
</member>
<member name="P:Prajna.Core.Job.BlobStartSerial(System.Int64)">
<summary>
 Start Blob Serial Number that will define this 
</summary>
</member>
<member name="P:Prajna.Core.Job.AvailThis(Prajna.Core.BlobAvailability)">
<summary>
 Availability vector for the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.AvailPeer(System.Collections.Generic.List{Prajna.Core.BlobAvailability})">
<summary>
 Availability vector for the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.Assemblies(System.Collections.Generic.List{Prajna.Core.AssemblyEx})">
<summary>
 Assemblies 
</summary>
</member>
<member name="P:Prajna.Core.Job.VersionString">
<summary>
 Version String
</summary>
</member>
<member name="P:Prajna.Core.Job.Version">
<summary>
 Version of Job is a 64bit integer, coded through hash of assemblies. 
 The idea is that the Job can persist 
</summary>
</member>
<member name="P:Prajna.Core.Job.TypeOf">
<summary>
 Prajna Task Type
</summary>
</member>
<member name="P:Prajna.Core.Job.TryExecuteSingleJobActionFunc">
<summary>
 Obtain a SingleJobActionApp object that is used for controlling the lifecycle of a job
 This function is set by DSetAction
</summary>
</member>
<member name="P:Prajna.Core.Job.SrcDSetNumValidResponse">
<summary>
 Number of peer responded with SrcDSet request, as the SrcDSet may differ from peers
</summary>
</member>
<member name="P:Prajna.Core.Job.SrcDSetNumResponded">
<summary>
 Number of peer responded with SrcDSet request, as the SrcDSet may differ from peers
</summary>
</member>
<member name="P:Prajna.Core.Job.SrcDSet">
<summary>
 SrcDSet are the set of DSets that exist before the execution of the current job. 
</summary>
</member>
<member name="P:Prajna.Core.Job.SignatureVersion">
<summary>
 Signature Name &amp; Version uniquely define a job that can be loaded into an AppDomain/Exe
</summary>
</member>
<member name="P:Prajna.Core.Job.SignatureName">
<summary>
 Signature Name &amp; Version uniquely define a job that can be loaded into an AppDomain/Exe
</summary>
</member>
<member name="P:Prajna.Core.Job.ReadyStatus">
<summary>
 Ready Status
</summary>
</member>
<member name="P:Prajna.Core.Job.PassthroughDSet">
<summary>
 PassthroughDSet are the set that exists for the duration of the job only
</summary>
</member>
<member name="P:Prajna.Core.Job.ParameterList">
<summary>
 Get Prajna Job parameters
</summary>
</member>
<member name="P:Prajna.Core.Job.OutgoingQueuesToPeerNumber">
<summary>
 Given a queue information, lookup the peer number
 OutgoingQueuesToPeerNumber is constructed one time during job launch, no multithread issue here. 
</summary>
</member>
<member name="P:Prajna.Core.Job.NumberOfAssemblies">
<summary>
 Number of Assemblies
</summary>
</member>
<member name="P:Prajna.Core.Job.NumBlobs">
<summary>
 Number of blobs
</summary>
</member>
<member name="P:Prajna.Core.Job.NodeInfo">
<summary>
 Node Information within a job. 
</summary>
</member>
<member name="P:Prajna.Core.Job.LaunchMode">
<summary>
 Whether the job needs to be launched, a few action, e.g., &quot;stop service&quot; don&apos;t attempt to launch a new job
</summary>
</member>
<member name="P:Prajna.Core.Job.JobPort">
<summary>
 Job port to be used by remote execution container
</summary>
</member>
<member name="P:Prajna.Core.Job.JobID">
<summary>
 Job ID, uniquely identify the job, inserted on 9/2015
 Job ID is initiated in DSetAction. 
</summary>
</member>
<member name="P:Prajna.Core.Job.JobEnvVars">
<summary>
 Environment Variables for the job
</summary>
</member>
<member name="P:Prajna.Core.Job.JobDirectory">
<summary>
 The Job Directory, if empty use default directory
</summary>
</member>
<member name="P:Prajna.Core.Job.JobDependencies">
<summary>
 Job File Dependencies
</summary>
</member>
<member name="P:Prajna.Core.Job.JobDependecyObjec">
<summary>
 Linked job dependency object. 
</summary>
</member>
<member name="P:Prajna.Core.Job.JobConfiguration">
<summary>
 Configuration for the job 
</summary>
</member>
<member name="P:Prajna.Core.Job.JobAsmBinding">
<summary>
 Assembly bindings for the job
</summary>
</member>
<member name="P:Prajna.Core.Job.IsJobHolder">
<summary>
 A Job Holder contains Assembly &amp; dependent files, a non job holder doesn&apos;t have those components. 
</summary>
</member>
<member name="P:Prajna.Core.Job.IsContainer">
<summary>
 Is the job to launch a container 
</summary>
</member>
<member name="P:Prajna.Core.Job.DstDSet">
<summary>
 DstDSet are the set of DSets that has persist content after the completion of the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.DStreams">
<summary>
 DStreams object used for the job
</summary>
</member>
<member name="P:Prajna.Core.Job.ContainerJobCollection">
<summary>
 ContainerJobCollection contains a list of DLLs signature of the current job. 
 Each signature is the signature of a collection of DLLs that is used by the current program. 
 It is used to track DLLs being loaded into the current AppDomain, and will usually only increase. 
 They will be released by Cleanup
</summary>
</member>
<member name="P:Prajna.Core.Job.ClustersInfo">
<summary>
 Information of the clusters that uses the Job
</summary>
</member>
<member name="P:Prajna.Core.Job.Clusters">
<summary>
 All Clusters to be used in the current job. 
</summary>
</member>
<member name="P:Prajna.Core.Job.Blobs">
<summary>
 Blobs associated with the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.BlobSync">
<summary>
 Blob sync method
</summary>
</member>
<member name="P:Prajna.Core.Job.BlobStartSerial">
<summary>
 Start Blob Serial Number that will define this 
</summary>
</member>
<member name="P:Prajna.Core.Job.AvailThis">
<summary>
 Availability vector for the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.AvailPeer">
<summary>
 Availability vector for the current job
</summary>
</member>
<member name="P:Prajna.Core.Job.Assemblies">
<summary>
 Assemblies 
</summary>
</member>
<member name="P:Prajna.Core.Job.AllAvailable">
<summary>
 Is all metadata available for execution
</summary>
</member>
<member name="M:Prajna.Core.Job.UpdateSourceAvailability(System.Boolean)">
<summary>
 Calculate dependent DSet &amp; mark availability. 
</summary>
</member>
<member name="M:Prajna.Core.Job.UpdateOutgoingQueueStatus(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.PerQueueJobStatus,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.PerQueueJobStatus,Prajna.Core.PerQueueJobStatus}},Prajna.Core.PerQueueJobStatus)">
<summary>
 Send Current Job Metadata to each peer. 
 Update the status of outgoing queue
</summary>
</member>
<member name="M:Prajna.Core.Job.UpdateMetadata">
<summary>
 Update metadata
 Return: 
     true:  all metadata becomes available
     false: some metadata is still not available. 
</summary>
</member>
<member name="M:Prajna.Core.Job.UpdateClusterJobInfo">
<summary>
 Try to Update node information within Job
</summary>
</member>
<member name="M:Prajna.Core.Job.UpdateBlobInfo(System.Int32)">
<summary>
 When a blob is written, the blob name &amp; version can change (especially for DSet). We thus need to update the associated blob information. 
</summary>
</member>
<member name="M:Prajna.Core.Job.UnpackToBlob(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Deserialize Job description to Blob, 
</summary>
</member>
<member name="M:Prajna.Core.Job.UnallocateBlob(System.Int32)">
<summary>
 Release the memory of a particular blob
</summary>
</member>
<member name="M:Prajna.Core.Job.UnallocateAllBlobs">
<summary>
 Release the memory of all blobs
</summary>
</member>
<member name="M:Prajna.Core.Job.TryLoadSrcMetadata">
<summary>
 Try load metadata. 
</summary>
</member>
<member name="M:Prajna.Core.Job.StreamForWrite(Prajna.Core.Blob)">
<summary>
 The job is properly decoded. 
</summary>
</member>
<member name="M:Prajna.Core.Job.ShowAllDObjectsInfo">
<summary>
 Show all objects (the following format is more debuggable
</summary>
</member>
<member name="M:Prajna.Core.Job.SetMetaDataAvailability(Prajna.Core.DSet)">
<summary>
 Set metadata availability fo a DSet according to job availability. 
</summary>
</member>
<member name="M:Prajna.Core.Job.SendBlobToJob(Prajna.Core.NetworkCommandQueue,System.Int32)">
<summary>
 Send blob to peer 
</summary>
</member>
<member name="M:Prajna.Core.Job.SendBlobToHost(Prajna.Core.NetworkCommandQueue,System.Int32)">
<summary>
 Send blob to host, always use non hash version here.  
</summary>
</member>
<member name="M:Prajna.Core.Job.SendBlobPeeri(System.Int32,Prajna.Core.NetworkCommandQueue,System.Int32)">
<summary>
 Send blob to peer i, used by client
</summary>
</member>
<member name="M:Prajna.Core.Job.ResolveDSetAfterMetadataSync(Prajna.Core.DSet)">
<summary>
 Because it is possible for the DSet version to get updated, so that we will need to get the correct DSet version (if necessary) 
</summary>
</member>
<member name="M:Prajna.Core.Job.ReadyMetaData">
<summary>
 Exchange with peer on metadata content, get all metadata ready. 
</summary>
</member>
<member name="M:Prajna.Core.Job.Ready">
<summary>
 Is the job ready to be executed?
</summary>
</member>
<member name="M:Prajna.Core.Job.PropagateMetadata">
<summary>
 Propagate metadata
 Return:
     true: all metadata becomes available
     false: some metadata is still not available. 
</summary>
</member>
<member name="M:Prajna.Core.Job.PrepareToReceiveSourceMetadata">
<summary>
 For those source metadata that needs to be read, set their version to minimum value to trigger receiving latest version 
</summary>
</member>
<member name="M:Prajna.Core.Job.PrepareRemoteExecutionRosterOnce(Prajna.Core.JobDependencies,Prajna.Core.Job)">
<summary>
 We have the lock in switching 
 Prepare a remote execution roster. 
</summary>
</member>
<member name="M:Prajna.Core.Job.PrepareRemoteExecutionRoster(Prajna.Core.JobDependencies,Prajna.Core.Job)">
<summary>
 Prepare a remote execution roster. 
</summary>
</member>
<member name="M:Prajna.Core.Job.PrepareMetaData">
<summary>
 Prepare Job Metadata to be sent to other peers. 
</summary>
</member>
<member name="M:Prajna.Core.Job.PrecodeDSets">
<summary>
 Generate Hash for DSet &amp; DStream, precoding. 
</summary>
</member>
<member name="M:Prajna.Core.Job.PopulateLoadedAssems">
<summary>
 Populate loaded assemblies, 
 Extended after similar function in ReflectionTools.fs
</summary>
</member>
<member name="M:Prajna.Core.Job.PeekJob(System.IO.Stream)">
<summary>
 Peek Serialized Job, extract Name, Version, and Job ID 
</summary>
</member>
<member name="M:Prajna.Core.Job.Pack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Pack to send the job information to client
 Define blobs that is used to identify data/metadata to be used during the job. 
 Job version is generated during pack, based on assemblies. 
</summary>
</member>
<member name="M:Prajna.Core.Job.JobStatus">
<summary>
 Return a (status, string) explaining the status of the job
</summary>
</member>
<member name="M:Prajna.Core.Job.InitializeAvailability">
<summary>
 Initialize the avaliablity vector
</summary>
</member>
<member name="M:Prajna.Core.Job.InitializeAllQueues">
<summary>
 Get All nodes (and queues) that is associated with the current job
</summary>
</member>
<member name="M:Prajna.Core.Job.GetOutgoingQueueStatus(System.Int32)">
<summary>
 Get the status of the outgoing queue
</summary>
</member>
<member name="M:Prajna.Core.Job.GetExecutionMode">
<summary>
 Get the execution mode needed by the current task. 
</summary>
</member>
<member name="M:Prajna.Core.Job.GetAllClusters">
<summary>
 Get All clusters associated with the DSets. 
</summary>
</member>
<member name="M:Prajna.Core.Job.GenerateSignature(System.Byte[])">
<summary>
 Generate a signature that best capture the current set of assemblies. 
 The signature is based on the assemblies and their referenced assemblies that are loaded at the time GenerateSignature
 function is called. 
</summary>
</member>
<member name="M:Prajna.Core.Job.EncodeToBlob(Prajna.Core.Blob)">
<summary>
 Encode metadata/content to blob
</summary>
</member>
<member name="M:Prajna.Core.Job.DisposeBlobsAndMetadataStream">
<summary>
 Free all resource related to the Job
</summary>
</member>
<member name="M:Prajna.Core.Job.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Core.Job.DecodeFromBlob(System.Int32,System.Int32)">
<summary>
 Decode from Blob
 For Assemblies, the received assemblies is put into file (directory), but is not loaded. 
 For Cluster, the received cluster is decoded, loaded into ClusterFactory, and saved (persisted)
 For DSet, the received DSet is decoded. It isn&apos;t loaded into DSetFactory. 
     For DSet that needs special assemblies, it is important to call DecodeFromBlob only in AppDomain, as the necessary assemblies may not be loaded. 
</summary>
</member>
<member name="M:Prajna.Core.Job.ClearSrcDSet">
<summary>
 Clear Source DSet
</summary>
</member>
<member name="M:Prajna.Core.Job.CalculateDependantDSet">
<summary>
 Calculate dependent DSet &amp; mark availability. 
 Return: true: if DSet availability has changed, false: no change
</summary>
</member>
<member name="M:Prajna.Core.Job.BypassSetup(Prajna.Core.DSet)">
<summary>
 Specific aid to setup structure
</summary>
</member>
<member name="M:Prajna.Core.Job.BlobiPeerStatusString(System.Int32)">
<summary>
 Blob Status
</summary>
</member>
<member name="M:Prajna.Core.Job.AddUnmanagedAssemblyAndComputeHash(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Unmanaged Assembly, this will be a folder which can contain any kind of data/assemblies to be sent out. 
</summary>
</member>
<member name="M:Prajna.Core.Job.AddSrcDSet(Prajna.Core.DSet)">
<summary>
 Add a source DSet 
</summary>
</member>
<member name="M:Prajna.Core.Job.AddOutoingQueue(Prajna.Core.NetworkCommandQueue,Prajna.Core.Cluster)">
<summary>
 Add a new queue to the cluster
</summary>
</member>
<member name="M:Prajna.Core.Job.AddDstDSet(Prajna.Core.DSet)">
<summary>
 Add a DSet to a destination DSet (a sink for the job)
</summary>
</member>
<member name="M:Prajna.Core.Job.AddDependencies">
<summary>
 Add dependent DSets. 
 Deprecated
</summary>
</member>
<member name="M:Prajna.Core.Job.AddDSet(Prajna.Core.DSet)">
<summary>
 Add DSet to the job, depending on whether the current DSet is a passthrough, it will be added to either the SrcDSet list or PassthroughDSet list.
 Return:
     true: dset is added to the list
     false: dset has already been in job (e.g., added via dependancy of other DSets).
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.DefaultTypeOfJobMask@">
<summary>
 Remote container execute mode control
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.NativeDeserializerCollection@">
<summary>
 Collection of native deserializer function, to avoid reinstall same deserializer
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.NativeSerializerCollection@">
<summary>
 Collection of native serializer function, to avoid reinstall same serializer 
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.DeserializerCollection@">
<summary>
 Collection of Customized Deserializer by Guid
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.SerializerCollection@">
<summary>
 Collection of Customized Serializer 
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.MemoryManagerCollection@">
<summary>
 Collection of Customized Allocator
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.JobPort@">
<summary>
 Port used by job, if 0us, a port will be assigned by the daemon
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.EnvVars@">
<summary>
 Additional Environmental setting required by the remote container 
 It will be used to set ProcessStartInfo.EnvironmentVariables during the launch of the remote container
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.JobDirectory@">
<summary>
 Job Directory of the remote container 
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.JobName@">
<summary>
 Remote container name 
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.nDependencyChanged@">
<summary>
 If any new dependency has been added to the file.
 if 1: there are dependency changes. 
 if 0: there are no dependency change
 1 -&gt; 0 is a lock, which multiple process can compete in launch the remote execution container.  
</summary>
</member>
<member name="F:Prajna.Core.JobDependencies.Current@">
<summary>
 Current execution roster
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.JobPort(System.UInt16)">
<summary>
 Port used by job, if 0us, a port will be assigned by the daemon
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.JobName(System.String)">
<summary>
 Remote container name 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.JobDirectory(System.String)">
<summary>
 Job Directory of the remote container 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.DefaultTypeOfJobMask(Prajna.Core.JobTaskKind)">
<summary>
 Remote container execute mode control
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.Current(Prajna.Core.JobDependencies)">
<summary>
 Current execution roster
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.setCurrentJob(System.String)">
<summary>
 Assign a name to the remote container, 
 All services &amp; data analytical jobs with the same jobName will be put into the same container for execution, and 
 calling between services and/or data analytical jobs within the container is a native functional call. 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.nDependencyChanged">
<summary>
 If any new dependency has been added to the file.
 if 1: there are dependency changes. 
 if 0: there are no dependency change
 1 -&gt; 0 is a lock, which multiple process can compete in launch the remote execution container.  
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.SerializerCollection">
<summary>
 Collection of Customized Serializer 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.NativeSerializerCollection">
<summary>
 Collection of native serializer function, to avoid reinstall same serializer 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.NativeDeserializerCollection">
<summary>
 Collection of native deserializer function, to avoid reinstall same deserializer
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.MemoryManagerCollection">
<summary>
 Collection of Customized Allocator
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.JobPort">
<summary>
 Port used by job, if 0us, a port will be assigned by the daemon
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.JobName">
<summary>
 Remote container name 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.JobDirectory">
<summary>
 Job Directory of the remote container 
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.EnvVars">
<summary>
 Additional Environmental setting required by the remote container 
 It will be used to set ProcessStartInfo.EnvironmentVariables during the launch of the remote container
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.DeserializerCollection">
<summary>
 Collection of Customized Deserializer by Guid
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.DefaultTypeOfJobMask">
<summary>
 Remote container execute mode control
</summary>
</member>
<member name="P:Prajna.Core.JobDependencies.Current">
<summary>
 Current execution roster
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.UnPackCustomizedFuncCollection(Prajna.Tools.MemoryStreamB)">
<summary>
 The deserializer collection is always coded to a separate bytestream, to be wrapped for delivery 
 The bytestream is only deserialized at the remote execution container, not at daemon. 
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.SetJobPort(System.UInt16)">
<summary>
 Set Job to use a certain port 
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.PackCustomizedFuncCollection">
<summary>
 The serializer collection is always coded to a separate bytestream, to be wrapped for delivery 
 The bytestream is only deserialized at the remote execution container, not at daemon. 
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.JobDependencySHA256">
<summary>
 Job File Dependencies Hash
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallSerializerDelegate(System.Guid,System.String,System.Action{System.Tuple{System.Object,System.IO.Stream}},System.String,System.Boolean)">
 <summary> 
 InstallSerializerDelegate allows language other than F# to install its own type serialization implementation. 
 </summary> 
 <param name="id"> Guid, that uniquely identifies the serializer/deserializer installed. </param>
 <param name="fulltypename"> Type.FullName that captures object that will trigger the serializer. 
         please note that the customized serializer/deserializer will not be triggered on the derivative type. You may need to install additional 
         serializer if multiple derivative type share the same customzied serializer/deserializer. </param>
 <param name="del"> An action delegate that perform the serialization function. </param>
 <param name="info"> A string that annotates the serializer installed. </param>
 <param name="bInstallAsDefault"> If true, install serializer as default. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallSerializerDelegate(System.Guid,System.String,System.Action{System.Tuple{System.Object,System.IO.Stream}},System.String,System.Boolean,System.Boolean)">
 <summary> 
 InstallSerializerDelegate allows language other than F# to install its own type serialization implementation. 
 </summary> 
 <param name="id"> Guid, that uniquely identifies the serializer/deserializer installed. </param>
 <param name="fulltypename"> Type.FullName that captures object that will trigger the serializer. 
         please note that the customized serializer/deserializer will not be triggered on the derivative type. You may need to install additional 
         serializer if multiple derivative type share the same customzied serializer/deserializer. </param>
 <param name="del"> An action delegate that perform the serialization function. </param>
 <param name="info"> A string that annotates the serializer installed. </param>
 <param name="bAllowReplicate"> should be false, does not allow multiple serializer with same Guid.  </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallSerializer``1(System.Guid,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.IO.Stream},Microsoft.FSharp.Core.Unit},System.String,System.Boolean)">
 <summary>
 Install a customized serializer, with a unique GUID that identified the use of the serializer in the bytestream. 
 </summary>
 <param name="id"> Guid that uniquely identified the use of the serializer in the bytestream. The Guid is used by the deserializer to identify the need to 
 run a customized deserializer function to deserialize the object. </param>
 <param name="encodeFunc"> Customized Serialization function that encodes the 'Type to a bytestream.  </param>
 <param name="info"> A string that annotates the serializer installed. </param>
 <param name="bInstallAsDefault"> If true, install serializer as default. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallSerializer``1(System.Guid,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.IO.Stream},Microsoft.FSharp.Core.Unit},System.String)">
 <summary>
 Install a customized serializer, with a unique GUID that identified the use of the serializer in the bytestream. 
 </summary>
 <param name="id"> Guid that uniquely identified the use of the serializer in the bytestream. The Guid is used by the deserializer to identify the need to 
 run a customized deserializer function to deserialize the object. </param>
 <param name="encodeFunc"> Customized Serialization function that encodes the 'Type to a bytestream.  </param>
 <param name="info"> A string that annotates the serializer installed. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallSerializer``1(System.Guid,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.IO.Stream},Microsoft.FSharp.Core.Unit},System.String,System.Boolean,System.Boolean)">
 <summary>
 Install a customized serializer, with a unique GUID that identified the use of the serializer in the bytestream. 
 Because the system has no way to tell if an encodeFunc is different from the other, 
 we will only install the first serializer of a ID. Subsequent installation will be ignored. 
 </summary>
 <param name="id"> Guid that uniquely identified the use of the serializer in the bytestream. The Guid is used by the deserializer to identify the need to 
 run a customized deserializer function to deserialize the object. </param>
 <param name="encodeFunc"> Customized Serialization function that encodes the 'Type to a bytestream.  </param>
 <param name="info"> A string that annotates the serializer installed. </param>
 <param name="bAllowReplicate"> Should be false, does not allow multiple serializer with same Guid.  </param>
 <param name="bInstallAsDefault"> If true, install the serializer as default.  </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallMemoryManager``1(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit},System.Boolean)">
 <summary>
 Install a customized Memory Manager. 
 </summary>
 <param name="id"> Guid that uniquely identified the use of the memory manager in the bytestream. </param>
 <param name="allocFunc"> Customized function to grab an obect of 'Type.  </param>
 <param name="preallocFunc"> PreAlloc N objects. If 0 is given as input, the function will free all objects in the pool.  </param>
 <param name="bAllowReplication"> Whether allow memory manager to be installed repeatedly. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallDeserializerDelegate(System.Guid,System.String,System.Func{System.IO.Stream,System.Object},System.String)">
 <summary> 
 InstallDeserializerDelegate allows language other than F# to install its own type deserialization implementation. 
 </summary> 
 <param name = "id"> Guid, that uniquely identifies the serializer/deserializer installed. </param>
 <param name = "fulltypename"> Type.FullName that captures object that will trigger the serializer. 
         please note that the customized serializer/deserializer will not be triggered on the derivative type. You may need to install additional 
         serializer if multiple derivative type share the same customzied serializer/deserializer </param>
 <param name = "del"> A function delegate that perform the deserialization function. </param>
 <param name="info"> A string that annotates the serializer installed. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallDeserializerDelegate(System.Guid,System.String,System.Func{System.IO.Stream,System.Object},System.String,System.Boolean)">
 <summary> 
 InstallDeserializerDelegate allows language other than F# to install its own type deserialization implementation. 
 </summary> 
 <param name = "id"> Guid, that uniquely identifies the serializer/deserializer installed. </param>
 <param name = "fulltypename"> Type.FullName that captures object that will trigger the serializer. 
         please note that the customized serializer/deserializer will not be triggered on the derivative type. You may need to install additional 
         serializer if multiple derivative type share the same customzied serializer/deserializer </param>
 <param name="info"> A string that annotates the serializer installed. </param>
 <param name = "del"> A function delegate that perform the deserialization function. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallDeserializer``1(System.Guid,Microsoft.FSharp.Core.FSharpFunc{System.IO.Stream,``0},System.String)">
 <summary>
 Install a customized deserializer, with a unique GUID that identified the use of the deserializer in the bytestream. 
 </summary>
 <param name="id"> Guid that uniquely identified the deserializer in the bytestream. </param>
 <param name="decodeFunc"> Customized Deserialization function that decodes bytestream to 'Type.  </param>
 <param name="info"> A string that annotates the serializer installed. </param>
</member>
<member name="M:Prajna.Core.JobDependencies.InstallDeserializer``1(System.Guid,Microsoft.FSharp.Core.FSharpFunc{System.IO.Stream,``0},System.String,System.Boolean)">
 <summary>
 Install a customized deserializer, with a unique GUID that identified the use of the deserializer in the bytestream. 
 </summary>
 <param name="id"> Guid that uniquely identified the deserializer in the bytestream. </param>
 <param name="decodeFunc"> Customized Deserialization function that decodes bytestream to 'Type.  </param>
 <param name="info"> A string that annotates the serializer installed. </param>
 <param name="bAllowReplicate"> should be false, does not allow multiple serializer with same Guid.  </param>
</member>
<member name="M:Prajna.Core.JobDependencies.GetVerStr">
<summary>
 Get Hash version string
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.GetSerializerInformation(System.Guid)">
 <summary>
 Get information of a serializer
 </summary>
</member>
<member name="M:Prajna.Core.JobDependencies.GetSchemaInformation(System.Guid)">
 <summary>
 Get information, either of serializer or deserializer 
 </summary>
</member>
<member name="M:Prajna.Core.JobDependencies.GetDeserializerInformation(System.Guid)">
 <summary>
 Get information of a deserializer
 </summary>
</member>
<member name="M:Prajna.Core.JobDependencies.AddTo(System.Tuple{System.String,System.String}[])">
<summary>
 Add a list of mapped file between remote and local. 
 The first item of each tuple is the local file, and the second item of each tuple is the remote file name. 
 The local file will be sent to remote file during the launch of the remote container. 
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.AddRefAssem(System.Boolean)">
<summary>
 Add referenced assemblies of the current program into dependency. The remote assembly will be located under current JobDirectory.
 If bAddPdb flag is true, PDB file is added to the remote  JobDirectory too. 
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.AddPdbsTo(System.Tuple{System.String,System.String}[])">
<summary>
 Add corresponding pdbs if they exist
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.AddLocalRemote(System.Tuple{System.String,System.String})">
<summary>
 Add a mapped file between remote and local. 
 The first item of the tuple is the local file, and the second item of the tuple is the remote file name. 
 The local file will be sent to remote file during the launch of the remote container. 
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.AddEnvVars(System.String,System.String)">
<summary>
 Additional Environmental setting required by the remote container 
 It will be used to set ProcessStartInfo.EnvironmentVariables during the launch of the remote container
</summary>
</member>
<member name="M:Prajna.Core.JobDependencies.AddDataDirectoryWithPrefix(System.String,System.String,System.String,System.String,System.IO.SearchOption)">
 <summary> 
 Add all data files in the directory for remote execution. The program/service that is executed remote should use remote prefix to access the data file. 
 </summary>
 <param name="prefix"> Defines what is the start of the remote name. </param>
 <param name="dirname"> the directory underwhich all data file should be added. </param>
 <param name="searchPattern">  The search string to match against the names of files in path. This parameter can contain a combination of valid literal 
 path and wildcard (* and ?) characters (see Remarks), but doesn't support regular expressions. </param> 
 <param name="searchOption"> One of the enumeration values that specifies whether the search operation should include all subdirectories or only the current directory. </param>
 <return>
 remoteprefix to be used to access datafile in the directory. 
 </return>    
</member>
<member name="M:Prajna.Core.JobDependencies.AddDataDirectory(System.String)">
 <summary> 
 Add all data files in the directory for remote execution. The program/service that is executed remote should use remote prefix to access the data file. 
 </summary>
 <param name="dirname"> the directory underwhich all data file should be added. The function only adds the file of the current directory, and does not perform recursive 
 mapping. </param>
 <return>
 remoteprefix to be used to access datafile in the directory. 
 </return>    
</member>
<member name="M:Prajna.Core.JobDependencies.AddDataDirectory(System.String,System.String)">
 <summary> 
 Add all data files in the current directory for remote execution. The program/service that is executed remote should use remote prefix to access the data file. 
 </summary>
 <param name="dirname"> the directory underwhich all data file should be added. </param>
 <param name="searchPattern">  The search string to match against the names of files in path. This parameter can contain a combination of valid literal 
 path and wildcard (* and ?) characters (see Remarks), but doesn't support regular expressions. Only file in the currently directory is added. 
 That is, SearchOption.TopDirectoryOnly is used to traverse the local directory.  </param> 
 <return>
 remoteprefix to be used to access datafile in the directory. 
 </return>    
</member>
<member name="M:Prajna.Core.JobDependencies.AddDataDirectory(System.String,System.String,System.IO.SearchOption)">
 <summary> 
 Add all data files in the directory for remote execution. The program/service that is executed remote should use remote prefix to access the data file. 
 </summary>
 <param name="dirname"> the directory underwhich all data file should be added. </param>
 <param name="searchPattern">  The search string to match against the names of files in path. This parameter can contain a combination of valid literal 
 path and wildcard (* and ?) characters (see Remarks), but doesn't support regular expressions. </param> 
 <param name="searchOption"> One of the enumeration values that specifies whether the search operation should include all subdirectories or only the current directory. </param>
 <return>
 remoteprefix to be used to access datafile in the directory. 
 </return>    
</member>
<member name="M:Prajna.Core.JobDependencies.Add(System.String[])">
<summary>
 Add a list of mapped file between remote and local. 
 The remote file will be under the current JobDirectory, with the same file name and extension of the local file (the path of the local file is ignored). 
</summary>
</member>
<member name="T:Prajna.Core.JobDependencies">
 <summary>
 Remote execution roster, which contains a list of file (dlls, data, environment variables) that is required for the job 
 </summary>
</member>
<member name="M:Prajna.Core.JobDependency.Unpack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Unpack file from stream 
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.ToAssembly(System.String)">
<summary>
 Try to represent Job Dependency as assembly
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.Pack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Pack file to stream 
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.LoadJobDirectory(System.String)">
<summary>
 Load file into job directory
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.GetDependency(System.String,System.Byte[],System.Boolean)">
<summary>
 Is the file available locally?
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.ConstructLocation(System.String,System.Byte[])">
<summary>
 Construct folder name for file 
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.ComputeHash">
<summary>
 Compute hash based on current file 
</summary>
</member>
<member name="M:Prajna.Core.JobDependency.ComputeHash(System.Byte[])">
<summary>
 Compute the signature of the file
 we use the last 8B of Hash as signature
</summary>
</member>
<member name="T:Prajna.Core.JobFactory">
<summary>
 Prajna Job
 A Prajna Job is a set of actions to be executed on Prajna. 
</summary>
</member>
<member name="F:Prajna.Core.JobInformation.ClustersInfo@">
<summary>
 ClusterInfo object that holds in Job node information of a cluster. 
 To differentiate job 
 Information of the clusters that uses the Job.
 This Information will be filled at the time of construction.
</summary>
</member>
<member name="F:Prajna.Core.JobInformation.TryGetDerivedJobInformationFunc@">
<summary>
 Try to get a derived Job information object 
</summary>
</member>
<member name="P:Prajna.Core.JobInformation.TryGetDerivedJobInformationFunc(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.DistributedObject,Prajna.Core.JobInformation})">
<summary>
 Try to get a derived Job information object 
</summary>
</member>
<member name="P:Prajna.Core.JobInformation.ClustersInfo(System.Collections.Generic.List{Prajna.Core.ClusterJobInfo})">
<summary>
 ClusterInfo object that holds in Job node information of a cluster. 
 To differentiate job 
 Information of the clusters that uses the Job.
 This Information will be filled at the time of construction.
</summary>
</member>
<member name="P:Prajna.Core.JobInformation.TryGetDerivedJobInformationFunc">
<summary>
 Try to get a derived Job information object 
</summary>
</member>
<member name="P:Prajna.Core.JobInformation.JobID">
<summary>
 JobID of the job information object. 
</summary>
</member>
<member name="P:Prajna.Core.JobInformation.ClustersInfo">
<summary>
 ClusterInfo object that holds in Job node information of a cluster. 
 To differentiate job 
 Information of the clusters that uses the Job.
 This Information will be filled at the time of construction.
</summary>
</member>
<member name="M:Prajna.Core.JobInformation.TryGetDerivedJobInformationImpl(Prajna.Core.DistributedObject)">
<summary>
 Created a replicated Job Information, but for a different Distributed object
</summary>
</member>
<member name="M:Prajna.Core.JobInformation.TryExecuteSingleJobAction">
<summary>
 Try grab an instance of a jobAction object to perform work on the job. 
 If null is returned, the job has been cancelled. 
</summary>
</member>
<member name="M:Prajna.Core.JobInformation.PartitionFailureFuture(System.Exception,System.String,System.Int32)">
<summary>
 Partition Failure
 A certain partition has failed to execute. 
 Other partition may still executable.
</summary>
</member>
<member name="M:Prajna.Core.JobInformation.PartitionFailure(System.Exception,System.String,System.Int32)">
<summary>
 Partition Failure
 A certain partition has failed to execute. 
 Other partition may still executable.
</summary>
</member>
<member name="M:Prajna.Core.JobInformation.OnException(System.Exception)">
<summary>
 Exception should be called when there is no hope for the job to be recovered. 
</summary>
</member>
<member name="T:Prajna.Core.JobInformation">
<summary>
 Internal data structure to pass data analytical job related information 
 Class exposed because of being used in an Abstract function
</summary>
</member>
<member name="F:Prajna.Core.JobLifeCycle.EndJobMark@">
<summary>
 EndJob has been called, the flag is mainly serve for debugging purpose. 
 If the jobLifeCycle object hasn&apos;t been disposed after EndJob has been called for a while, something is wrong 
</summary>
</member>
<member name="F:Prajna.Core.JobLifeCycle.CTS@">
<summary>
 Cancellation Token
 Job using the lifecycle object may register and listen to cancellation request on this token. 
</summary>
</member>
<member name="F:Prajna.Core.JobLifeCycle.MaxWaitToEndJobInMilliseconds@">
<summary>
 If a job is idle for this much time, it is considered to have problems, and may be cancelled. 
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.MaxWaitToEndJobInMilliseconds(System.Int32)">
<summary>
 If a job is idle for this much time, it is considered to have problems, and may be cancelled. 
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.EndJobMark(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
 EndJob has been called, the flag is mainly serve for debugging purpose. 
 If the jobLifeCycle object hasn&apos;t been disposed after EndJob has been called for a while, something is wrong 
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.MaxWaitToEndJobInMilliseconds">
<summary>
 If a job is idle for this much time, it is considered to have problems, and may be cancelled. 
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.JobID">
<summary>
 Guid that indicates the current Job
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.IsCancellationRequested">
<summary>
 Perform registered operation on excetion
 First exception will be thrown 
 Is the job cancelled
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.HasException">
<summary>
 Has Exception been thrown 
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.Exception">
<summary>
 Exception to throw here
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.EndJobMark">
<summary>
 EndJob has been called, the flag is mainly serve for debugging purpose. 
 If the jobLifeCycle object hasn&apos;t been disposed after EndJob has been called for a while, something is wrong 
</summary>
</member>
<member name="P:Prajna.Core.JobLifeCycle.CTS">
<summary>
 Cancellation Token
 Job using the lifecycle object may register and listen to cancellation request on this token. 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.WaitHandleForCancellation">
<summary>
 WaitHandle for cancellation
 Should use TryEnterJob everytime that process is waken up 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.RegisterCancellation(System.Threading.CancellationToken)">
<summary>
 Register CancelationToken, 
 When this CancelationToken is cancelled, The lifecycle object&apos;s CancelJob() will be called, which inform its CancellationToken that it has been cancelled. 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.OnExceptionFS(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit})">
<summary>
 These operation will be executed every time when an exception is thrown 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.OnException(System.Action{System.Exception})">
<summary>
 These operation will be executed every time when an exception is thrown 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.OnDisposeFS(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 These actions will be executed once after the Job ends 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.OnDispose(System.Action)">
<summary>
 These actions will be executed once after the Job ends 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.OnCancellationFS(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 These actions will be executed once when a cancellation is encountered 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.OnCancellation(System.Action)">
<summary>
 These actions will be executed once when a cancellation is encountered 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.LogException">
<summary>
 Log Exception 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.ExceptionCallbackFS(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit})">
<summary>
 This single operation will be executed every time when an exception is thrown 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.ExceptionCallback(System.Action{System.Exception})">
<summary>
 This single operation will be executed every time when an exception is thrown 
 Only one operation is assigned. If there is a previous action for exception, the new operation 
 will NOT be inserted. 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.EndJob">
<summary>
 End/Cancel a particular job
 This function can be called multiple times concurrently, only one instance of the call will be executed. 
 Also, during execution, it will wait for any SingleJobActionGeneric that relies on the current job to complete before executing this action. 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.DisposeJob">
<summary>
 Dispose job, the job structure should not be used afterwards
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.DSetExceptionAtDaemon(System.Exception,System.String,System.Int64)">
<summary>
 Exception AT Daemon 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.CancelJob">
<summary>
 Try to cancel JobLifeCycle, multiple cancel call is OK, but only first will be processed. 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.CancelByException(System.Exception)">
<summary>
 Cancel by Exception 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycle.CancelByError(System.Exception)">
<summary>
 Perform registered operation on excetion
 First exception will be thrown 
 Cancel by Error
 Error is usually program exception. As such, we only send back one error.  
</summary>
</member>
<member name="T:Prajna.Core.JobLifeCycle">
<summary>
 Job Lifecycle management
</summary>
</member>
<member name="T:Prajna.Core.JobLifeCycleCollectionApp">
<summary>
 Job Lifecycle management at the application
</summary>
</member>
<member name="T:Prajna.Core.JobLifeCycleCollectionContainer">
<summary>
 Job Lifecycle management at the application
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycleCollectionGeneric`1.RegisterJob(`0)">
<summary>
 Register a jobLifeCycle object, 
 Return:
     true: a new object is created ..
     false: a previous object is already there 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycleCollectionGeneric`1.GetAllJobs">
<summary>
 Allow enumerating through all jobs 
</summary>
</member>
<member name="T:Prajna.Core.JobLifeCycleCollectionGeneric`1">
<summary>
 Job Lifecycle management at the application
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycleContainer.ToSend(Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Send/forward a message 
</summary>
</member>
<member name="M:Prajna.Core.JobLifeCycleContainer.SendExceptionBackGeneral(System.Exception)">
<summary>
 Send an exception
</summary>
</member>
<member name="T:Prajna.Core.JobLifeCycleContainer">
<summary>
 Job Lifecycle management at the container 
</summary>
</member>
<member name="M:Prajna.Core.JobListener.OnIncomingQueue(Prajna.Core.NetworkCommandQueuePeer)">
<summary>
 Default on Accept
</summary>
</member>
<member name="M:Prajna.Core.JobListener.InitializeListenningPort(System.String,System.Int32)">
<summary>
 Start a listening port on certain port
</summary>
</member>
<member name="T:Prajna.Core.JobListeningPortManagement">
<summary>
 Manage Listening port for the job
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.StartReadOne">
<summary>
 Attempt to launch the remote container as a light read job
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.LightCPULoad">
<summary>
 Attempt to launch the remote container as a light job
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.ReleaseApplicationMask">
<summary>
 Attempt to launch the remote container as a Release Application
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.ReleaseMask">
<summary>
 Attempt to launch the remote container as a Release Application
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.ApplicationMask">
<summary>
 Attempt to launch the remote container as an Application attached to Daemon
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.AppDomainMask">
<summary>
 Attempt to launch the remote container as an AppDomain attached to Daemon
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.ExecActionMask">
<summary>
 Mask that govern how a remote container is launched 
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.PersistentMask">
<summary>
 Mask that govern close of remote container 
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.JobActionMask">
<summary>
 Remote container mask used internally 
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.InRAMDataMask">
<summary>
 Remote container may use in RAM data 
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.Computation">
<summary>
 Attempt to launch a Light computation job within daemon
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.ReadOne">
<summary>
 Attempt to launch a Read Job within daemon
</summary>
</member>
<member name="F:Prajna.Core.JobTaskKind.None">
<summary>
 Default, the remote daemon determines how to launch job/service
</summary>
</member>
<member name="T:Prajna.Core.JobTaskKind">
<summary>
 Enumeration class that controls how a remote container for the job/service is executed. 
</summary>
</member>
<member name="M:Prajna.Core.JobTraverse.TraverseDependencyObj(Prajna.Core.TraverseDirection,System.Collections.Generic.List{Prajna.Core.DistributedObject},Prajna.Core.DistributedObject)">
<summary>
 Get all dependent DSets &amp; DStream
 obj: the current object to used in traversal
 flag: 0, trace upstream
       1, trace downstream
</summary>
</member>
<member name="M:Prajna.Core.JobTraverse.GetDSetChain(Prajna.Core.DistributedObject,Prajna.Core.TraverseDirection,Prajna.Core.DSetChainFlag)">
<summary>
 Parsed chained DSet
 flag with mask DSetChainFlag.Passthrough, return all passthrough DSet in the chains
 flag with mask DSetChainFlag.Source, return all source DSet in the chains
 flag with mask DSetChainFlag.Destination, return all destination DSet in the chain. 
</summary>
</member>
<member name="T:Prajna.Core.JobTraverse">
<summary>
 JobTraverse is used to traverse multiple object hosted in a job to figure out
 Src, Dst and Passthrough DSet and various objects. 
 We define a separate JobTraverse() object to recognize the need to figure out the source/destination DSet involved in a particular action, 
 which can be a subset of the source/destination/passthroughDSet involved in Job 
</summary>
</member>
<member name="M:Prajna.Core.JobTraverseBase.TraverseAllObjectsWDirection(Prajna.Core.TraverseDirection,System.Collections.Generic.List{Prajna.Core.DistributedObject},Prajna.Core.DistributedObject,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.TraverseDirection,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.DistributedObject,Microsoft.FSharp.Core.Unit}})">
<summary>
 Traverse all job object, with a direction
</summary>
</member>
<member name="T:Prajna.Core.JobTraverseBase">
<summary>
 Put in traverse class here. 
</summary>
</member>
<member name="M:Prajna.Core.JobTraveseFromSource.TraverseOnce(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.DistributedObject,Microsoft.FSharp.Core.FSharpFunc{System.Boolean,Microsoft.FSharp.Core.Unit}})">
<summary>
 Examine the object in FutureExamine, 
 If the object has all information, place it in the Traversed list, otherwise, move it to FutureExamine
 For object that is placed onto the traversed list, add its downstream object to FutureExamine
</summary>
</member>
<member name="M:Prajna.Core.JobTraveseFromSource.Traverse(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.DistributedObject,Microsoft.FSharp.Core.FSharpFunc{System.Boolean,Microsoft.FSharp.Core.Unit}})">
<summary>
 Examine the object in FutureExamine, 
 If the object has all information, place it in the Traversed list, otherwise, move it to FutureExamine
 For object that is placed onto the traversed list, add its downstream object to FutureExamine
</summary>
</member>
<member name="M:Prajna.Core.JobTraveseFromSource.Status">
<summary>
 Monitor metadata resolution
</summary>
</member>
<member name="T:Prajna.Core.JobTraveseFromSource">
<summary>
 Traverse from source, to resolve any dependency issue
</summary>
</member>
<member name="T:Prajna.Core.JoinByMergeFunctionWrapper`1">
<summary>
 used for sortedJoin and joinBykey
</summary>
</member>
<member name="M:Prajna.Core.JoinByMergeFunctionWrapper`4.WrapperDerivedExecuteFunc(System.Int32,System.Int32)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="P:Prajna.Core.Listener.Callback">
<summary>
 Call back function during listening loop, 
 the function takes one parameter, Object,
 Return: 
     true: IO activity occurs during call back. 
     false: No IO activity occurs during call back. 
</summary>
</member>
<member name="M:Prajna.Core.Listener.RemoveConnectedQueue(Prajna.Core.NetworkCommandQueuePeer,Microsoft.FSharp.Core.Unit)">
 <summary>
 Disconnect of a peer 
 </summary> 
</member>
<member name="M:Prajna.Core.Listener.ParseCommandAtDaemon(Prajna.Core.NetworkCommandQueuePeer,Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Parse Command At Daemon
</summary>
</member>
<member name="M:Prajna.Core.Listener.Error(Prajna.Core.NetworkCommandQueue,System.String)">
<summary>
 Error: error in parsing 
</summary>
</member>
<member name="T:Prajna.Core.Listener">
<summary>
 Listener will be run by PrajnaClient to parse input command
</summary>
</member>
<member name="F:Prajna.Core.LoadBalanceAlgorithm.Default">
<summary>
 Default load balancing algorithm 
</summary>
</member>
<member name="F:Prajna.Core.LoadBalanceAlgorithm.CHR">
<summary>
 Consistent hash ring
</summary>
</member>
<member name="F:Prajna.Core.LoadBalanceAlgorithm.CHT2">
<summary>
 A second implementation of consistent hash table 
</summary>
</member>
<member name="F:Prajna.Core.LoadBalanceAlgorithm.CHT">
<summary>
 Consistent Hash Table 
</summary>
</member>
<member name="F:Prajna.Core.LoadBalanceAlgorithm.RoundRobin2">
<summary>
 A second RoundRobin algorithm 
</summary>
</member>
<member name="F:Prajna.Core.LoadBalanceAlgorithm.RoundRobin">
<summary>
 RoundRobin
</summary>
</member>
<member name="T:Prajna.Core.LoadBalanceAlgorithm">
<summary>
 Enumeration class of constant of type of Load balancing algorithm supported 
</summary>
</member>
<member name="M:Prajna.Core.LoadBlanceAlg.NormalizeResource(System.Int32[])">
<summary>
 NormalizeResource: Internal function, convert resource to a set of normalized resource (1..n) for resource allocation purpose. 
 Mapping:
 We want the base to be as large as possible to reduce the number of bins needed in resource reallocation. 
</summary>
</member>
<member name="M:Prajna.Core.LoadBlanceAlg.NormalizeResource(System.Int32[],System.Int32,System.Int32)">
<summary>
 NormalizeResource: convert resource to a set of normalized resource (1..n) for resource allocation purpose. 
 Mapping:
 Any resource &lt;=0 -&gt; 0
 Any resource r &gt;0 -&gt; round( r / base_resource) with cap
 We want the base to be as large as possible to reduce the number of bins needed in resource reallocation. 
</summary>
</member>
<member name="F:Prajna.Core.LocalCluster.ClusterInfo@">
<summary>
 Get the cluster information
</summary>
</member>
<member name="P:Prajna.Core.LocalCluster.ClusterInfo">
<summary>
 Get the cluster information
</summary>
</member>
<member name="M:Prajna.Core.LocalCluster.Start">
<summary>
 Start the cluster that each client is launched via a process using specified client
</summary>
</member>
<member name="M:Prajna.Core.LocalCluster.InternalStop">
<summary>
 Actual Shutdown the cluster by terminating all clients
 Externally, if need to shutdown the cluser, you should call stopObject.CleanUpThisOnly, or dispose the x object. 
</summary>
</member>
<member name="T:Prajna.Core.LocalCluster">
<summary>
 Represents a local cluster that all clients are started on the same machine
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.PortsRange">
<summary>
 The inclusive range of ports that the local cluster can use. It has to at least provide 
     NumClients + NumJobPortsPerClient * NumClients
 ports
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.NumJobPortsPerClient">
<summary>
 Number of job ports for each client
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.ClientPath">
<summary>
 The path to the PrajnaClient executable. If given, the client is started as a process, otherwise, as an AppDomain
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.ContainerInAppDomain">
<summary>
 Start the container in AppDomain? If false, start the container as a process
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.NumClients">
<summary>
 Number of clients 
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.Version">
<summary>
 The version of the local cluster
</summary>
</member>
<member name="P:Prajna.Core.LocalClusterConfig.Name">
<summary>
 The name of the local cluster
</summary>
</member>
<member name="T:Prajna.Core.LocalClusterConfig">
<summary>
 The configuration for a local cluster
</summary>
</member>
<member name="T:Prajna.Core.LocalClusterContainerMode">
<summary>
 Mode for starting a container for a local cluster
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.SerializationLimit@">
<summary>
 Serialization Change Listner, any derived function that wants to be notified if serialization limits changes?
 Serialization Limit will be used by some function so it is exposed here. 
 This will be automatically updated. 
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.GetPartitionsForElem@">
<summary>
 Function used at PrajnaClient, 
 Get partitions assignment for a array of key object and value object, 
 GetPartitionsForElem( numElems, keyArray, valueArray, numPartitions )
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.ExecuteFunc@">
<summary>
 Execute 
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.DepositFunc@">
<summary>
　Deposit from a parent DSet 
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.MapFunc@">
<summary>
 Map Function, signature: meta, Object -&gt; seq&lt;meta, Object&gt;
 when Object is null, this signals the end of the partition. The null should be passed down the pipe to signal the end of the stream. 
 It is important that if the intermediate app returns a null Object, it does not call the downstreaming app, as this signals the end of the stream
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.Encode@">
<summary>
 Encode a stream to downstream, with meta, Object as input, and meta, msStream as output
</summary>
</member>
<member name="F:Prajna.Core.MetaFunction.Decode@">
<summary>
 Decode a stream from upstream, with meta, MemStream as input, and meta, Object as output
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.SerializationLimit(System.Int32)">
<summary>
 Serialization Change Listner, any derived function that wants to be notified if serialization limits changes?
 Serialization Limit will be used by some function so it is exposed here. 
 This will be automatically updated. 
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.MapFunc(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind},System.Collections.Generic.IEnumerable{System.Tuple{Prajna.Core.BlobMetadata,System.Object}}})">
<summary>
 Map Function, signature: meta, Object -&gt; seq&lt;meta, Object&gt;
 when Object is null, this signals the end of the partition. The null should be passed down the pipe to signal the end of the stream. 
 It is important that if the intermediate app returns a null Object, it does not call the downstreaming app, as this signals the end of the stream
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.GetPartitionsForElem(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object,System.Int32},System.Int32[]})">
<summary>
 Function used at PrajnaClient, 
 Get partitions assignment for a array of key object and value object, 
 GetPartitionsForElem( numElems, keyArray, valueArray, numPartitions )
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.ExecuteFunc(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{Prajna.Core.BlobMetadata,System.Object}}})">
<summary>
 Execute 
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.Encode(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object},System.Tuple{Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte}}})">
<summary>
 Encode a stream to downstream, with meta, Object as input, and meta, msStream as output
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.DepositFunc(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,System.Object},Microsoft.FSharp.Core.Unit}})">
<summary>
　Deposit from a parent DSet 
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.Decode(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte}},System.Tuple{Prajna.Core.BlobMetadata,System.Object}})">
<summary>
 Decode a stream from upstream, with meta, MemStream as input, and meta, Object as output
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.SerializationLimit">
<summary>
 Serialization Change Listner, any derived function that wants to be notified if serialization limits changes?
 Serialization Limit will be used by some function so it is exposed here. 
 This will be automatically updated. 
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.MapFunc">
<summary>
 Map Function, signature: meta, Object -&gt; seq&lt;meta, Object&gt;
 when Object is null, this signals the end of the partition. The null should be passed down the pipe to signal the end of the stream. 
 It is important that if the intermediate app returns a null Object, it does not call the downstreaming app, as this signals the end of the stream
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.GetPartitionsForElem">
<summary>
 Function used at PrajnaClient, 
 Get partitions assignment for a array of key object and value object, 
 GetPartitionsForElem( numElems, keyArray, valueArray, numPartitions )
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.ExecuteFunc">
<summary>
 Execute 
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.Encode">
<summary>
 Encode a stream to downstream, with meta, Object as input, and meta, msStream as output
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.DepositFunc">
<summary>
　Deposit from a parent DSet 
</summary>
</member>
<member name="P:Prajna.Core.MetaFunction.Decode">
<summary>
 Decode a stream from upstream, with meta, MemStream as input, and meta, Object as output
</summary>
</member>
<member name="M:Prajna.Core.MetaFunction.RandomPartition(Prajna.Core.BlobMetadata,System.Object,System.Int32)">
<summary>
 Default partition function, assign a random key, value to a partition. 
</summary>
</member>
<member name="T:Prajna.Core.MetaFunction">
<summary>
 Function that used in DSet.AsyncReadChunk
 input parameter is parti, serial, numElems, ms
 Output parameter is seq&lt;parti, serial, numElems, ms&gt;
</summary>
</member>
<member name="M:Prajna.Core.MetaFunction`1.DecodeFunc(Prajna.Core.BlobMetadata,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Input: metadata, MemStream
 Output: metadata, elemObject
 It is OK for value object to be null. However, a null KeyObject signals the end of the stream. 
</summary>
</member>
<member name="T:Prajna.Core.MetaFunction`1">
<summary>
 Function that used in DSet.AsyncReadChunk
 input parameter is parti, serial, numElems, ms
 Output parameter is parti, serial, numElems, ms
</summary>
</member>
<member name="M:Prajna.Core.MixFunctionWrapper`1.WrapperExecuteFunc(System.Int32)">
<summary>
 Wrapper Mapping Function, notice that when KeyArray or ValueArray is null, the UseFunc will not be called, but null will passed down as the end of stream symbols. 
 It is the calling function&apos;s responsibility to make sure that when x.UseFunc return null, the subsequent class is not called, as that will signal the termination 
 of the partition. 
</summary>
</member>
<member name="T:Prajna.Core.MixFunctionWrapper`1">
<summary>
 ----------------------------------------------------------------------------------------------------------------------------------------------
 Used for .mix and mixby 
 ----------------------------------------------------------------------------------------------------------------------------------------------
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommand.buildHeader@">
<summary>
 Get the length of the command on the wire
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommand.ms@">
<summary>
 The memory stream
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommand.cmd@">
<summary>
 The controller command
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommand.ms(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 The memory stream
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommand.cmd(Prajna.Core.ControllerCommand)">
<summary>
 The controller command
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommand.buildHeader(System.Boolean)">
<summary>
 Get the length of the command on the wire
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommand.ms">
<summary>
 The memory stream
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommand.cmd">
<summary>
 The controller command
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommand.buildHeader">
<summary>
 Get the length of the command on the wire
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommand.Release">
<summary>
 release the underlying memstream
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandCallback.Callback(Prajna.Core.ControllerCommand,System.Int32,Prajna.Tools.StreamBase{System.Byte},System.Guid,System.String,System.Int64,Prajna.Core.Cluster)">
<summary>
 Callback triggered by peer:
 calling parameter:
     Controller Command [V, N]
     Peeri
     Payload
</summary>
</member>
<member name="T:Prajna.Core.NetworkCommandCallback">
<summary>
 Can&apos;t add another function to call back without break the function. 
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.Performance@">
<summary>
 Performance of the network communication queue, only used in 
 Distributed function
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.PendingCommand@">
<summary>
 The pending command which has not yet been processed
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.LastMonitorPendingCommand@">
<summary>
 Last time pending command was monitored
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.MyExchangeRSA@">
<summary>
 A RSA Cryto service provider for key exchange
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.MyAuthRSA@">
<summary>
 A RSA Crypto service provider for authentication
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.MyGuid@">
<summary>
 GUID of this connection
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.RequireAuth@">
<summary>
 Whether authentication is required or not - if authentication required other side has AES key for sending encrypted messages here
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.Stopwatch@">
<summary>
 A stopwatch which starts when connection established
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.OnDisconnect@">
 <summary> 
 Listen to Disconnect event - use OnDisconnectAdd to add to this
 </summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.OnConnect@">
 <summary> 
 Listen to OnConnect event - use OnConnectAdd to add to this
 </summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueue.NumFailed@">
<summary>
 Number of time it fails.
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RequireAuth(System.Boolean)">
<summary>
 Whether authentication is required or not - if authentication required other side has AES key for sending encrypted messages here
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.PendingCommand(System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.Tuple{Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte}}},System.DateTime})">
<summary>
 The pending command which has not yet been processed
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.NumFailed(System.Int32)">
<summary>
 Number of time it fails.
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MyGuid(System.Guid)">
<summary>
 GUID of this connection
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MyExchangeRSA(System.Security.Cryptography.RSACryptoServiceProvider)">
<summary>
 A RSA Cryto service provider for key exchange
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MyAuthRSA(System.Security.Cryptography.RSACryptoServiceProvider)">
<summary>
 A RSA Crypto service provider for authentication
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MaxTokenSize(System.Int64)">
<summary>
 The maximum size of sending token bucket
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.LastMonitorPendingCommand(System.DateTime)">
<summary>
 Last time pending command was monitored
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.UnProcessedCmdInMB">
<summary>
 UnProcessedCmdInBytes in units of MB
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.UnProcessedCmdInBytes">
<summary>
 A count of unprocessed bytes (those which have not been acknowledged)
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.TotalBytesSent">
<summary>
 The total bytes sent by connection
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.TotalBytesRcvd">
<summary>
 The total bytes recieved by connection
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.Stopwatch">
<summary>
 A stopwatch which starts when connection established
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.Shutdown">
<summary>
 Tells if connection is capable of receiving more data
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.SendSpeed">
<summary>
 Current sending limit
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.SendQueueSize">
<summary>
 Length of sending queue of NetworkCommand in units of bytes
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.SendQueueLength">
<summary>
 Length of sending queue of SocketAsyncEventArgs in internal GenericConn
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.SendCommandQueueLength">
<summary>
 Length of sending queue of NetworkCommand
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RequireAuth">
<summary>
 Whether authentication is required or not - if authentication required other side has AES key for sending encrypted messages here
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RemoteEndPointSignature">
<summary>
 Int64 value of the RemoteEndPoint
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RemoteEndPoint">
<summary>
 The remote endpoint of the connection
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RecvQueueSize">
<summary>
 Length of receiving queue of SocketAsyncEventArgs in units of bytes in internal GenericConn
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.ReceivingQueueLength">
<summary>
 Length of receiving queue of SocketAsyncEventArgs in internal GenericConn
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.ReceivingCommandQueueLength">
<summary>
 Length of receiving queue of NetworkCommand
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RcvdSpeed">
<summary>
 Current speed limit on the receiving interface
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.RcvdCommandSerial">
<summary>
 The index of the last received command
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.Performance">
<summary>
 Performance of the network communication queue, only used in 
 Distributed function
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.PendingCommand">
<summary>
 The pending command which has not yet been processed
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.OnDisconnect">
 <summary> 
 Listen to Disconnect event - use OnDisconnectAdd to add to this
 </summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.OnConnect">
 <summary> 
 Listen to OnConnect event - use OnConnectAdd to add to this
 </summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.NumFailed">
<summary>
 Number of time it fails.
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MyGuid">
<summary>
 GUID of this connection
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MyExchangeRSA">
<summary>
 A RSA Cryto service provider for key exchange
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MyAuthRSA">
<summary>
 A RSA Crypto service provider for authentication
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.MaxTokenSize">
<summary>
 The maximum size of sending token bucket
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.LocalEndPoint">
<summary>
 The local endpoint of the connection
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.LastMonitorPendingCommand">
<summary>
 Last time pending command was monitored
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.Initialized">
<summary>
 Tells if event initialized has been set
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.HasFailed">
<summary>
 Tells if NetworkCommandQueue has failed
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.ConnectionStatus">
<summary>
 Connection Status
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.CompSend">
<summary>
 The internal sending component which processes NetworkCommand objects and converts them from NetworkCommand to SocketAsyncEventArgs
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.CompRecv">
<summary>
 The internal receiving component which processes NetworkCommand objects
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueue.CanSend">
<summary>
 Tells if we are we allowed to send
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.ToSendFromPos``1(Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte},System.Int64,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Add command to sender queue - enqueue takes place synchronously, blocks caller
 &lt;param name=&quot;command&quot;&gt;The ControllerCommand to send&lt;/param&gt;
 &lt;param name=&quot;sendStream&quot;&gt;The associated MemStream to send&lt;/param&gt;
 &lt;param name=&quot;startPos&quot;&gt;Start sending from this position&lt;/param&gt;
 &lt;param name=&quot;bExpediateSend&quot;&gt;Optional - Unused parameter&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.ToSendEncrypt(Prajna.Core.ControllerCommand,System.Byte[],System.Int32,System.Int32)">
<summary>
 Add command to sender queue using encryption - decryption takes place automatically
 enqueue takes place synchronously, blocks caller
 &lt;param name=&quot;command&quot;&gt;The ControllerCommand to send&lt;/param&gt;
 &lt;param name=&quot;arr&quot;&gt;The associated buffer to send&lt;/param&gt;
 &lt;param name=&quot;offset&quot;&gt;The offset into the buffer to send&lt;/param&gt;
 &lt;param name=&quot;arrCount&quot;&gt;The length of content in buffer to send (starting at offset)&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.ToSend``1(Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Add command to sender queue - enqueue takes place synchronously, blocks caller
 &lt;param name=&quot;command&quot;&gt;The ControllerCommand to send&lt;/param&gt;
 &lt;param name=&quot;sendStream&quot;&gt;The associated MemStream to send&lt;/param&gt;
 &lt;param name=&quot;bExpediateSend&quot;&gt;Optional - Unused parameter&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.ToForward(System.Net.IPEndPoint[],Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Wrap the Memstream to forward to multiple endPoints during the communication. 
 &lt;param name=&quot;endPoints&quot;&gt;The endpoints to forward to&lt;/param&gt;
 &lt;param name=&quot;command&quot;&gt;The controller command&lt;/param&gt;
 &lt;param name=&quot;sendStream&quot;&gt;The associated MemStream to send&lt;/param&gt;
 &lt;param name=&quot;bExpediateSend&quot;&gt;Optional argument - unused for now&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.ToForward(System.Net.IPEndPoint,Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Wrap the Memstream to forward to 1 endPoint during the communication. 
 &lt;param name=&quot;endPoint&quot;&gt;The endpoint to forward to&lt;/param&gt;
 &lt;param name=&quot;command&quot;&gt;The controller command&lt;/param&gt;
 &lt;param name=&quot;sendStream&quot;&gt;The associated MemStream to send&lt;/param&gt;
 &lt;param name=&quot;bExpediateSend&quot;&gt;Optional argument - unused for now&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.Terminate">
 <summary> 
 Terminate network queue, all pending actions are discarded. 
 </summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.SetSendSpeed(System.Int64)">
<summary>
 Set the sending speed for this connection
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.SetRcvdSpeed(System.Int64)">
<summary>
 Set the receiving speed for this connection
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.QueueFail(Prajna.Core.NetworkCommandQueue)">
<summary>
 Tells if queue is null or has failed
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.MonitorRcvd">
<summary>
 Monitor the connection
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.MarkFail">
<summary>
 Mark the connection as having failed and terminate
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.Initialize">
<summary>
 Initialize the NetworkCommandQueue - Only call after AddRecvProc are all done
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.GetPendingCommandEventIfNeeded">
<summary>
 Get Event for pending command if there is one, else null
 &lt;returns&gt;The event to wait for, or null if a wait is not required.&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.GetOrAddRecvProc(System.String,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommand,System.Threading.ManualResetEvent})">
<summary>
 Add receiver processing - multiple processeros may be added
 &lt;param name=&quot;processItem&quot;&gt;The function to process NetworkCommand objects from queue&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.Close">
 <summary>
 Normal close of socket/queue, 
 </summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.BeginConnect(System.Net.IPAddress,System.Int32)">
<summary>
 Begin connection to IP address
 &lt;param name=&quot;addr&quot;&gt;The IPAddress to connect to&lt;/param&gt;
 &lt;param name=&quot;port&quot;&gt;The port to connect to&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.AddSystemwideRecvProcessor(System.String,Prajna.Core.NetworkCommandQueueType,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommandQueue,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommand,System.Threading.ManualResetEvent}})">
<summary>
 Add a systemwide recv processor that will be registered to every queue. 
 This function should be executed before queue is active to ensure that message are properly processed. 
 name is used to identify the recv process, mainly for debug purpose
 ty is Loopback, Incoming, Outgoing, AnyDirection: indicate what type of connection that the recv process will be added to
 procItem is a recv process that will be executed on each package with signature NetworkCommandQueue-&gt;NetworkCommand-&gt;ManualResetEvent
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.AddSystemwideDisconnectProcessor(System.String,Prajna.Core.NetworkCommandQueueType,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommandQueue,Microsoft.FSharp.Core.Unit})">
<summary>
 Add a systemwide disconnect processor that will be registered to every queue 
 name is used to identify the disonnect process, mainly for debug purpose
 ty is Loopback, Incoming, Outgoing, AnyDirection: indicate what type of connection that the disconnect process will be added to
 procDisconnect is a disconnect process that will be executed when a socket closes with signature NetworkCommandQueue-&gt;unit
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.AddRecvProc(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommand,System.Threading.ManualResetEvent})">
<summary>
 Add receiver processing - multiple processeros may be added
 &lt;param name=&quot;processItem&quot;&gt;The function to process NetworkCommand objects from queue&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.#ctor(System.Net.IPAddress,System.Int32,Prajna.Core.NetworkConnections)">
<summary>
 3. Constructor when connecting to machine with address/port (w/o DNS resolve)
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.#ctor(System.String,System.Int32,Prajna.Core.NetworkConnections)">
<summary>
 2. Constructor when connecting to machine with name/port (with DNS resolve)
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueue.#ctor(System.Net.Sockets.Socket,Prajna.Core.NetworkConnections)">
<summary>
 1. Constructor used when accepting a new connection
</summary>
</member>
<member name="T:Prajna.Core.NetworkCommandQueue">
<summary>
 An extension to GenericConn to process NetworkCommand
 GenericConn is an internal object which contains Send/Recv Components to process SocketAsyncEventArgs objects
 NetworkCommandQueue contains Send/Recv Components to process NetworkCommand objects
 The general pipeline looks like following
 For Recv:
 Network -&gt; GenericConn (ProcessRecvGenericConn) -&gt; NetworkCommandQueue (function from AddRecvProc) -&gt; Application
 RecvAsync-&gt;queue        CompRecv of GenericConn                       CompRecv of NetworkCommandQueue
                         SocketAsyncEventArgs-&gt;NetworkCommand           NetworkCommand-&gt;application
                         To Queue of NetworkCommandQueue
 For Send:
 Network &lt;- (SendAsync)          GenericConn     &lt;- (ProcessSendGenericConn) NetworkCommandQueue    &lt;- Application
            CompSend of GenericConn                 CompSend of NetworkCommandQueue
            network&lt;-SocketAsyncEventArgs           SocketAsyncEventArgs&lt;-NetworkCommand
                                                    Application writes to NetworkCommand queue using ToSend
</summary>
</member>
<member name="F:Prajna.Core.NetworkCommandQueueLifeCycle.RegisterOnConnect@">
<summary>
 Upon connect, do something for the queue
</summary>
</member>
<member name="P:Prajna.Core.NetworkCommandQueueLifeCycle.RegisterOnConnect">
<summary>
 Upon connect, do something for the queue
</summary>
</member>
<member name="T:Prajna.Core.NetworkCommandQueueLifeCycle">
<summary>
 NetworkCommandQueueLifeCycle contains function that should be called whenever 
 a connection is connected or disconnected. 
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueuePeer.UpdateDSet(System.Guid,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Update DSet meta data, when the peer finished writing. 
</summary>
</member>
<member name="M:Prajna.Core.NetworkCommandQueuePeer.SetDSet(Prajna.Core.JobLifeCycle,Microsoft.FSharp.Core.FSharpOption{Prajna.Tools.StreamBase{System.Byte}})">
<summary>
 Write DSet Metadata to disk
</summary>
</member>
<member name="T:Prajna.Core.NetworkCommandQueuePeer">
<summary>
 A Prajna CommandQueue that is resulted from accept() 
</summary>
</member>
<member name="T:Prajna.Core.NetworkCommandQueueType">
<summary>
 Discriminative union that identifies the type of connection
</summary>
</member>
<member name="F:Prajna.Core.NetworkConnections.ChannelMonitorInterval@">
<summary>
 Interval in seconds to monitor channel connectivity (in Ms)
</summary>
</member>
<member name="F:Prajna.Core.NetworkConnections.ChannelMonitorLevel@">
<summary>
 Channel monitor levels 
</summary>
</member>
<member name="F:Prajna.Core.NetworkConnections.MaxChannelsToMonitor@">
<summary>
 Maximum Number of Channels to monitor 
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.MaxChannelsToMonitor(System.Int32)">
<summary>
 Maximum Number of Channels to monitor 
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.ChannelMonitorLevel(Prajna.Tools.LogLevel)">
<summary>
 Channel monitor levels 
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.ChannelMonitorInterval(System.Int32)">
<summary>
 Interval in seconds to monitor channel connectivity (in Ms)
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.MaxChannelsToMonitor">
<summary>
 Maximum Number of Channels to monitor 
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.Current">
<summary>
 The current NetworkConnections - only one instantiation exists
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.ChannelsCollection">
<summary>
 Get the current channel collection
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.ChannelMonitorLevel">
<summary>
 Channel monitor levels 
</summary>
</member>
<member name="P:Prajna.Core.NetworkConnections.ChannelMonitorInterval">
<summary>
 Interval in seconds to monitor channel connectivity (in Ms)
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.RemoveConnect(Prajna.Core.NetworkCommandQueue)">
<summary>
 Remove a channel from collection
 &lt;param name=&quot;channel&quot;&gt;The channel to remove&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.ObtainKeyInfoFromFiles(System.String)">
<summary>
 Obtain key information for security (authentication / encryption) from files and load in memory
 &lt;param name=&quot;keyfile&quot;&gt;
 The base key file, other guids are obtained from other files in same directory
 Own key information is stored in a file with the name &quot;keyfile_mykey.txt&quot; which has following format
 - 16 byte GUID
 - Length of authentication key blob (4 bytes)
 - A private key blob which has been encrypted and contains information to initialize RSA
 - Length of encryption key blob (4 bytes)
 - A private key blob which has been encrypted and contains information to initialize RSA
 Other key information is stored in files &quot;keyfile_&lt;GUID&gt;.txt&quot; where &lt;GUID&gt; is guid of connection and has following format
 - 16 byte GUID
 - Key blob (unencrypted) with length containing authentication public key
 - Key blob (unencrypted) with length containing encryption public key
 &lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.MonitorChannels(System.Collections.Generic.IEnumerable{Prajna.Core.NetworkCommandQueue})">
<summary>
 Monitor information
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.LookforConnectBySignature(System.Int64)">
<summary>
 Search for connection in collection by signature
 &lt;param name=&quot;signature&quot;&gt;The signature of the endpoint to search for&lt;/param&gt;
 &lt;returns&gt;The channel if found, else null&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.LookforConnect(System.Net.IPEndPoint)">
<summary>
 Search for connection in collection by endpoint
 &lt;param name=&quot;endPoint&quot;&gt;The endpoint to search for&lt;/param&gt;
 &lt;returns&gt;The channel if found, else null&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.InitializeAuthentication(System.Byte[],System.String)">
<summary>
 Initialize authentication / security information from key information obtained in buffer
 &lt;param name=&quot;keyInfo&gt;
 The key information blob as a byte array
 The blob consists of:
 Own key information with following format
 - 16 byte GUID
 - Length of authentication key blob (4 bytes)
 - A private key blob which has been encrypted and contains information to initialize RSA
 - Length of encryption key blob (4 bytes)
 - A private key blob which has been encrypted and contains information to initialize RSA
 Key information for allowed connections in following format - can be multiple of these
 - 16 byte GUID
 - Key blob (unencrypted) with length containing authentication public key
 - Key blob (unencrypted) with length containing encryption public key
 &lt;/param&gt;
 &lt;param name=&quot;keyfilepwd&quot;&gt;The password used to decrypt the encrypted private key information&lt;/param&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.InitializeAuthentication(System.String,System.String,System.String)">
<summary>
 Initialize authentication / security information from keyfile (encrypted with keyfilePwd)
 while also allowing for shared secret (password) to be used for authentication.
 &lt;param name=&quot;pwd&quot;&gt;A shared secret password which can be used for authentication&lt;/param&gt;
 &lt;param name=&quot;keyfile&quot;&gt;
 The base key file, other guids are obtained from other files in same directory
 Own key information is stored in a file with the name &quot;keyfile_mykey.txt&quot; which has following format
 - 16 byte GUID
 - Length of authentication key blob (4 bytes)
 - A private key blob which has been encrypted and contains information to initialize RSA
 - Length of encryption key blob (4 bytes)
 - A private key blob which has been encrypted and contains information to initialize RSA
 Other key information is stored in files &quot;keyfile_&lt;GUID&gt;.txt&quot; where &lt;GUID&gt; is guid of connection and has following format
 - 16 byte GUID
 - Key blob (unencrypted) with length containing authentication public key
 - Key blob (unencrypted) with length containing encryption public key
 &lt;/param&gt;
 &lt;param name=&quot;keyfilepwd&quot;&gt;The password used to decrypt the encrypted private key information&lt;/param&gt; 
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.InitializeAuthentication(System.String)">
<summary>
 Initialize authentication using a shared secret password 
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.Initialize">
<summary>
 Initialize the object
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.GetOutgoingChannels">
<summary>
 Get all outgoing channels
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.GetLoopbackChannels">
<summary>
 Get all loopback channels
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.GetAuthParam">
<summary>
 Get the authentication parameters
 &lt;returns&gt;
 The authentication parameters as (RequireAuth, MyGUID, PrivateKey, KeyFilePassword)
 RequireAuth - whether authentication is currently required
 MyGUID - my own GUID
 PrivateKey - my own private key
 KeyFilePassword - password for the key file
 &lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.GetAllChannelsOfType(Prajna.Core.NetworkCommandQueueType)">
<summary>
 Get all loopback channels 
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.GetAllChannels">
<summary>
 Get all channels in the collection as a sequence
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.Close">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.CheckForAllowedConnection(System.Guid)">
<summary>
 Check for allowed connections
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.AddToCollection(Prajna.Core.NetworkCommandQueue)">
<summary>
 Add a channel to collection - this is only needed in case a class inherits NetworkCommandQueue 
 &lt;param name=&quot;newChannel&quot;&gt;The channel to add to collection&lt;/param&gt;
 &lt;returns&gt;The channel in collection&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.AddToAllowedConnection(System.Guid,System.Byte[],System.Byte[])">
<summary>
 Add to allowed connection list by adding to file and concurrent dictionary
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.AddLoopbackConnect(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Guid},Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Byte[],System.Byte[]}},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Add a loopback connection to specified port, with optional security parameters specified
 &lt;param name=&quot;port&quot;&gt;The port for loopback connection to connect to&lt;/param&gt;
 &lt;param name=&quot;requireAuth&quot;&gt;Optional - specifies if authentication required&lt;/param&gt;
 &lt;param name=&quot;guid&quot;&gt;Optional - own GUID for loopback&lt;/param&gt;
 &lt;param name=&quot;rsaParam&quot;&gt;Optional - byte array for RSA information blob&lt;/param&gt;
 &lt;param name=&quot;pwd&quot;&gt;Optional - password for decrypting RSA information blob&lt;/param&gt;
 &lt;returns&gt;The NetworkCommandQueue for the channel being added&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.AddConnect(System.Net.IPAddress,System.Int32)">
<summary>
 Given a IP address and port, create socket and connect, then create a NetworkCommandQueue and add it to collection
 &lt;param name=&quot;addr&quot;&gt;The IP address to connect to&lt;/param&gt;
 &lt;param name=&quot;port&quot;&gt;The port to connect to&lt;/param&gt;
 &lt;returns&gt;The NetworkCommandQueue created from the socket&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.AddConnect(System.String,System.Int32)">
<summary>
 Given a machine name and port, create socket and connect, then create a NetworkCommandQueue and add it to collection
 &lt;param name=&quot;machineName&quot;&gt;The machine to connect to&lt;/param&gt;
 &lt;param name=&quot;port&quot;&gt;The port to connect to&lt;/param&gt;
 &lt;returns&gt;The NetworkCommandQueue created from the socket&lt;/returns&gt;
</summary>
</member>
<member name="M:Prajna.Core.NetworkConnections.AddConnect(System.Net.Sockets.Socket)">
<summary>
 Given a socket, create a NetworkCommandQueue and add it to collection
 &lt;param name=&quot;socket&quot;&gt;The socket from which to create NetworkCommandQueue&lt;/param&gt;
 &lt;returns&gt;The NetworkCommandQueue created from the socket&lt;/returns&gt;
</summary>
</member>
<member name="T:Prajna.Core.NetworkConnections">
<summary>
 A set of NetworkCommandQueue that are established via the Connect call
 Each connect is reference counted, so that the connect will shutdown when the reference reaches 0
</summary>
</member>
<member name="M:Prajna.Core.NetworkCorssBarAtDaemon.RemoveEntry(System.Int64)">
<summary>
 Network sig1 disconnects
</summary>
</member>
<member name="M:Prajna.Core.NetworkCorssBarAtDaemon.GetMappedEntry(System.Int64)">
<summary>
 Get all entry maps with sig1
</summary>
</member>
<member name="M:Prajna.Core.NetworkCorssBarAtDaemon.AddEntry(System.Int64,System.Int64)">
<summary>
 Network sig1 connects to network sig2
</summary>
</member>
<member name="T:Prajna.Core.NetworkCorssBarAtDaemon">
<summary>
 Network Crossbar at daemon maintains information of 
 which queue of client maps to queues of container, 
 and whch queue of container maps to queues of client
</summary>
</member>
<member name="F:Prajna.Core.NetworkPerformance.LastSendTicks@">
<summary>
 Last ticks that the content is sent from this queue
</summary>
</member>
<member name="F:Prajna.Core.NetworkPerformance.LastRtt@">
<summary>
 Last RTT from the remote node. 
</summary>
</member>
<member name="F:Prajna.Core.NetworkPerformance.RttCount@">
<summary>
 Filter out 1st RTT value, as it contains initialization cost, which is not part of network RTT
</summary>
</member>
<member name="F:Prajna.Core.NetworkPerformance.RTTFilterThreshold@">
<summary>
 Threshold above which the RTT value is deemed unreliable, and will not be used
</summary>
</member>
<member name="F:Prajna.Core.NetworkPerformance.RTTSamples@">
<summary>
 Number of Rtt samples to statistics
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.RTTSamples(System.Int32)">
<summary>
 Number of Rtt samples to statistics
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.RTTFilterThreshold(System.Double)">
<summary>
 Threshold above which the RTT value is deemed unreliable, and will not be used
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.LastSendTicks(System.DateTime)">
<summary>
 Last ticks that the content is sent from this queue
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.LastRtt(System.Double)">
<summary>
 Last RTT from the remote node. 
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.StartTime">
<summary>
 The ticks that the connection is initialized. 
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.RttCount">
<summary>
 Filter out 1st RTT value, as it contains initialization cost, which is not part of network RTT
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.RTTSamples">
<summary>
 Number of Rtt samples to statistics
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.RTTFilterThreshold">
<summary>
 Threshold above which the RTT value is deemed unreliable, and will not be used
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.LastSendTicks">
<summary>
 Last ticks that the content is sent from this queue
</summary>
</member>
<member name="P:Prajna.Core.NetworkPerformance.LastRtt">
<summary>
 Last RTT from the remote node. 
</summary>
</member>
<member name="M:Prajna.Core.NetworkPerformance.WriteHeader(System.IO.Stream)">
<summary>
 Wrap header for RTT estimation 
</summary>
</member>
<member name="M:Prajna.Core.NetworkPerformance.WriteEndMark(System.IO.Stream)">
<summary>
 Write end marker 
</summary>
</member>
<member name="M:Prajna.Core.NetworkPerformance.ReadHeader(System.IO.Stream)">
<summary>
 Validate header for RTT estimation 
</summary>
</member>
<member name="M:Prajna.Core.NetworkPerformance.ReadEndMark(System.IO.Stream)">
<summary>
 Validate end marker
</summary>
</member>
<member name="M:Prajna.Core.NetworkPerformance.GetRtt">
<summary>
 Get the RTT of the connection
</summary>
</member>
<member name="M:Prajna.Core.NetworkPerformance.ConnectionReady">
<summary>
 Whether connection receives some valid data
</summary>
</member>
<member name="T:Prajna.Core.NetworkPerformance">
<summary>
 Statistics of network performance
 Used by distributed functions
</summary>
</member>
<member name="M:Prajna.Core.NetworkSocket.GetTCPClient(System.String,System.Int32)">
<summary>
 This function is used to replace new TcpClient(name, port) 
 to use IPv4 address, hopefully to speed up things. 
</summary>
</member>
<member name="M:Prajna.Core.NodeConnectionFactory.Evict(System.Int32)">
<summary>
 First time to  connect to a machine port
 If not first connect, at least wait for the queue to be created. 
</summary>
</member>
<member name="F:Prajna.Core.NodeConnectionInfo.RecvProc@">
<summary>
 RecvProc
</summary>
</member>
<member name="F:Prajna.Core.NodeConnectionInfo.TimerToReonnect@">
<summary>
 Timer 
</summary>
</member>
<member name="P:Prajna.Core.NodeConnectionInfo.TimerToReonnect(Prajna.Tools.ThreadPoolTimer)">
<summary>
 Timer 
</summary>
</member>
<member name="P:Prajna.Core.NodeConnectionInfo.RecvProc(Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommandQueue,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.NetworkCommand,System.Threading.ManualResetEvent}})">
<summary>
 RecvProc
</summary>
</member>
<member name="P:Prajna.Core.NodeConnectionInfo.TimerToReonnect">
<summary>
 Timer 
</summary>
</member>
<member name="P:Prajna.Core.NodeConnectionInfo.RecvProc">
<summary>
 RecvProc
</summary>
</member>
<member name="M:Prajna.Core.NodeConnectionInfo.System-IDisposable-Dispose">
<summary>
 Timestamp refresh. 
 Mark Store as disconnected
</summary>
</member>
<member name="M:Prajna.Core.NodeConnectionInfo.DaemonReconnect">
<summary>
 Mark Store as disconnected
</summary>
</member>
<member name="F:Prajna.Core.NodeWithInJobInfo.ConstructFunc@">
<summary>
 For other Node type, please extend this Construction Function
</summary>
</member>
<member name="P:Prajna.Core.NodeWithInJobInfo.ConstructFunc(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Core.NodeWithInJobType,Prajna.Tools.StreamBase{System.Byte}},Prajna.Core.NodeWithInJobInfo})">
<summary>
 For other Node type, please extend this Construction Function
</summary>
</member>
<member name="P:Prajna.Core.NodeWithInJobInfo.ConstructFunc">
<summary>
 For other Node type, please extend this Construction Function
</summary>
</member>
<member name="T:Prajna.Core.NodeWithInJobInfo">
<summary>
 Store information related to the current node for the job
 This may have specific job related information, e.g., TCP port, RDMA information related to the job. 
</summary>
</member>
<member name="T:Prajna.Core.OnAcceptAction">
<summary>
 Delegate that is called when some one connects in 
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping.UseMapping">
<summary>
 Use a particular partition mapping matrix. 
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping.AggregateParents">
<summary>
 Aggregate the partition mapping of multiple parents to form the partition mapping of the current DSet
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping.UseParent">
<summary>
 Use partition mapping of a dependent obect 
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping.FullMapping">
<summary>
 Each partition is available on any node of the cluster. 
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping.GenerateMapping">
<summary>
 The class should support a function to generate the partition mapping 
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping.UndefinedMapping">
<summary>
 Error 
</summary>
</member>
<member name="T:Prajna.Core.ParentMapping">
<summary>
 Enumeration class that determines how to derive partition mapping for DSet/DStream
</summary>
</member>
<member name="T:Prajna.Core.PartitionCacheBase">
<summary>
 Cache Structure used to cache a partition of Prajna
</summary>
</member>
<member name="T:Prajna.Core.PartitionCacheEnumerable`1">
<summary>
 Cache Structure used to cache a partition of Prajna
</summary>
</member>
<member name="T:Prajna.Core.PartitionCacheKeyValueStore`2">
<summary>
 Cache Structure used to cache a partition of Prajna
 The ConcurrentDictionary carries a penalty compared with ConcurrentQueue, 
 It takes almost 2x to enqueue (even considering processing time), and about 3x to Enumerate, can&apos;t figureout why. 
</summary>
</member>
<member name="T:Prajna.Core.PartitionCacheList`1">
<summary>
 Cache Structure used to cache a partition of Prajna
 This one uses List&lt;_&gt;, we find that it is not observably faster than a ConcurrentQueue, and since ConcurrentQueue has better property, it is used as default. 
</summary>
</member>
<member name="T:Prajna.Core.PartitionCacheQueue`1">
<summary>
 Cache Structure used to cache a partition of Prajna
</summary>
</member>
<member name="M:Prajna.Core.RemoteConfig.GetRemoteStorageInfo(Prajna.Core.Cluster)">
<summary>
 Get the remote storage information of the cluster
</summary>
</member>
<member name="M:Prajna.Core.RemoteConfig.GetDriveSpace(System.String)">
<summary>
 Get remote drive information synchronously. 
</summary>
</member>
<member name="M:Prajna.Core.RemoteConfig.AsyncGetDriveSpace(System.String)">
<summary>
 This somehow doesn&apos;t work, though the synchronous version works. 
</summary>
</member>
<member name="P:Prajna.Core.RemoteContainer.DefaultJobListener">
<summary>
 Get the Listener used by the current container 
</summary>
</member>
<member name="T:Prajna.Core.RemoteContainer">
<summary>
 Access state of RemoteContainer 
</summary>
</member>
<member name="F:Prajna.Core.RemoteExecutionEnvironment.ContainerName@">
<summary>
 Obtain the remote container name that the Prajna program is executed upon. 
</summary>
</member>
<member name="P:Prajna.Core.RemoteExecutionEnvironment.ContainerName(System.String)">
<summary>
 Obtain the remote container name that the Prajna program is executed upon. 
</summary>
</member>
<member name="P:Prajna.Core.RemoteExecutionEnvironment.MachineName">
 <summary> Obtain the MachineName that the Prajna Program is executed upon. </summary>
</member>
<member name="P:Prajna.Core.RemoteExecutionEnvironment.ContainerName">
<summary>
 Obtain the remote container name that the Prajna program is executed upon. 
</summary>
</member>
<member name="M:Prajna.Core.RemoteExecutionEnvironment.IsDaemon">
<summary>
 Is the current execution environment a daemon?
 We don&apos;t expect user code in daemon outside of the Core
</summary>
</member>
<member name="M:Prajna.Core.RemoteExecutionEnvironment.IsContainer">
<summary>
 Is the current execution environment a remote container
</summary>
</member>
<member name="M:Prajna.Core.RemoteExecutionEnvironment.IsClient">
<summary>
 Is the current execution environment a client?
</summary>
</member>
<member name="M:Prajna.Core.RemoteExecutionEnvironment.GetServiceFolder">
<summary>
 Obtain the folder of the service store
</summary>
</member>
<member name="M:Prajna.Core.RemoteExecutionEnvironment.GetLogFolder">
<summary>
 Obtain the log folder that is used by Prajna
</summary>
</member>
<member name="T:Prajna.Core.RemoteExecutionEnvironment">
 <summary> Parameters related to Prajna remote running environment </summary>
</member>
<member name="T:Prajna.Core.RoundRobin">
<summary>
 Load balancing by round robin assignment
</summary>
</member>
<member name="T:Prajna.Core.SingleJobActionApp">
<summary>
 Allow a segment of the program to hold a particular instance of a JobLifeCycle object, usually used when an executed job uses JobLifeCycle
 When an action is in process, cancellation of jobLifeCycle will be delayed until this action completes. 
 It will be disposed at the end of the action so that jobLifeCycle can be cancelled. 
 Please always use:
 using () ( fun _ -&gt; _) when programming with the SingleJobActionGeneric object so that we can make sure that jobLifeCycle properly terminates 
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionContainer.ToSend(Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Forward/Send a message
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionContainer.ThrowExceptionAtContainer(System.String)">
<summary>
 Create a System.Runtime.Remoting.RemotingException, cancel this job using this exception
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionContainer.ErrorAtContainer(System.String)">
<summary>
 Create a System.Runtime.Remoting.RemotingException, cancel this job using this exception
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionContainer.EncounterExceptionAtContainer(System.Exception,System.String)">
<summary>
 Runtime at container encounter an exception, cancel this job using this exception with location information 
</summary>
</member>
<member name="T:Prajna.Core.SingleJobActionContainer">
<summary>
 Allow a segment of the program to hold a particular instance of a JobLifeCycle object, usually used when an executed job at a remote execution container
 When an action is in process, cancellation of jobLifeCycle will be delayed until this action completes. 
 It will be disposed at the end of the action so that jobLifeCycle can be cancelled. 
 Please always use:
 using () ( fun _ -&gt; _) when programming with the SingleJobActionGeneric object so that we can make sure that jobLifeCycle properly terminates 
</summary>
</member>
<member name="F:Prajna.Core.SingleJobActionGeneric`1.cnt">
<summary>
 Whether we have successfully hold a JobLifeCycle object and garantee that can use the object before it is being cancelled 
</summary>
</member>
<member name="P:Prajna.Core.SingleJobActionGeneric`1.IsCancelledAndThrow">
<summary>
 Check if the job has been cancelled, and if a exception is thrown, it will be propagated back. 
</summary>
</member>
<member name="P:Prajna.Core.SingleJobActionGeneric`1.IsCancelled">
<summary>
 Check if the job has been cancelled
</summary>
</member>
<member name="P:Prajna.Core.SingleJobActionGeneric`1.Exception">
<summary>
 Exception 
</summary>
</member>
<member name="P:Prajna.Core.SingleJobActionGeneric`1.CanExecuteOrThrow">
<summary>
 Check whether the job can still execute, throw exception if need
 Return:
     true: job can continue to execute
     false: job is cancelled
     throw exception, (exception encoutnered)
</summary>
</member>
<member name="P:Prajna.Core.SingleJobActionGeneric`1.CTS">
<summary>
 Get Cancelation Token
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.ThrowExceptionAtCallback(System.String)">
<summary>
 Create a System.Exception, cancel this job using this exception
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.ReceiveExceptionAtCallback(System.Exception,System.String)">
<summary>
 Runtime at callback encounter an exception, cancel this job using this exception with location information 
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.LogException">
<summary>
 Show Exception information. 
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.Exit">
<summary>
 Release lock of DSet for a particular write job
 The object should not be used afterwards  
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.EncounterExceptionAtCallback(System.Exception,System.String)">
<summary>
 Runtime at callback encounter an exception, cancel this job using this exception with location information 
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.CancelJob">
<summary>
 Close the associated job (can be a normal close operation
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.CancelByException(System.Exception)">
<summary>
 Exception encountered by the execution of this job
 Try to cancel the entire job for execution
</summary>
</member>
<member name="M:Prajna.Core.SingleJobActionGeneric`1.CancelByError(System.Exception)">
<summary>
 Exception encountered by the execution of this job
 Try to cancel the entire job for execution
</summary>
</member>
<member name="T:Prajna.Core.SingleJobActionGeneric`1">
<summary>
 Allow a segment of the program to hold a particular instance of a JobLifeCycle object, usually used when an executed job uses JobLifeCycle
 When an action is in process, cancellation of jobLifeCycle will be delayed until this action completes. 
 It will be disposed at the end of the action so that jobLifeCycle can be cancelled. 
 Please always use:
 using () ( fun _ -&gt; _) when programming with the SingleJobActionGeneric object so that we can make sure that jobLifeCycle properly terminates 
</summary>
</member>
<member name="F:Prajna.Core.SourceFunctionWrapper`1.SourceSeqFunc@">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.SourceFunctionWrapper`1.SourceSeqFunc(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{`0}})">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.SourceFunctionWrapper`1.SourceSeqFunc">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="M:Prajna.Core.SourceFunctionWrapper`1.WrapperSourceFunc(Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind)">
<summary>
 Wrapper Mapping Function for Init, which is a DSet with DSetDependencyType.Source 
 The calling signature should be parti, serial, 0, null, null (numElems and o and v are not used). 
 The return signature should be (parti, serial, numElems, ko, vo) in which SerializationLimit worth of objects are generated.
 The InitFunc will be called for ( parti, serial) to generate the object associated with the serialization
 The InitFunc signals the end when it sends parti, serial, numElems, null, null
</summary>
</member>
<member name="T:Prajna.Core.SourceFunctionWrapper`1">
<summary>
 Mapping function wrapper: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
</summary>
</member>
<member name="F:Prajna.Core.SourceIFunctionWrapper`1.SourceISeqFunc@">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.SourceIFunctionWrapper`1.SourceISeqFunc(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{`0}})">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.SourceIFunctionWrapper`1.SourceISeqFunc">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="M:Prajna.Core.SourceIFunctionWrapper`1.WrapperSourceIFunc(Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind)">
<summary>
 Wrapper Mapping Function for Init, which is a DSet with DSetDependencyType.Source 
 The calling signature should be parti, serial, 0, null, null (numElems and o and v are not used). 
 The return signature should be (parti, serial, numElems, ko, vo) in which SerializationLimit worth of objects are generated.
 The InitFunc will be called for ( parti, serial) to generate the object associated with the serialization
 The InitFunc signals the end when it sends parti, serial, numElems, null, null
</summary>
</member>
<member name="T:Prajna.Core.SourceIFunctionWrapper`1">
<summary>
 Mapping function wrapper: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
</summary>
</member>
<member name="F:Prajna.Core.SourceNFunctionWrapper`1.SourceNSeqFunc@">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.SourceNFunctionWrapper`1.SourceNSeqFunc(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Collections.Generic.IEnumerable{`0}})">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="P:Prajna.Core.SourceNFunctionWrapper`1.SourceNSeqFunc">
<summary>
 sizeFunc: parti -&gt; size of partition i
</summary>
</member>
<member name="M:Prajna.Core.SourceNFunctionWrapper`1.WrapperSourceNFunc(Prajna.Core.BlobMetadata,System.Object,Prajna.Core.MapToKind)">
<summary>
 Wrapper Mapping Function for Init, which is a DSet with DSetDependencyType.Source 
 The calling signature should be parti, serial, 0, null, null (numElems and o and v are not used). 
 The return signature should be (parti, serial, numElems, ko, vo) in which SerializationLimit worth of objects are generated.
 The InitFunc will be called for ( parti, serial) to generate the object associated with the serialization
 The InitFunc signals the end when it sends parti, serial, numElems, null, null
</summary>
</member>
<member name="T:Prajna.Core.SourceNFunctionWrapper`1">
<summary>
 Mapping function wrapper: helps to deserialize and serialize Memstreams
 Generic, allows mapping from DSet&lt;&apos;U&gt; -&gt; DSet&lt;&apos;U1&gt;
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.StorageMediumMask">
<summary>
 Mask to retrieve storage type 
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.Passthrough">
<summary>
 no storage, the DSet content is only instantiated during start up 
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.Azure">
<summary>
 Azure storage 
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.RAM">
<summary>
 In-memory, instantiated object. 
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.SSD">
<summary>
 SSD 
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.HDD">
<summary>
 Hard drive 
</summary>
</member>
<member name="F:Prajna.Core.StorageKind.None">
<summary>
 Should not be used 
</summary>
</member>
<member name="T:Prajna.Core.StorageKind">
<summary>
 Type of Storage used by DSet
</summary>
</member>
<member name="P:Prajna.Core.StorageStream.RecommendedBufferSize">
<summary>
 Recommended size of the wrapper Buffered Stream for performance optimization
</summary>
</member>
<member name="P:Prajna.Core.StorageStream.Persistent">
<summary>
 Does this storage element support persistency (e.g., Azure Blob is considered persistent
</summary>
</member>
<member name="P:Prajna.Core.StorageStream.IsLocal">
<summary>
 Is this a local store
</summary>
</member>
<member name="M:Prajna.Core.StorageStream.Open(System.String[],System.String[])">
<summary>
 Open blobs for read
 Parameter: ( [| path1, path2, ..., pathn |], [|name1, name2, ..., namei|], File.Mode )
 Return:
 An array of StorageStream to be written upon
</summary>
</member>
<member name="M:Prajna.Core.StorageStream.List(System.String[],System.String)">
<summary>
 List the content of the directory 
 parameter ( [| path1, path2, ..., pathn |] )
 Return: 
 an array of items in the directory
 each item contains its name, type (directory or blob), and the size of the content (0: for directory)
</summary>
</member>
<member name="M:Prajna.Core.StorageStream.Exist(System.String[],System.String[])">
<summary>
 Is a certain file exist
</summary>
</member>
<member name="M:Prajna.Core.StorageStream.Delete(System.String[],System.String)">
<summary>
 Delete blobs
 Parameter: ( [| path1, path2, ..., pathn |], [|name1, name2, ..., namei|] )
</summary>
</member>
<member name="M:Prajna.Core.StorageStream.Create(System.String[],System.String[])">
<summary>
 Create blobs
 Parameter: ( [| path1, path2, ..., pathn |], [|name1, name2, ..., namei|], File.Mode )
 Return:
 An array of StorageStream to be written upon
</summary>
</member>
<member name="M:Prajna.Core.StorageStream.Choose(System.String[],System.String[])">
<summary>
 Choose files to be created and written upon
 Parameter: ( [| path1, path2, ..., pathn |], [|name1, name2, ..., namei|])
 Return:
 An array of files to be created and written upon
</summary>
</member>
<member name="T:Prajna.Core.StorageStream">
<summary>
 Common Base Class for Storage in 
</summary>
</member>
<member name="M:Prajna.Core.SystemBug.Sleep(System.Int32)">
<summary>
 Sleep is used to replace Async.Sleep, which sometime takes a super long time to wake up. 
 A sleep of 1ms can turn into !!!213187.620400ms!!! in one of the instance. 
</summary>
</member>
<member name="F:Prajna.Core.Task.DSetReferences@">
<summary>
 DSet and DStream that will be referenced to form the execution graph
</summary>
</member>
<member name="F:Prajna.Core.Task.QueueToClient@">
<summary>
 QueueAtClient resides at AppDomain/Exe, it is the local loopback interface to talk to the PrajnaClient
</summary>
</member>
<member name="F:Prajna.Core.Task.IncomingQueuesClusterMembership@">
<summary>
 Map a particular queue (index) to a membership list of 
 ( cluster, peerindex)
 ...
</summary>
</member>
<member name="F:Prajna.Core.Task.IncomingQueues@">
<summary>
 Map peer index to a queue
</summary>
</member>
<member name="P:Prajna.Core.Task.QueueToClient(Prajna.Core.NetworkCommandQueue)">
<summary>
 QueueAtClient resides at AppDomain/Exe, it is the local loopback interface to talk to the PrajnaClient
</summary>
</member>
<member name="P:Prajna.Core.Task.IncomingQueuesClusterMembership(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Collections.Generic.List{System.Tuple{Prajna.Core.Cluster,System.Int32}}})">
<summary>
 Map a particular queue (index) to a membership list of 
 ( cluster, peerindex)
 ...
</summary>
</member>
<member name="P:Prajna.Core.Task.IncomingQueues(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,Prajna.Core.NetworkCommandQueuePeer})">
<summary>
 Map peer index to a queue
</summary>
</member>
<member name="P:Prajna.Core.Task.QueueToClient">
<summary>
 QueueAtClient resides at AppDomain/Exe, it is the local loopback interface to talk to the PrajnaClient
</summary>
</member>
<member name="P:Prajna.Core.Task.QueueAtClientMonitor">
<summary>
 Monitor QueueAtClient resides at PrajnaClient, give null if need to wait
</summary>
</member>
<member name="P:Prajna.Core.Task.QueueAtClient">
<summary>
 QueueAtClient resides at PrajnaClient, it is the local loopback interface to talk to the job at the AppDomain/Exe
</summary>
</member>
<member name="P:Prajna.Core.Task.PrimaryHostQueue">
<summary>
 Return one host queue 
</summary>
</member>
<member name="P:Prajna.Core.Task.IncomingQueuesClusterMembership">
<summary>
 Map a particular queue (index) to a membership list of 
 ( cluster, peerindex)
 ...
</summary>
</member>
<member name="P:Prajna.Core.Task.IncomingQueues">
<summary>
 Map peer index to a queue
</summary>
</member>
<member name="P:Prajna.Core.Task.DSetReferences">
<summary>
 DSet and DStream that will be referenced to form the execution graph
</summary>
</member>
<member name="M:Prajna.Core.Task.UpdatePrimaryHostQueue">
<summary>
 Check for validity of the Primary Host Queue, and make update. 
</summary>
</member>
<member name="M:Prajna.Core.Task.UnloadAll">
<summary>
 Unload all Cluster, DSet, GV, this is particularly important for static reference in DStreamFactory
</summary>
</member>
<member name="M:Prajna.Core.Task.TrySyncMetadataClient">
<summary>
 Sync metadata, in P2P fashion. 
</summary>
</member>
<member name="M:Prajna.Core.Task.TrySendSrcMetadataToHost(Prajna.Core.NetworkCommandQueuePeer,Prajna.Core.BlobAvailability)">
<summary>
 Try send missing srouce metadata (srcDSet) to host
 The information is light, so the sending command is executed synchronously. 
</summary>
</member>
<member name="M:Prajna.Core.Task.ToStartJob">
<summary>
 Send Start Job Command to the linked program. 
</summary>
</member>
<member name="M:Prajna.Core.Task.TerminateTask">
<summary>
 Persistent job is never killed
 Stop the job 
</summary>
</member>
<member name="M:Prajna.Core.Task.StartTaskAsSeperateApp(System.String,System.Int64,System.String,System.Int32,System.String,System.Int32,System.Tuple{System.Boolean,System.Guid,System.Tuple{System.Byte[],System.Byte[]},System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
<summary>
 Entry point for task as a separate appdomain or exe 
 sigName: Signature Name of the Executable Module
 sigVersion: Version information of the executable module
 port: loopback port
 lport: listening port
 clientProcessId: the host client&apos;s process Id
 clientModuleName: the host client&apos;s module name
 clientStartTimeTicks: the ticks of the host client&apos;s start time
</summary>
</member>
<member name="M:Prajna.Core.Task.StartLightTask">
<summary>
 Check blob availability 
</summary>
</member>
<member name="M:Prajna.Core.Task.ShouldTerminate">
<summary>
 Do we need to kill the task?
</summary>
</member>
<member name="M:Prajna.Core.Task.ResolveOne``1(``0,Prajna.Core.DistributedObject)">
<summary>
 Action for traverse, resolve object for both up and down dependency
</summary>
</member>
<member name="M:Prajna.Core.Task.ResolveDependentDStream(Prajna.Core.DependentDObject)">
<summary>
 Resolve a single dependent DSet Object
</summary>
</member>
<member name="M:Prajna.Core.Task.ResolveDependentDSet(Prajna.Core.DependentDObject)">
<summary>
 Resolve a single dependent DSet Object
</summary>
</member>
<member name="M:Prajna.Core.Task.RegisterOne(System.Boolean,Prajna.Core.DistributedObject)">
<summary>
 Action for registering callback. 
</summary>
</member>
<member name="M:Prajna.Core.Task.RegisterInJobCallback(Prajna.Core.DSet,System.Boolean)">
<summary>
 Register &amp; Unregister Callback
</summary>
</member>
<member name="M:Prajna.Core.Task.ReadDSet(Prajna.Core.DSetPeer,Prajna.Core.NetworkCommandQueuePeer,System.Int32[])">
<summary>
 Read DSet, and send the result to the Queue.[0]
</summary>
</member>
<member name="M:Prajna.Core.Task.ParseTaskCommandAtDaemon(Prajna.Core.SingleJobActionContainer,Prajna.Core.NetworkCommandQueuePeer,Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte},Prajna.Core.TaskQueue)">
<summary>
 Process incoming command for the task queue. 
 true: Command parsed. 
 false: Command Not parsed
</summary>
</member>
<member name="M:Prajna.Core.Task.OnJobFinish">
<summary>
 OnJobFinish govern freeing of the resource of the Task object. 
 It has been registered when the Task is first established, and will garantee to execute when job is done or cancelled
</summary>
</member>
<member name="M:Prajna.Core.Task.LoadAllJobDependencies">
<summary>
 Load all job depencies            
</summary>
</member>
<member name="M:Prajna.Core.Task.LoadAllAssemblies">
<summary>
 Load all Assemblies
</summary>
</member>
<member name="M:Prajna.Core.Task.LoadAll">
<summary>
 Load all Cluster, DSet, GV, Assemblies
 For DSet, DStream, ClusterJobInfo, they are only decoded in AppDomain/Exe, and is not available in the main loop.  
 This should only be called in AppDomain. 
</summary>
</member>
<member name="M:Prajna.Core.Task.LinkAllAssemblies(System.String)">
<summary>
 Link all assemblies
</summary>
</member>
<member name="M:Prajna.Core.Task.GetIncomingQueueNumber(Prajna.Core.NetworkCommandQueuePeer)">
<summary>
 Add incoming queue for the job. 
</summary>
</member>
<member name="M:Prajna.Core.Task.FError(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String})">
<summary>
 Error: error in parsing 
</summary>
</member>
<member name="M:Prajna.Core.Task.ExceptionInTask(Prajna.Core.NetworkCommandQueue,Prajna.Core.Task,System.String)">
<summary>
 Throw exception to application
</summary>
</member>
<member name="M:Prajna.Core.Task.ExceptionInGeneral(Prajna.Core.NetworkCommandQueue,System.String)">
<summary>
 Throw general exception, not bound to a particular application
 Note that general exception may or may not be able to propagate back to application as it may miss routing information
</summary>
</member>
<member name="M:Prajna.Core.Task.EvaluateThreadState">
<summary>
 State of the job
</summary>
</member>
<member name="M:Prajna.Core.Task.ErrorInSeparateApp(Prajna.Core.NetworkCommandQueue,System.String)">
<summary>
 Unusual error in a container
 The error cannot be localized to a certain job, but can be assoicated with a network queue 
</summary>
</member>
<member name="M:Prajna.Core.Task.ErrorAsSeparateApp(System.String)">
<summary>
 Error
</summary>
</member>
<member name="M:Prajna.Core.Task.Error(System.String)">
<summary>
 Error: error in parsing 
</summary>
</member>
<member name="M:Prajna.Core.Task.DSetReadToNetworkAsSeparateAppSync(Prajna.Core.NetworkCommandQueue,System.Net.IPEndPoint,Prajna.Core.DSet,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 ReadToNetwork, Job (DSet) 
</summary>
</member>
<member name="M:Prajna.Core.Task.DSetReadAsSeparateApp(Prajna.Core.NetworkCommandQueue,System.Net.IPEndPoint,Prajna.Core.DSet,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>
 Read, Job (DSet) 
</summary>
</member>
<member name="M:Prajna.Core.Task.DSetFoldAsSeparateApp(Prajna.Core.NetworkCommandQueue,System.Net.IPEndPoint,Prajna.Core.DSet,System.Collections.Generic.IEnumerable{System.Int32},Prajna.Core.FoldFunction,Prajna.Core.AggregateFunction,Prajna.Core.GVSerialize,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Object},Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Fold, Job (DSet) 
</summary>
</member>
<member name="M:Prajna.Core.Task.ClusterMembership(Prajna.Core.NetworkCommandQueue)">
<summary>
 Generate a membership list 
</summary>
</member>
<member name="M:Prajna.Core.Task.ClientReceiveBlob(System.Int32,System.Boolean)">
<summary>
 Client: perform necessary processing of arrival of Blobi, e.g., 
    for assembly, write the blob data to assembly file
</summary>
</member>
<member name="M:Prajna.Core.Task.ClientAvailability(System.Int64,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.Blob,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Tools.StreamBase{System.Byte},System.Int64},Microsoft.FSharp.Core.Unit}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{Prajna.Core.Blob,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Prajna.Tools.StreamBase{System.Byte},System.Int64},Microsoft.FSharp.Core.Unit}}}})">
<summary>
 Initialize the avaliablity vector
</summary>
</member>
<member name="M:Prajna.Core.Task.CheckClientLiveness(System.Int32,System.String,System.Int64)">
<summary>
 Check whether the host client is alive 
</summary>
</member>
<member name="M:Prajna.Core.Task.AddCluster(Prajna.Core.Cluster,Prajna.Core.Blob)">
<summary>
 Add a new cluster to the job
 The function will recheck the membership relation of each peer (represented by queue), and redefine PrimaryHostQueueIndex
 that defines the PrimaryHostQueue to communicate with host. 
</summary>
</member>
<member name="T:Prajna.Core.Task">
<summary>
 Prajna Task 
 A Prajna task is an action to be executed at Prajna Client, 
 it usually involes one or more DSet peer parameters, and one or more functions to be executed upon. 
 class Task is usually hosted at the Prajna Client. 
</summary>
</member>
<member name="F:Prajna.Core.TaskLaunchMode.DonotLaunch">
<summary>
 Do not launch a remote container, usually used to close a service in remote container. 
</summary>
</member>
<member name="F:Prajna.Core.TaskLaunchMode.LaunchAndFailWhenDifferentVersionExist">
<summary>
 Launch a remote container, fail if there are containers of different signatures. 
</summary>
</member>
<member name="F:Prajna.Core.TaskLaunchMode.LaunchAndDisregardDifferentVersion">
<summary>
 Launch a remote container, don&apos;t check whether there are containers of different signatures. 
</summary>
</member>
<member name="F:Prajna.Core.TaskLaunchMode.LaunchAndTerminateDifferentVersion">
<summary>
 Launch a remote container, if there are containers of different signature exist, terminate those containers (with an outdated execution roster). 
</summary>
</member>
<member name="T:Prajna.Core.TaskLaunchMode">
<summary>
 Enumeration Class that controls the behavior of the remote container launch
</summary>
</member>
<member name="F:Prajna.Core.TaskQueue.CurExeJobs@">
<summary>
 Current # of Exe Jobs. 
</summary>
</member>
<member name="F:Prajna.Core.TaskQueue.CurAppDomainJobs@">
<summary>
 Current # of AppDomain Jobs. 
</summary>
</member>
<member name="F:Prajna.Core.TaskQueue.CurLightJobs@">
<summary>
 TODO: JinL
 We intentionally set a low job limit for debugging purpose, this limit will be raised considering the capacity of the machines. 
 Current # of Light Jobs. 
</summary>
</member>
<member name="F:Prajna.Core.TaskQueue.EvEmptyExecutionTable@">
<summary>
 Whether there are any remote container attached to daemon. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.CurLightJobs(System.Int32)">
<summary>
 TODO: JinL
 We intentionally set a low job limit for debugging purpose, this limit will be raised considering the capacity of the machines. 
 Current # of Light Jobs. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.CurExeJobs(System.Int32)">
<summary>
 Current # of Exe Jobs. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.CurAppDomainJobs(System.Int32)">
<summary>
 Current # of AppDomain Jobs. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.Tasks">
<summary>
 List of Tasks
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.EvEmptyExecutionTable">
<summary>
 Whether there are any remote container attached to daemon. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.CurLightJobs">
<summary>
 TODO: JinL
 We intentionally set a low job limit for debugging purpose, this limit will be raised considering the capacity of the machines. 
 Current # of Light Jobs. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.CurExeJobs">
<summary>
 Current # of Exe Jobs. 
</summary>
</member>
<member name="P:Prajna.Core.TaskQueue.CurAppDomainJobs">
<summary>
 Current # of AppDomain Jobs. 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.TerminateSeparateTask(System.String)">
<summary>
 Terminate All tasks in the app domain/exe
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.ReportCrash(System.String,System.Int64,Prajna.Tools.MemoryStreamB)">
<summary>
 Report Crash message. 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.RemoveSeparateTask(Prajna.Core.Task)">
<summary>
 Find a task 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.RemoveFinishedJobs">
<summary>
 Remote Finished Jobs, and reset # of active jobs. 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.ParseCommandAtDaemon(Prajna.Core.NetworkCommandQueuePeer,Prajna.Core.ControllerCommand,Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Process incoming command for the task queue. 
 Return:
     True: if command has been parsed. 
     False: if command has not been parsed. 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.MonitorTasks">
<summary>
 Monitoring all tasks 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.LinkSeparateProgram(Prajna.Core.NetworkCommandQueue,System.String,System.Int64)">
<summary>
 Called by PrajnaClient, to link tasks
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.GetTasks">
<summary>
 Get a list of current tasks 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.GetTaskHolderOfDifferentVersion(Prajna.Core.Task)">
<summary>
 Get related task holder
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.GetRelatedTaskHolder(Prajna.Core.Task)">
<summary>
 Get related task holder
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.GetAllRelatedTasksDeprecated(Prajna.Core.Task)">
<summary>
 Get All tasks with the same signature
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.FindTaskHolderByloopbackQueue(Prajna.Core.NetworkCommandQueue)">
<summary>
 Find task tolder 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.FindTaskHolderByService(System.String)">
<summary>
 is any of the DSet embedded in Task by name only
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.FindTask(System.Guid)">
<summary>
 Find a certain task by name &amp; vernumber
 If verNumber = 0L, find the latest task in the system. 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.FindSeparateTask(Prajna.Core.Task)">
<summary>
 Find a task 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.FindDSet(System.String,System.Int64)">
<summary>
 is any of the DSet embedded in Task (therefore not visible globally? )
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.ExecuteTask(Prajna.Core.Task,Prajna.Core.NetworkCommandQueue)">
<summary>
 Execute a task
 Return: true, job executed
         false, job failed (no slot)
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.ExecuteLightJobs">
<summary>
 Find one task to execute. 
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.ConnectTaskToTaskHolder(Prajna.Core.Task,Prajna.Core.NetworkCommandQueue)">
<summary>
 Add a task with feedback Queue
</summary>
</member>
<member name="M:Prajna.Core.TaskQueue.CloseConnectedQueueForAllTasks(Prajna.Core.NetworkCommandQueue)">
 <summary>
 Shutdown associated connection queue
 </summary>
</member>
<member name="M:Prajna.Core.TaskQueue.AddSeparateTask(Prajna.Core.Task,Prajna.Core.NetworkCommandQueue)">
<summary>
 Add a task with feedback Queue
</summary>
</member>
<member name="T:Prajna.Core.ThreadsInformation">
<summary>
 Threads 
</summary>
</member>
<member name="T:Prajna.Core.TransformKind">
<summary>
 Transform type is a one byte mask defines the type of the transform 
 that is used by Prajna
</summary>
</member>
<member name="T:Prajna.Core.TraverseDirection">
<summary>
 Enumeration class of Traverse Upstream or downstream.
</summary>
</member>
<member name="F:Prajna.Service.AggregationPolicyCollection.AggregationPolicyDefaultGuid@">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="F:Prajna.Service.AggregationPolicyCollection.AggregationByAllReplyGuid@">
<summary>
 Guid of policy to return all object after completion is signalled
</summary>
</member>
<member name="F:Prajna.Service.AggregationPolicyCollection.AggregationByFirstReplyGuid@">
<summary>
 Guid of policy to return the first object of the reply
</summary>
</member>
<member name="F:Prajna.Service.AggregationPolicyCollection.aggregationPolicyCollection">
 <summary> 
 Collection of distribution Policy
 </summary> 
</member>
<member name="P:Prajna.Service.AggregationPolicyCollection.AggregationPolicyDefaultGuid(System.Guid)">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.AggregationPolicyCollection.AggregationPolicyDefaultGuid">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.AggregationPolicyCollection.AggregationByFirstReplyGuid">
<summary>
 Guid of policy to return the first object of the reply
</summary>
</member>
<member name="P:Prajna.Service.AggregationPolicyCollection.AggregationByAllReplyGuid">
<summary>
 Guid of policy to return all object after completion is signalled
</summary>
</member>
<member name="M:Prajna.Service.AggregationPolicyCollection.Register(System.Guid,System.String,System.Func{System.Tuple{Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64,System.Object},System.Boolean})">
<summary>
 Guid of policy to randomly select a service endpoint
 Register additional distribution policy 
</summary>
</member>
<member name="M:Prajna.Service.AggregationPolicyCollection.FindAggregationPolicy(System.Guid)">
<summary>
 Find aggregation policy, if the request policy doesn&apos;t exist, the policy AggregationByFirstReplyGuid will be applied. 
</summary>
</member>
<member name="M:Prajna.Service.AggregationPolicyCollection.AggregationByFirstReply(Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64,System.Object)">
<summary>
 Return the first object of the reply, and then signals that the operation is completed
</summary>
</member>
<member name="M:Prajna.Service.AggregationPolicyCollection.AggregationByAllReply(Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64,System.Object)">
<summary>
 Return the an object of the reply, but continuous execution
</summary>
</member>
<member name="T:Prajna.Service.AggregationPolicyCollection">
<summary>
 Collection of aggregation policy for distributed function
</summary>
</member>
<member name="T:Prajna.Service.AggregationPolicyFunction">
 <summary> 
 An aggregation policy delegate determines the action to perform when it receives the reply (OnNext) from a particular service endpoints.  
 Return:
     true: the life cycle of the RemoteDistributedFunction has been completed, and the function holder may terminates. 
     false: the life cycle fo the RemoteDistributedFunction can still continues. 
 </summary>
</member>
<member name="F:Prajna.Service.CacheService.CacheServiceName@">
<summary>
 Default name of the cache service. 
</summary>
</member>
<member name="P:Prajna.Service.CacheService.CacheServiceName(System.String)">
<summary>
 Default name of the cache service. 
</summary>
</member>
<member name="P:Prajna.Service.CacheService.CacheServiceName">
<summary>
 Default name of the cache service. 
</summary>
</member>
<member name="M:Prajna.Service.CacheService.Stop(Prajna.Core.Cluster)">
<summary>
 Stop cache service on cluster
</summary>
</member>
<member name="M:Prajna.Service.CacheService.Stop">
<summary>
 Stop cache service on current cluster
</summary>
</member>
<member name="M:Prajna.Service.CacheService.Start(Prajna.Core.Cluster)">
<summary>
 Start cache service on cluster
</summary>
</member>
<member name="M:Prajna.Service.CacheService.Start">
<summary>
 Start cache service on current cluster
</summary>
</member>
<member name="T:Prajna.Service.CacheService">
 <summary>
 Cache Service doesn't do anything itself. It only register a service with an AppDomain/Exe, so that when the client stops, the AppDomain/Exe continues to 
 run and hold cached data. 
 </summary>
</member>
<member name="T:Prajna.Service.CacheServiceClass">
 <summary>
 Cache Service doesn't do anything itself. It only register a service with an AppDomain/Exe, so that when the client stops, the AppDomain/Exe continues to 
 run and hold the recognition service. 
 bool OnStart(): Run once when the service started
 bool OnStop(): Run once when the service stopped
 void Run(): main entry point when the service is running. 
 bool IsRunning(): return true if the service is still running, false if the service terminates.
 </summary>
</member>
<member name="F:Prajna.Service.CompletionPolicyCollection.CompletionPolicyDefaultGuid@">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="F:Prajna.Service.CompletionPolicyCollection.CompletionByAllPeersGuid@">
<summary>
 Guid of completion policy which is done after all peer complete
</summary>
</member>
<member name="F:Prajna.Service.CompletionPolicyCollection.CompletionByFirstPeerGuid@">
<summary>
 Guid of completion policy which is done after first peer completes
</summary>
</member>
<member name="F:Prajna.Service.CompletionPolicyCollection.completionPolicyCollection">
 <summary> 
 Collection of distribution Policy
 </summary> 
</member>
<member name="P:Prajna.Service.CompletionPolicyCollection.CompletionPolicyDefaultGuid(System.Guid)">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.CompletionPolicyCollection.CompletionPolicyDefaultGuid">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.CompletionPolicyCollection.CompletionByFirstPeerGuid">
<summary>
 Guid of completion policy which is done after first peer completes
</summary>
</member>
<member name="P:Prajna.Service.CompletionPolicyCollection.CompletionByAllPeersGuid">
<summary>
 Guid of completion policy which is done after all peer complete
</summary>
</member>
<member name="M:Prajna.Service.CompletionPolicyCollection.Register(System.Guid,System.String,System.Func{System.Tuple{Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64},System.Boolean})">
<summary>
 Guid of policy to randomly select a service endpoint
 Register additional distribution policy 
</summary>
</member>
<member name="M:Prajna.Service.CompletionPolicyCollection.FindCompletionPolicy(System.Guid)">
<summary>
 Find aggregation policy, if the request policy doesn&apos;t exist, the policy AggregationByFirstReplyGuid will be applied. 
</summary>
</member>
<member name="M:Prajna.Service.CompletionPolicyCollection.CompletionByFirstPeer(Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64)">
<summary>
 Return the first object of the reply, and then signals that the operation is completed
</summary>
</member>
<member name="M:Prajna.Service.CompletionPolicyCollection.CompletionByAllPeers(Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64)">
<summary>
 Return the an object of the reply, but continuous execution
</summary>
</member>
<member name="T:Prajna.Service.CompletionPolicyCollection">
<summary>
 Collection of completion policy for distributed function
</summary>
</member>
<member name="T:Prajna.Service.CompletionPolicyFunction">
 <summary> 
 An completion policy delegate determines the action to perform when it receives the completion (OnComplete) from a particular service endpoints.  
 Return:
     true: the life cycle of the RemoteDistributedFunction has been completed, and the function holder may terminates. 
     false: the life cycle fo the RemoteDistributedFunction can still continues. 
 </summary>
</member>
<member name="F:Prajna.Service.ContractInfo.DefaultRequestTimeoutAtDaemonInMS@">
 <summary> 
 Default timeout value for contract. If nothing happens during the interval, the contract will be removed from daemon
 </summary>
</member>
<member name="P:Prajna.Service.ContractInfo.DefaultRequestTimeoutAtDaemonInMS(System.Int32)">
 <summary> 
 Default timeout value for contract. If nothing happens during the interval, the contract will be removed from daemon
 </summary>
</member>
<member name="P:Prajna.Service.ContractInfo.DefaultRequestTimeoutAtDaemonInMS">
 <summary> 
 Default timeout value for contract. If nothing happens during the interval, the contract will be removed from daemon
 </summary>
</member>
<member name="M:Prajna.Service.ContractInfo.Unpack(Prajna.Tools.StreamBase{System.Byte})">
<summary>
 Always use null to represent empty string, so that type comparison can be meansingful. 
</summary>
</member>
<member name="T:Prajna.Service.ContractKind">
 <summary>
 Type of Contract being exported. 
 </summary>
</member>
<member name="F:Prajna.Service.ContractRequestManager.EndPointCollection@">
<summary>
 A collection of endpoint that the request has been sent to 
</summary>
</member>
<member name="F:Prajna.Service.ContractRequestManager.EvWait@">
<summary>
 ManualResetEvent to wait for the request to be fullfilled. 
</summary>
</member>
<member name="F:Prajna.Service.ContractRequestManager.RequestTicksTimeOut@">
<summary>
 Ticks at which time the request timesout
</summary>
</member>
<member name="F:Prajna.Service.ContractRequestManager.ReqID@">
<summary>
 ID of the request 
</summary>
</member>
<member name="F:Prajna.Service.ContractRequestManager.DefaultRequestTimeoutInMs@">
 <summary> default timeout value (in milliseconds) to timeout the request </summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.RequestTicksTimeOut(System.Int64)">
<summary>
 Ticks at which time the request timesout
</summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.DefaultRequestTimeoutInMs(System.Int32)">
 <summary> default timeout value (in milliseconds) to timeout the request </summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.RequestTicksTimeOut">
<summary>
 Ticks at which time the request timesout
</summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.ReqID">
<summary>
 ID of the request 
</summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.EvWait">
<summary>
 ManualResetEvent to wait for the request to be fullfilled. 
</summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.EndPointCollection">
<summary>
 A collection of endpoint that the request has been sent to 
</summary>
</member>
<member name="P:Prajna.Service.ContractRequestManager.DefaultRequestTimeoutInMs">
 <summary> default timeout value (in milliseconds) to timeout the request </summary>
</member>
<member name="M:Prajna.Service.ContractRequestManager.ParseFunc(Prajna.Tools.StreamBase{System.Byte},System.Int64)">
<summary>
 A function that is called when a reply comes back from a contract server 
</summary>
</member>
<member name="M:Prajna.Service.ContractRequestManager.FailedRequestFunc(System.String,System.Int64)">
<summary>
 A function that is called when a contract server informs that it fails to service the contract 
</summary>
</member>
<member name="T:Prajna.Service.ContractRequestManager">
<summary>
 Class that manage the life cycle of one request
</summary>
</member>
<member name="M:Prajna.Service.ContractRequestManagerForFunc`1.FailedRequestFunc(System.String,System.Int64)">
<summary>
 Failed request, if queueSignature is 0, all pending requests will be cancelled. 
</summary>
</member>
<member name="M:Prajna.Service.ContractRequestManagerForSeqFunc`1.FailedRequestFunc(System.String,System.Int64)">
<summary>
 Failed request, if queueSignature is 0, all pending requests will be cancelled. 
</summary>
</member>
<member name="F:Prajna.Service.ContractResolver.ConstructRequestFunc@">
<summary>
 Constract a request 
</summary>
</member>
<member name="F:Prajna.Service.ContractResolver.UnregisterFunc@">
<summary>
 Action being invoked when a contract server leaves
</summary>
</member>
<member name="F:Prajna.Service.ContractResolver.RegisterFunc@">
<summary>
 Action being invoked when a new contract server becomes available. 
</summary>
</member>
<member name="F:Prajna.Service.ContractResolver.ResolveTimeOutInMs@">
<summary>
 Timeout for importing the current contract 
</summary>
</member>
<member name="F:Prajna.Service.ContractResolver.ResolveTimeOutInMilliseconds@">
<summary>
 Timeout for importing a contract 
</summary>
</member>
<member name="F:Prajna.Service.ContractResolver.OutgoingCollections@">
 <summary>
 A store for connection end point of a particular contract
 </summary>
</member>
<member name="P:Prajna.Service.ContractResolver.UnregisterFunc(System.Action{System.Tuple{System.String,System.Int64}})">
<summary>
 Action being invoked when a contract server leaves
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.ResolveTimeOutInMs(System.Int32)">
<summary>
 Timeout for importing the current contract 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.ResolveTimeOutInMilliseconds(System.Int32)">
<summary>
 Timeout for importing a contract 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.RegisterFunc(System.Action{System.Int64})">
<summary>
 Action being invoked when a new contract server becomes available. 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.ConstructRequestFunc(System.Func{System.Guid,Prajna.Service.ContractRequestManager})">
<summary>
 Constract a request 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.UnregisterFunc">
<summary>
 Action being invoked when a contract server leaves
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.ResolveTimeOutInMs">
<summary>
 Timeout for importing the current contract 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.ResolveTimeOutInMilliseconds">
<summary>
 Timeout for importing a contract 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.RegisterFunc">
<summary>
 Action being invoked when a new contract server becomes available. 
</summary>
</member>
<member name="P:Prajna.Service.ContractResolver.OutgoingCollections">
 <summary>
 A store for connection end point of a particular contract
 </summary>
</member>
<member name="P:Prajna.Service.ContractResolver.ConstructRequestFunc">
<summary>
 Constract a request 
</summary>
</member>
<member name="M:Prajna.Service.ContractResolver.SendRequestDefaultTimeout``1(``0)">
 <summary>
 Send out a request, with name, input paramter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractResolver.SendRequestCustomizable``1(System.Int32,``0)">
 <summary>
 Send out a request 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractResolver.GetSendQueues(System.Guid)">
<summary>
 Return a set of queues to be used to send out the current request. 
</summary>
</member>
<member name="T:Prajna.Service.ContractResolver">
 <summary>
 Used to resolve pending contracts. 
 </summary>
</member>
<member name="F:Prajna.Service.ContractServerInfoLocal.ServerInCluster@">
<summary>
 Servers whose information is as part of the cluster
</summary>
</member>
<member name="F:Prajna.Service.ContractServerInfoLocal.ConnectedServerCollection@">
<summary>
 A list of connected server 
</summary>
</member>
<member name="F:Prajna.Service.ContractServerInfoLocal.ResolvedServerNameToIP@">
<summary>
 A list of resolved server, name to ip addresses
 server name is case insensitive
</summary>
</member>
<member name="F:Prajna.Service.ContractServerInfoLocal.ResolvedServerCollection@">
<summary>
 A list of resolved server, ip address to server name 
</summary>
</member>
<member name="F:Prajna.Service.ContractServerInfoLocal.OnConnectOperation@">
<summary>
 Register Functions ( a set of functions to be called once per queue connected ) 
</summary>
</member>
<member name="P:Prajna.Service.ContractServerInfoLocal.ServerInCluster">
<summary>
 Servers whose information is as part of the cluster
</summary>
</member>
<member name="P:Prajna.Service.ContractServerInfoLocal.ResolvedServerNameToIP">
<summary>
 A list of resolved server, name to ip addresses
 server name is case insensitive
</summary>
</member>
<member name="P:Prajna.Service.ContractServerInfoLocal.ResolvedServerCollection">
<summary>
 A list of resolved server, ip address to server name 
</summary>
</member>
<member name="P:Prajna.Service.ContractServerInfoLocal.OnConnectOperation">
<summary>
 Register Functions ( a set of functions to be called once per queue connected ) 
</summary>
</member>
<member name="P:Prajna.Service.ContractServerInfoLocal.ConnectedServerCollection">
<summary>
 A list of connected server 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.Parse(Prajna.Service.ContractServersInfo)">
<summary>
 Public interface to derive a ContractServerInfoLocal from ContractServersInfo
 Cache is used so that if the same ContractServersInfo is passed in, a already constructed ContractServerInfoLocal is returned
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.OnConnectAction(System.Action{System.Int64},System.Func{System.String})">
<summary>
 The action will be called once a queue has been connected
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.OnConnect(Microsoft.FSharp.Core.FSharpFunc{System.Int64,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String})">
<summary>
 The action will be called once a queue has been connected
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.IsEqualContractServerType(Prajna.Service.ContractServerType,Prajna.Service.ContractServerType)">
<summary>
 A list of to be resolved server ContractServerType is equal
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.GetServerCollection">
<summary>
 Return all resolved servers as a ConcurrentDictionary&lt;int64, string &gt;, where 
 the key is int64 which can parse to the IP Address &amp; port of the server, 
 and the value is the host name of the server. 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.GetClusterCollection">
<summary>
 Return each server as a single entry in the cluster. 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.DisconnectChannel(System.Int64)">
<summary>
 Disconnect a certain channel 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.DNSResolveOnce(System.Boolean)">
 <summary> 
 Resolve: all Single server, 
 Resolve: traffic manager once. 
 This process is a long running process and may contain blocking operation (DNS resolve), and is recommend to run on its separate thread. 
 </summary> 
 <param name="bAutoConnect"> true, automatically connect to the server that is resolved. 
                             false, no action is done. </param>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.ContainsSignature(System.Int64)">
<summary>
 We always use signature, to avoid holding reference to NetworkCommandQueue object
 Contains 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.Cancel">
<summary>
 Cancel all pending DNS resolve operation
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.AddConnectedChannel(Prajna.Core.NetworkCommandQueue,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String})">
<summary>
 Add a connected channel. 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.Add(Prajna.Service.ContractServersInfo)">
<summary>
 Add an additional set of Contract server
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocal.#ctor(Prajna.Service.ContractServersInfo)">
<summary>
 Function that compare if two 
 Instantiate a new set of Contract server information from local server. 
</summary>
</member>
<member name="T:Prajna.Service.ContractServerInfoLocal">
<summary>
 Specify contract servers to be monitored, this class can not be serialized
</summary>
</member>
<member name="M:Prajna.Service.ContractServerInfoLocalRepeatable.RepeatedDNSResolve(System.Boolean)">
<summary>
 Start a continuous DNS resolve process, because DNS resolve has blocking operation, the process is placed on its own thread, rather than schedule on a timer or task 
</summary>
</member>
<member name="T:Prajna.Service.ContractServerInfoLocalRepeatable">
<summary>
 ContractServerInfoLocalRepeatable is used to host remote servers that requires repeatable DNS resolution. 
 Such servers may be behind a traffic manager, in which new servers can be added for a single address, e.g., *.trafficmanager.net.
</summary>
</member>
<member name="F:Prajna.Service.ContractServerQueues.ResolvedContractServersCollection@">
<summary>
 A set of pre-resolved contract servers
</summary>
</member>
<member name="F:Prajna.Service.ContractServerQueues.Default@">
<summary>
 Default contract servers used.
</summary>
</member>
<member name="P:Prajna.Service.ContractServerQueues.ResolvedContractServersCollection">
<summary>
 A set of pre-resolved contract servers
</summary>
</member>
<member name="P:Prajna.Service.ContractServerQueues.Default">
<summary>
 Default contract servers used.
</summary>
</member>
<member name="M:Prajna.Service.ContractServerQueues.GetNetworkQueues(Prajna.Service.ContractServersInfo)">
<summary>
 Return a sequence of contract servers that are active
</summary>
</member>
<member name="M:Prajna.Service.ContractServerQueues.GetNetworkQueues">
<summary>
 Return a sequence of contract servers that are active
</summary>
</member>
<member name="M:Prajna.Service.ContractServerQueues.ConstructContractResolver(System.String)">
<summary>
 Construct a contract resolver for a particular contract 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerQueues.AddQueue(Prajna.Core.NetworkCommandQueue)">
<summary>
 Add a contract server by queue 
</summary>
</member>
<member name="M:Prajna.Service.ContractServerQueues.AddCluster(Prajna.Core.Cluster)">
<summary>
 Add a cluster of contract servers 
</summary>
</member>
<member name="T:Prajna.Service.ContractServerQueues">
<summary>
 Specify additional contract servers to be used. 
</summary>
</member>
<member name="T:Prajna.Service.ContractServerType">
<summary>
 Method to specify a contract server
</summary>
</member>
<member name="F:Prajna.Service.ContractServersInfo.InternalToResolveAllInMillisecond@">
<summary>
 Internal to Resolve All Traffic manager (in millisecond) 
</summary>
</member>
<member name="F:Prajna.Service.ContractServersInfo.ServerCollection@">
<summary>
 A list of contract server to be used. 
</summary>
</member>
<member name="F:Prajna.Service.ContractServersInfo.ID@">
<summary>
 A Guid that uniquely identifies ContractServersInfo class. 
 We expect that the ContractServersInfo to be parsed to remote node (e.g., to import contract). The Guid can be used to uniquely 
 identify the ContractServerInfo class, and avoids information to be reinitialized. 
</summary>
</member>
<member name="P:Prajna.Service.ContractServersInfo.InternalToResolveAllInMillisecond(System.Int32)">
<summary>
 Internal to Resolve All Traffic manager (in millisecond) 
</summary>
</member>
<member name="P:Prajna.Service.ContractServersInfo.ID(System.Guid)">
<summary>
 A Guid that uniquely identifies ContractServersInfo class. 
 We expect that the ContractServersInfo to be parsed to remote node (e.g., to import contract). The Guid can be used to uniquely 
 identify the ContractServerInfo class, and avoids information to be reinitialized. 
</summary>
</member>
<member name="P:Prajna.Service.ContractServersInfo.Cluster(Prajna.Core.Cluster)">
<summary>
 Add a cluster
</summary>
</member>
<member name="P:Prajna.Service.ContractServersInfo.ServerCollection">
<summary>
 A list of contract server to be used. 
</summary>
</member>
<member name="P:Prajna.Service.ContractServersInfo.InternalToResolveAllInMillisecond">
<summary>
 Internal to Resolve All Traffic manager (in millisecond) 
</summary>
</member>
<member name="P:Prajna.Service.ContractServersInfo.ID">
<summary>
 A Guid that uniquely identifies ContractServersInfo class. 
 We expect that the ContractServersInfo to be parsed to remote node (e.g., to import contract). The Guid can be used to uniquely 
 identify the ContractServerInfo class, and avoids information to be reinitialized. 
</summary>
</member>
<member name="M:Prajna.Service.ContractServersInfo.ToString">
<summary>
 Show server information
</summary>
</member>
<member name="M:Prajna.Service.ContractServersInfo.NewID">
<summary>
 Assign a new ID, usually means that there are some change/addition of the server 
</summary>
</member>
<member name="M:Prajna.Service.ContractServersInfo.AddSingleServer(System.String,System.Int32)">
<summary>
 Add one single server, with server name and port, 
 We assume that the single server always resolved to a certain servername and port, thus doesn&apos;t need to be resolved repeatedly
</summary>
</member>
<member name="M:Prajna.Service.ContractServersInfo.AddServerBehindTrafficManager(System.String,System.Int32)">
<summary>
 Add one traffic manager, with server name and port, 
 the traffic manager may be resolved to different servers during the time span
</summary>
</member>
<member name="M:Prajna.Service.ContractServersInfo.AddDaemon">
<summary>
 Add Daemon
</summary>
</member>
<member name="M:Prajna.Service.ContractServersInfo.AddCluster(Prajna.Core.Cluster)">
<summary>
 Add a cluster 
</summary>
</member>
<member name="T:Prajna.Service.ContractServersInfo">
<summary>
 Specify servers to be used to launch services, import and export contract
</summary>
</member>
<member name="F:Prajna.Service.ContractStore.Collections@">
 <summary>
 Access the common ContractStore for the address space. 
 </summary>
</member>
<member name="F:Prajna.Service.ContractStore.Current@">
 <summary>
 Access the common ContractStore for the address space. 
 </summary>
</member>
<member name="P:Prajna.Service.ContractStore.Current">
 <summary>
 Access the common ContractStore for the address space. 
 </summary>
</member>
<member name="P:Prajna.Service.ContractStore.Collections">
 <summary>
 Access the common ContractStore for the address space. 
 </summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportSeqFunctionWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportSeqFunctionWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportSeqFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportSeqFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalSeqFunctionWithTimeout``2(System.String)">
<summary>
 Import a function Func&lt;&apos;T,IEnumerable&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalSeqFunctionWithTimeout``1(System.String)">
<summary>
 Import a function Func&lt;IEnumerable&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalSeqFunction``2(System.String)">
<summary>
 Import a function Func&lt;&apos;T,IEnumerable&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalSeqFunction``1(System.String)">
<summary>
 Import a function Func&lt;IEnumerable&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunctionWithTimeout``1(System.String)">
<summary>
 Import a function Func&lt;&apos;T,&apos;TResult&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunctionWithTimeout``2(System.String)">
<summary>
 Import a function Func&lt;&apos;T,&apos;TResult&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunctionTaskWithTimeout``1(System.String)">
<summary>
 Import a function task:  Func&lt;Task&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunctionTaskWithTimeout``2(System.String)">
<summary>
 Import a function task:  Func&lt;&apos;T,Task&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunctionTask``1(System.String)">
<summary>
 Import a function task:  Func&lt;Task&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunctionTask``2(System.String)">
<summary>
 Import a function task:  Func&lt;&apos;T,Task&lt;&apos;TResult&gt;&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunction``1(System.String)">
<summary>
 Import a function Func&lt;&apos;T,&apos;TResult&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalFunction``2(System.String)">
<summary>
 Import a function Func&lt;&apos;T,&apos;TResult&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportLocalAction``1(System.String)">
<summary>
 Import an action Action&lt;&apos;T&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportInternal(System.String)">
<summary>
 Export an action Action&lt;&apos;T&gt;
</summary>
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunctionWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunctionWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunctionTaskWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunctionTaskWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunctionTask``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunctionTask``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ImportAction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Action from both local &amp; server, with name, input parameter, if successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStore.ExportSeqFunction``2(System.String,System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Int32,System.Boolean)">
 <summary>
 Export as a function Func&lt;seq&lt;'TResult>>, the result can be imported and executed by Prajna data analytical pipeline. 
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="serializationLimit"> Parameter that controls granularity of serialization. If serializationLimit&lt;=0, the size is equivalent to Int32.MaxValue.
      The export function will collect an array of size serializationLimit of 'TResult[] worth of data, and then send the result to the calling function. 
 </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.ContractStore.ExportSeqFunction``1(System.String,System.Func{System.Collections.Generic.IEnumerable{``0}},System.Int32,System.Boolean)">
 <summary>
 Export as a function Func&lt;seq&lt;'TResult>>, the result can be imported and executed by Prajna data analytical pipeline. 
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="serializationLimit"> Parameter that controls granularity of serialization. If serializationLimit&lt;=0, the size is equivalent to Int32.MaxValue.
      The export function will collect an array of size serializationLimit of 'TResult[] worth of data, and then send the result to the calling function. 
 </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.ContractStore.ExportInternal(System.String,System.Object,System.Boolean)">
 <summary>
 Export an action Action&lt;'T>
 <param name="name"> Name of the action to be exported </param>
 <param name="act"> An action of type Action&lt;'T> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.ContractStore.ExportFunctionTask``2(System.String,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Boolean)">
 <summary>
 Export as a function that return a Task Func&lt;'T,Task&lt;'TResult>>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,Task&lt;'TResult>> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.ContractStore.ExportFunctionTask``1(System.String,System.Func{System.Threading.Tasks.Task{``0}},System.Boolean)">
 <summary>
 Export as a function that return a Task Func&lt;Task&lt;'TResult>>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,Task&lt;'TResult>> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.ContractStore.ExportFunction``1(System.String,System.Func{``0},System.Boolean)">
 <summary>
 Export as a function Func&lt;'TResult>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.ContractStore.ExportFunction``2(System.String,System.Func{``0,``1},System.Boolean)">
 <summary>
 Export as a function Func&lt;'T,'TResult>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.ContractStore.ExportAction``1(System.String,System.Action{``0},System.Boolean)">
 <summary>
 Export an action Action&lt;'T>
 <param name="name"> Name of the action to be exported </param>
 <param name="act"> An action of type Action&lt;'T> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="T:Prajna.Service.ContractStore">
 <summary>
 ContractStore provides a central location for export/import contract
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtDaemon.PendingRequests@">
 <summary>
 Requests that are pending
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtDaemon.ImportCollections@">
 <summary>
 Imported collection at daemon
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtDaemon.ExportCollections@">
 <summary>
 Exported contract at daemon
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtDaemon.Current@">
 <summary>
 Access the common ContractStoreAtDaemon for the address space. 
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtDaemon.PendingRequests">
 <summary>
 Requests that are pending
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtDaemon.ImportCollections">
 <summary>
 Imported collection at daemon
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtDaemon.ExportCollections">
 <summary>
 Exported contract at daemon
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtDaemon.Current">
 <summary>
 Access the common ContractStoreAtDaemon for the address space. 
 </summary>
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.RegisterContract(System.String,Prajna.Service.ContractInfo,System.Int64,System.Boolean)">
 <summary> 
 Register a contract at daemon
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.ProcessContractRequest(Prajna.Tools.StreamBase{System.Byte},System.Int64)">
 <summary> 
 Look for a contract at daemon with a particular name
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.ProcessContractReply(Prajna.Tools.StreamBase{System.Byte},System.Int64)">
 <summary> 
 Look for a contract at daemon with a particular name
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.ProcessContractFailedRequest(Prajna.Tools.StreamBase{System.Byte},System.Int64)">
 <summary> 
 Look for a contract at daemon with a particular name
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.MonitorContracts">
 <summary> 
 Monitor contracts at daemon
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.LookforContract(System.String,System.Int64)">
 <summary> 
 Look for a contract at daemon with a particular name
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtDaemon.CloseConnection(System.Int64)">
<summary>
 Call when a queue disconnects. 
</summary>
</member>
<member name="T:Prajna.Service.ContractStoreAtDaemon">
 <summary>
 ContractStoreAtDaemon registers contracts that are exported by PrajnaProgram at daemon. Client and other PrajnaProgram may search the contract store to find 
 appropriate contract to import. The class is to be used only by Prajna core programmers. 
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtProgram.ToResolve@">
 <summary>
 Contracts to be resolved
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtProgram.RequestCollections@">
 <summary>
 A store that stores the collected service entrypoint 
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtProgram.RegisteredContract@">
 <summary>
 name -> contract function
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtProgram.Collections@">
 <summary>
 Access the store for deserialization &amp; return of value for service. 
 </summary>
</member>
<member name="F:Prajna.Service.ContractStoreAtProgram.Current@">
 <summary>
 Access the common ContractStoreAtDaemon for the address space. 
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtProgram.ToResolve">
 <summary>
 Contracts to be resolved
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtProgram.RequestCollections">
 <summary>
 A store that stores the collected service entrypoint 
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtProgram.RegisteredContract">
 <summary>
 name -> contract function
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtProgram.RegisterContractToDaemon">
 <summary>
 Register the action/function to daemon
 </summary> 
</member>
<member name="P:Prajna.Service.ContractStoreAtProgram.Current">
 <summary>
 Access the common ContractStoreAtDaemon for the address space. 
 </summary>
</member>
<member name="P:Prajna.Service.ContractStoreAtProgram.Collections">
 <summary>
 Access the store for deserialization &amp; return of value for service. 
 </summary>
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.RegisterContractToServers(Prajna.Service.ContractServersInfo,System.String,Prajna.Service.ContractInfo,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Int64,Prajna.Tools.StreamBase{System.Byte}},Microsoft.FSharp.Core.Unit})">
 <summary>
 Register the action/function to daemon &amp; a group of servers
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportUnitSeqFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportSeqFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportFunctionUnit``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportFunctionTaskUnit``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportFunctionTask``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.ImportAction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Action, with name, input parameter
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreAtProgram.FunctionReturn``1(Prajna.Service.ContractRequestManagerForFunc{``0})">
 <summary> 
 Import a function, with name, input parameter
 </summary> 
</member>
<member name="T:Prajna.Service.ContractStoreAtProgram">
 <summary>
 ContractStoreAtProgram contains wrapped up contract and deserialization code for other program/service to access the contract. The class is to be used by Prajna 
 core programmers.  
 </summary>
</member>
<member name="M:Prajna.Service.ContractStoreCommon.RemoteInvoke(System.String)">
 <summary>
 Attach Common Header for remote invokation. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.RemoteFunctionWrapper``2(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Guid,System.Threading.Tasks.Task{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Guid,Prajna.Tools.MemoryStreamB},Microsoft.FSharp.Core.Unit})">
 <summary>
 Fucntion parsing to invoke a function remotely. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.RemoteFunctionTaskWrapper``2(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Guid,System.Threading.Tasks.Task{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Guid,Prajna.Tools.MemoryStreamB},Microsoft.FSharp.Core.Unit})">
 <summary>
 Fucntion parsing to invoke a function remotely. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.RemoteActionWrapper``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Prajna.Tools.MemoryStreamB,Microsoft.FSharp.Core.Unit})">
 <summary>
 Action parsing to invoke an action remotely. 
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.ParseRemoteSeqFunction``2(System.Int32,System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Int64,Prajna.Tools.StreamBase{System.Byte})">
 <summary>
 Parsing when a remote program call a function that returns IEnumerable Result
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.ParseRemoteFunctionTask``2(System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int64,Prajna.Tools.StreamBase{System.Byte})">
 <summary>
 Parsing when a remote program call a function that returns IEnumerable Result
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.ParseRemoteFunction``2(System.Func{``0,``1},System.Int64,Prajna.Tools.StreamBase{System.Byte})">
 <summary>
 Parsing when a remote program call a function that returns IEnumerable Result
 </summary> 
</member>
<member name="M:Prajna.Service.ContractStoreCommon.ParseRemoteAction``1(System.Action{``0},System.Int64,Prajna.Tools.StreamBase{System.Byte})">
 <summary>
 Action parsing when an action is invoked remotely. 
 </summary> 
</member>
<member name="F:Prajna.Service.DefaultSerializerForDistributedFunction.Customized">
<summary>
 Customized
</summary>
</member>
<member name="F:Prajna.Service.DefaultSerializerForDistributedFunction.JSonSerializer">
<summary>
 System.Runtime.Serialization.Json.DataContractJsonSerializer
</summary>
</member>
<member name="F:Prajna.Service.DefaultSerializerForDistributedFunction.BinarySerializer">
<summary>
 System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
</summary>
</member>
<member name="F:Prajna.Service.DefaultSerializerForDistributedFunction.PrajnaSerializer">
<summary>
 Default Serializer implementation in Prajna
</summary>
</member>
<member name="T:Prajna.Service.DefaultSerializerForDistributedFunction">
<summary>
 Govern the behavior of the default serialization to be used 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionBuiltIn.TriggerRemoteException">
<summary>
 Trigger an exception in remote function, for testing purpose only 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionBuiltIn.RemoteExceptionLocal">
<summary>
 Remote Exception 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionBuiltIn.GetContainerLocal">
<summary>
 Retrieve information of the local App/container, in the form of 
 machine name, container name 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionBuiltIn.GetConnectedContainers">
<summary>
 Get information of containers that is connected with the current clients. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionBuiltIn.GetBuiltInFunctionPerformance">
<summary>
 Trigger an exception in remote function, for testing purpose only 
 The performance is measured using the particular function of GetConnectedContainers()
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionBuiltIn">
<summary>
 A set of built in distributed functions. 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionBuiltInProvider">
<summary>
 For built in Prajna functions. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.ReqObject@">
<summary>
 Request object (input)
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.CompletionPolicy@">
<summary>
 Guid governs the behavior of completion
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.FailoverPolicy@">
<summary>
 Guid governs the behavior of failover 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.AggregationPolicy@">
<summary>
 Guid governs how to aggregate multiple requests  
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.DistributionPolicy@">
<summary>
 Guid governs which service endpoint(s) are selected to service the request. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.DomainID@">
<summary>
 ID of the service to be performed 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.OutputSchemaCollection@">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.InputSchemaCollection@">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.ProviderID@">
<summary>
 ID of the service provider to be performed 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionClientStub.ServerInfo@">
<summary>
 Information of the servers/clusters that we tried use this distributed function upon.
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.ServerInfo">
<summary>
 Information of the servers/clusters that we tried use this distributed function upon.
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.ReqObject">
<summary>
 Request object (input)
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.ProviderID">
<summary>
 ID of the service provider to be performed 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.OutputSchemaCollection">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.InputSchemaCollection">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.FailoverPolicy">
<summary>
 Guid governs the behavior of failover 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.DomainID">
<summary>
 ID of the service to be performed 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.DistributionPolicy">
<summary>
 Guid governs which service endpoint(s) are selected to service the request. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.CompletionPolicy">
<summary>
 Guid governs the behavior of completion
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionClientStub.AggregationPolicy">
<summary>
 Guid governs how to aggregate multiple requests  
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionClientStub.GetServicePerformance">
<summary>
 Get the performance of the service
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionClientStub.GetServiceEndPoints">
<summary>
 Get a list of service endpoints
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionClientStub.ExecutorForClientStub(System.Int32,System.Object,System.Threading.CancellationToken,System.IObserver{System.Object})">
<summary>
 Pending Distributed Functions. 
 Execute a distributed function with a certain time budget. 
 The execution is an observer object. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionClientStub.ConstructAggregateAllPeers(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid,System.Guid[],System.Guid[])">
<summary>
 Helper function to contruct ClientStub
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionClientStub.Construct(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid,System.Guid[],System.Guid[])">
<summary>
 Helper function to contruct ClientStub
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionClientStub">
<summary>
 This class encapsulate a DistributedFunctionHolder for a remote function call. 
 The main reason of wrapping around DistributedFunctionHolder is capacity control (we can control 
 how many service call can be accepted per Distributed Function) 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderByLock.GetCount">
<summary>
 Information on how many threads can enter semaphore, and the total capacity of the semaphore 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderByLock.ExecuteWithTimebudget(System.Guid,System.Int32,System.Object,System.Threading.CancellationToken,System.IObserver{System.Object})">
<summary>
 Execute a distributed function with a certain time budget. 
 The execution is an observer object. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderByLock.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderByLock.Cancel">
<summary>
 Cancel all jobs related to this distributed function. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderByLock.CanDispose">
<summary>
 Can we dispose this job holder?
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionHolderByLock">
<summary>
 Distributed function holder 
 Govern the execution cycle of a distributed function. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderBySemaphore.GetCount">
<summary>
 Information on how many threads can enter semaphore, and the total capacity of the semaphore 
 Return 0, 0 if no capacity control is enforced. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderBySemaphore.ExecuteWithTimebudgetAndPerf(System.Guid,System.Int32,System.Object,Prajna.Service.SingleRequestPerformance,System.Threading.CancellationToken,System.IObserver{System.Object})">
<summary>
 Execute a distributed function with a certain time budget. 
 The execution is an observer object. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderBySemaphore.ExecuteWithTimebudget(System.Guid,System.Int32,System.Object,System.Threading.CancellationToken,System.IObserver{System.Object})">
<summary>
 Execute a distributed function with a certain time budget. 
 The execution is an observer object. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderBySemaphore.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderBySemaphore.Cancel">
<summary>
 Cancel all jobs related to this distributed function. 
 ctsStatus will be 1 or higher after Cancel is called. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderBySemaphore.CanDispose">
<summary>
 Can we dispose this job holder?
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionHolderBySemaphore">
<summary>
 Distributed function holder 
 Govern the execution cycle of a distributed function. 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionHolderImporter">
<summary>
 Option for DistributedFunctionHolder with a string to hold information on why fails to find
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderRef.GetCount">
<summary>
 Get number of jobs that can be executed by the job holder and capacity
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderRef.ExecuteWithTimebudgetAndPerf``1(System.Guid,System.Int32,``0,Prajna.Service.SingleRequestPerformance,System.Threading.CancellationToken,System.IObserver{System.Object})">
<summary>
 Execute a distributed function with a certain time budget. 
 The execution is an observer object. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderRef.ExecuteWithTimebudget``1(System.Guid,System.Int32,``0,System.Threading.CancellationToken,System.IObserver{System.Object})">
<summary>
 Execute a distributed function with a certain time budget. 
 The execution is an observer object. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderRef.System-IDisposable-Dispose">
<summary>
 Close All Active Connection, to be called when the program gets shutdown.
 Close All Active Connection, to be called when the program gets shutdown.
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionHolderRef.Cancel">
<summary>
 Cancel all jobs related to this distributed function. 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionHolderRef">
<summary>
 A DistributedFunctionHolder can be reference with multiple schema (e.g., different input/output coding type, etc..)
 DistributedFunctionHolderRef allows reference counting on the DistributedFunctionHolder. 
 When the reference count goes to zero, the enclosed DistributedFunctionHolder can be deferenced. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionID.SchemaOut@">
<summary>
 Guid of the output schema
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionID.SchemaIn@">
<summary>
 Guid of the input schema
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionID.DomainID@">
<summary>
 Guid of the domain 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionID.ProviderID@">
<summary>
 Guid of the provider
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionID.SchemaOut">
<summary>
 Guid of the output schema
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionID.SchemaIn">
<summary>
 Guid of the input schema
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionID.ProviderID">
<summary>
 Guid of the provider
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionID.DomainID">
<summary>
 Guid of the domain 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionID">
<summary>
 A registered distributed function
 A disposing interface, when called
 Identity of a distributed function
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionPerformance.NumValidOperations">
<summary>
 Number of valid operation completed
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionPerformance.NumOperations">
<summary>
 Number of operation queued
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionPerformance.RegisterStart(System.Guid)">
<summary>
 This function when the timed operation starts
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionPerformance.RegisterEnd(System.Guid,System.Boolean)">
<summary>
 This function is called when the timed operation ends. bSuccess=true, operation completes. bSuccess=false, operation fails (timeout), and is not timed. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionPerformance.GetAvgOperationTime">
<summary>
 average operation time in milliseconds. 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionPerformance">
<summary>
 DistributedFunctionPerformance provides a performance statistics instance for the underlying operation. 
 Whenever a request is queued, a timestamp is registered in the class. We will wait for the 
 operation to complete to unqueue the request, and register a finished timestamp of the request. 
 From both, we can calculate the timespan that the request complete, and compute execution statistics. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionProvider.PrivateID@">
<summary>
 Private ID of the provider, the service provider should use this ID to register for service 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionProvider.PublicID@">
<summary>
 Public ID of the provider, the consumer will use this to reference the provider to be used. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionProvider.Email@">
<summary>
 Name of the provider 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionProvider.Institution@">
<summary>
 Name of the provider 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionProvider.Name@">
<summary>
 Name of the provider 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionProvider.Version@">
<summary>
 Provider version information, in a.b.c.d. Each of a, b, c, d should be from 0..255, and a should be from 0 to 255 the provider version is represented as an unsigned integer. 
 Version should be comparable 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.VersionString(System.String)">
<summary>
 Use a string of &quot;a.b.c.d&quot; to express the versin information
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Version(System.UInt32)">
<summary>
 Provider version information, in a.b.c.d. Each of a, b, c, d should be from 0..255, and a should be from 0 to 255 the provider version is represented as an unsigned integer. 
 Version should be comparable 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.PublicID(System.Guid)">
<summary>
 Public ID of the provider, the consumer will use this to reference the provider to be used. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.PrivateID(System.Guid)">
<summary>
 Private ID of the provider, the service provider should use this ID to register for service 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Name(System.String)">
<summary>
 Name of the provider 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Institution(System.String)">
<summary>
 Name of the provider 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Email(System.String)">
<summary>
 Name of the provider 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.VersionString">
<summary>
 Use a string of &quot;a.b.c.d&quot; to express the versin information
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Version">
<summary>
 Provider version information, in a.b.c.d. Each of a, b, c, d should be from 0..255, and a should be from 0 to 255 the provider version is represented as an unsigned integer. 
 Version should be comparable 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.PublicID">
<summary>
 Public ID of the provider, the consumer will use this to reference the provider to be used. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.PrivateID">
<summary>
 Private ID of the provider, the service provider should use this ID to register for service 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Name">
<summary>
 Name of the provider 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Institution">
<summary>
 Name of the provider 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionProvider.Email">
<summary>
 Name of the provider 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionProvider">
<summary>
 Infromation of distributed Function Provider 
 To use distributed function, 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionServices.StatisticsPeriodInSecond@">
<summary>
 Keep statistics of most recent certain seconds worth of requests
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionServices.StatisticsCollection@">
<summary>
 Statistics Queue holds statistics of the request that is served. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionServices.SecondaryServiceQueue@">
<summary>
 Service Queue holds request to be processed.
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionServices.PrimaryQueue@">
<summary>
 Primary Queue holds all services, it indicates the SecondaryServiceQueue that needs to be looked at. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionServices.TimeOutTicks@">
<summary>
 Timeout value, in ticks 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.TimeOutTicks(System.Int64)">
<summary>
 Timeout value, in ticks 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.StatisticsPeriodInSecond(System.Int32)">
<summary>
 Keep statistics of most recent certain seconds worth of requests
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.TimeOutTicks">
<summary>
 Timeout value, in ticks 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.StatisticsPeriodInSecond">
<summary>
 Keep statistics of most recent certain seconds worth of requests
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.StatisticsCollection">
<summary>
 Statistics Queue holds statistics of the request that is served. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.SecondaryServiceQueue">
<summary>
 Service Queue holds request to be processed.
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionServices.PrimaryQueue">
<summary>
 Primary Queue holds all services, it indicates the SecondaryServiceQueue that needs to be looked at. 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionServices">
<summary>
 This class services the request of distributed function. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.RediscoverConnectedClientEachExecution@">
<summary>
 If true, every execution, the imported function will attempt to discover containers (connected ServiceEndpoints) which export the current function. 
 This is a better behavior, however, there is a cost of 4 concurrent dictionary lookup everytime an imported function executes.
 The cost may be justifable as each imported function execution involves network anyway.  
 If false, the discover of connected ServiceEndpoints only happens at the time of function import. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.ExportedCollections@">
<summary>
 Collection of exported distributed functions, indexed by providerID, domainID, schemaIn and schemaOut
 This set is used 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.ProviderCollectionByPublicID@">
<summary>
 Convert public ID to provider
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.ProviderCollection@">
<summary>
 Collection of providers 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.DefaultSerializerTag@">
<summary>
 Default tag for the codec
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.Current@">
<summary>
 Access the common DistributedFunctionStore for the address space. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.ExportedServerCollection@">
<summary>
 Hold all servers that we expect the registered distributed function to be called from
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.CurrentProviderPublicID@">
<summary>
 Current provider, public ID
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.DefaultImportProviderID@">
<summary>
 Default Provider used for import (default = all provider ) 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.CurrentProviderID@">
<summary>
 Current provider, private ID
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStore.ConcurrentCapacity@">
<summary>
 A collection of all distributed stores 
 Capacity of the DistributedFunctionStore
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.RediscoverConnectedClientEachExecution(System.Boolean)">
<summary>
 If true, every execution, the imported function will attempt to discover containers (connected ServiceEndpoints) which export the current function. 
 This is a better behavior, however, there is a cost of 4 concurrent dictionary lookup everytime an imported function executes.
 The cost may be justifable as each imported function execution involves network anyway.  
 If false, the discover of connected ServiceEndpoints only happens at the time of function import. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.DefaultSerializerTag(Prajna.Service.DefaultSerializerForDistributedFunction)">
<summary>
 Default tag for the codec
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.DefaultImportProviderID(System.Guid)">
<summary>
 Default Provider used for import (default = all provider ) 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.CurrentProviderPublicID(System.Guid)">
<summary>
 Current provider, public ID
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.CurrentProviderID(System.Guid)">
<summary>
 Current provider, private ID
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ConcurrentCapacity(System.Int32)">
<summary>
 A collection of all distributed stores 
 Capacity of the DistributedFunctionStore
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.RediscoverConnectedClientEachExecution">
<summary>
 If true, every execution, the imported function will attempt to discover containers (connected ServiceEndpoints) which export the current function. 
 This is a better behavior, however, there is a cost of 4 concurrent dictionary lookup everytime an imported function executes.
 The cost may be justifable as each imported function execution involves network anyway.  
 If false, the discover of connected ServiceEndpoints only happens at the time of function import. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ProviderCollectionByPublicID">
<summary>
 Convert public ID to provider
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ProviderCollection">
<summary>
 Collection of providers 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ParseDistributedFunctionCrossBar">
<summary>
 Parser for Distributed Function (at Daemon)
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ParseDistributedFunction">
<summary>
 Parser for Distributed Function
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ExportedServerCollection">
<summary>
 Hold all servers that we expect the registered distributed function to be called from
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ExportedCollections">
<summary>
 Collection of exported distributed functions, indexed by providerID, domainID, schemaIn and schemaOut
 This set is used 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.DisconnectProcessor">
<summary>
 Should fail all distributed function to run from that client. 
 Should deregister all distributed function from that client
 Exeption is thrown for FailedRegister out of band, which may crash the program (which is fine, the user&apos;s distributed function will not work)
 Disconnect Processor 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.DefaultSerializerTag">
<summary>
 Default tag for the codec
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.DefaultImportProviderID">
<summary>
 Default Provider used for import (default = all provider ) 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.CurrentProviderPublicID">
<summary>
 Current provider, public ID
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.CurrentProviderID">
<summary>
 Current provider, private ID
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.Current">
<summary>
 Access the common DistributedFunctionStore for the address space. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStore.ConcurrentCapacity">
<summary>
 A collection of all distributed stores 
 Capacity of the DistributedFunctionStore
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.Unregister(System.Guid,System.Guid,System.Guid,System.Guid)">
<summary>
 Unregister a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportUnitActionLocal(System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportUnitAction(System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportUnitAction(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportSequenceFunction``1(System.String)">
<summary>
 Try import a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportSequenceFunction``1(System.String,System.Int32)">
<summary>
 Raise exception
 Try import a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportSequenceFunction``1(Prajna.Service.ContractServerInfoLocal,System.String,System.Int32)">
<summary>
 Try import a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportSequenceFunction``2(System.String)">
<summary>
 Try import a function sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportSequenceFunction``2(System.String,System.Int32)">
<summary>
 Raise exception
 Try import a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportSequenceFunction``2(Prajna.Service.ContractServerInfoLocal,System.String,System.Int32)">
<summary>
 Try import a function to execute results in a data sequence  
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportFunctionLocal``2(System.String)">
<summary>
 Try import a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportFunctionLocal``1(System.String)">
<summary>
 Try import a function with no input parameter
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportFunction``2(System.String)">
<summary>
 Try import a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportFunction``2(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportFunction``1(System.String)">
<summary>
 Try import a function with no input parameter
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportFunction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import a function with no input parameter
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportActionLocal``1(System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportAction``1(System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryImportAction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindUnitActionLocal(System.Guid,System.Guid)">
 <summary>
 Try find an action to execute without input and output parameter 
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindUnitAction(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid)">
 <summary>
 Try find an action to execute without input and output parameter 
 <param name="name"> name of the distributed function (for debug purpose only) </param>
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindSequenceFunction``1(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid)">
 <summary>
 Try find a function to execute
 <param name="name"> name of the distributed function (for debug purpose only) </param>
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindSequenceFunction``2(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid)">
 <summary>
 Try find a function to execute
 <param name="name"> name of the distributed function (for debug purpose only) </param>
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindInternalLocal(System.Guid,System.Guid,System.Guid,System.Guid)">
<summary>
 Import a particular action/function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindFunctionLocal``2(System.Guid,System.Guid)">
 <summary>
 Try find a function to execute
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindFunctionLocal``1(System.Guid,System.Guid)">
 <summary>
 Try find function to execute with no input parameter, but with output. 
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindFunction``2(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid)">
 <summary>
 Try find a function to execute
 <param name="name"> name of the distributed function (for debug purpose only) </param>
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindFunction``1(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid)">
 <summary>
 Try find function to execute with no input parameter, but with output. 
 <param name="name"> name of the distributed function (for debug purpose only) </param>
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindActionLocal``1(System.Guid,System.Guid)">
 <summary>
 Try find an action to execute without input and output parameter 
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.TryFindAction``1(Prajna.Service.ContractServerInfoLocal,System.String,System.Guid,System.Guid)">
 <summary>
 Try find an action to execute without input and output parameter 
 Note that if there are multiple action with the same domain name, but with variation of the scema, the action will bind 
 to the any remote service endpoint that matches at least one input/output schema pair 
 <param name="name"> name of the distributed function (for debug purpose only) </param>
 <param name="publicID"> public ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.SendExceptionWithJobID(Prajna.Core.NetworkCommandQueue,System.Guid,Prajna.Core.ControllerVerb,System.Exception)">
<summary>
 SendException in which the exception can be linked with a particular job
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.SendException(Prajna.Core.NetworkCommandQueue,Prajna.Core.ControllerVerb,System.Exception)">
<summary>
 SendException 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.SendAggregateException``1(Prajna.Core.NetworkCommandQueue,Prajna.Core.ControllerVerb,System.Collections.Concurrent.ConcurrentDictionary{``0,System.Exception})">
<summary>
 SendException 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterUnitAction(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>
 Register an action without input and output parameter.
 <param name="name"> name of the action </param>
 <param name="act"> An action to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterUnitAction(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.Boolean)">
 <summary>
 Register an action without input and output parameter. 
 <param name="name"> name of the action </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="act"> An action of type to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterProvider(Prajna.Service.DistributedFunctionProvider)">
<summary>
 Register a provider, use this provider as the default. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterInternal(System.Guid,System.Guid,System.Guid,System.Guid,Prajna.Service.DistributedFunctionHolderBySemaphore,System.Boolean)">
 <summary>
 Export an action or function object. 
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="act"> An action of type Action&lt;'T> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterFunction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Register a function Func&lt;'TResult>
 <param name="name"> name of the function </param>
 <param name="func"> A function of type Func&lt;'TResult> to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterFunction``1(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.Boolean)">
 <summary>
 Register a function Func&lt;'TResult>
 <param name="name"> name of the action </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterFunction``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>
 Register as a function Func&lt;'T,'TResult>
 <param name="name"> name of the action </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterFunction``2(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Boolean)">
 <summary>
 Register as a function Func&lt;'T,'TResult>
 <param name="name"> name of the action </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterAction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>
 Register an action Action&lt;'T>
 <param name="name"> name of the action, for debugging purpose </param>
 <param name="act"> An action of type Action&lt;'T> to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.RegisterAction``1(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Boolean)">
 <summary>
 Register an action Action&lt;'T>
 <param name="name"> name of the action, for debugging purpose </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="act"> An action of type Action&lt;'T> to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.NumberOfRegistered">
<summary>
 Number of registered distributed functions. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.NullifyProvider">
<summary>
 force other function to register its own provider
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.InstallDefaultSerializer``1">
<summary>
 Install Default Serializer
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.InstallCustomizedSerializer``1(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.IO.Stream},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.IO.Stream,``0},System.Boolean)">
<summary>
 Install Serializer, only one serializer should be installed per type. 
 User should call this to supply its own serializer/deserializer if desired. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceUnitAction(System.String)">
<summary>
 Get performance of the unit action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceUnitAction(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of the unit action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceSequenceFunction``1(System.String)">
<summary>
 Get performance of a function to execute results in a data sequence  
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceSequenceFunction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceSequenceFunction``2(System.String)">
<summary>
 Get performance of a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceSequenceFunction``2(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of a function to execute results in a data sequence 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceFunction``2(System.String)">
<summary>
 Get performance of a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceFunction``2(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceFunction``1(System.String)">
<summary>
 Get performance of a function with no input parameter
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceFunction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of a function with no input parameter
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceAction``1(System.String)">
<summary>
 Get performance of imported action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetPerformanceAction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of imported action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.GetAllExportedFunctions">
<summary>
 Get all current distributed function in a list
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.ExportToOneServer(System.Int64)">
<summary>
 Export function to peers 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.ExportTo(Prajna.Service.ContractServersInfo)">
<summary>
 Allow the registered distributed function to be called by a set of servers/server groups
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.ExceptionWhenReply(System.Guid,System.Int64,System.Exception)">
<summary>
 Exception during reply 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.ErrorAt(Prajna.Core.NetworkCommandQueue,System.Exception)">
<summary>
 Operations to be executed when an unrecoverable error occurs 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.DoParseDistributedFunction(Prajna.Core.NetworkCommandQueue,Prajna.Core.NetworkCommand)">
<summary>
 Parser for Distributed Function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.DoDisconnect(Prajna.Core.NetworkCommandQueue)">
<summary>
 Disconnect Processor 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStore.CleanUp(System.Int32)">
<summary>
 Clean Up 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionStore">
<summary>
 DistributedFunctionStore provides a central location for handling distributed functions. 
</summary>
</member>
<member name="F:Prajna.Service.DistributedFunctionStoreAsync.Current@">
<summary>
 Access the common DistributedFunctionStore for the address space. 
</summary>
</member>
<member name="P:Prajna.Service.DistributedFunctionStoreAsync.Current">
<summary>
 Access the common DistributedFunctionStore for the address space. 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportUnitActionLocal(System.String)">
<summary>
 Try import an action
 The return signature is () -&gt; Task
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportUnitAction(System.String)">
<summary>
 Try import an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportUnitAction(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import an action 
 The return signature is () -&gt; Task
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportFunctionLocal``2(System.String)">
<summary>
 Try import an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportFunctionLocal``1(System.String)">
<summary>
 Try import a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportFunction``2(System.String)">
<summary>
 Try import a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportFunction``2(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import a function 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportFunction``1(System.String)">
<summary>
 Try import a function 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportFunction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportActionLocal``1(System.String)">
<summary>
 Try import an action
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportAction``1(System.Object)">
<summary>
 Try import an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.TryImportAction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Try import an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterUnitAction(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task})">
 <summary>
 Register an action without input and output parameter.
 <param name="name"> name of the action </param>
 <param name="act"> An action to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterUnitAction(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task},System.Boolean)">
 <summary>
 Register a task to be executed when called upon. 
 <param name="name"> name of the action </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="act"> An action of type to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterFunction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}})">
 <summary>
 Register a function Func&lt;'TResult>
 <param name="name"> name of the function </param>
 <param name="func"> A function of type Func&lt;'TResult> to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterFunction``1(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}},System.Boolean)">
 <summary>
 Register a function Func&lt;'TResult>
 <param name="name"> name of the action </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterFunction``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
 <summary>
 Register as a function Func&lt;'T,'TResult>
 <param name="name"> name of the action </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterFunction``2(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},System.Boolean)">
 <summary>
 Register as a function Func&lt;'T,Task&lt;'TResult>>
 <param name="name"> name of the action </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterAction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task})">
 <summary>
 Register an action Action&lt;'T>
 <param name="name"> name of the action, for debugging purpose </param>
 <param name="act"> An action of type Action&lt;'T> to be registered </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.RegisterAction``1(System.String,System.Int32,System.Guid,System.Guid,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task},System.Boolean)">
 <summary>
 Register an action Action&lt;'T>
 <param name="name"> name of the action, for debugging purpose </param>
 <param name="capacity"> Concurrency level, if larger than 1, multiple action can be executed at the same time, if less than or equal to 0, no capacity control is exercised </param>
 <param name="privateID"> private ID of the provider </param>
 <param name="domainID"> ID of the particular function/action </param>
 <param name="act"> An action of type Action&lt;'T> to be registered </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceUnitAction(System.String)">
<summary>
 Get performance of an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceUnitAction(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceFunction``2(System.String)">
<summary>
 Get performance of a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceFunction``2(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceFunction``1(System.String)">
<summary>
 Get performance of a function
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceFunction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of a function 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceAction``1(System.String)">
<summary>
 Get performance of an action 
</summary>
</member>
<member name="M:Prajna.Service.DistributedFunctionStoreAsync.GetPerformanceAction``1(Prajna.Service.ContractServerInfoLocal,System.String)">
<summary>
 Get performance of an action 
</summary>
</member>
<member name="T:Prajna.Service.DistributedFunctionStoreAsync">
<summary>
 Distributed function store with Async interface. 
</summary>
</member>
<member name="F:Prajna.Service.DistributionPolicyCollection.DistributionPolicyDefaultGuid@">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="F:Prajna.Service.DistributionPolicyCollection.DistributionAllGuid@">
<summary>
 Guid of policy to select all service endpoint
</summary>
</member>
<member name="F:Prajna.Service.DistributionPolicyCollection.DistributionRandomGuid@">
<summary>
 Guid of policy to select a service endpoint in a roundrobin way
</summary>
</member>
<member name="F:Prajna.Service.DistributionPolicyCollection.DistributionRoundRobinGuid@">
<summary>
 Guid of policy to roundrobinly select a service endpoint
</summary>
</member>
<member name="F:Prajna.Service.DistributionPolicyCollection.DistributionToFastestGuid@">
<summary>
 Guid of policy to select the backend with the lowest expected latency to serve the request 
</summary>
</member>
<member name="F:Prajna.Service.DistributionPolicyCollection.distributionPolicyCollection">
 <summary> 
 Collection of distribution Policy
 </summary> 
</member>
<member name="P:Prajna.Service.DistributionPolicyCollection.DistributionPolicyDefaultGuid(System.Guid)">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.DistributionPolicyCollection.DistributionToFastestGuid">
<summary>
 Guid of policy to select the backend with the lowest expected latency to serve the request 
</summary>
</member>
<member name="P:Prajna.Service.DistributionPolicyCollection.DistributionRoundRobinGuid">
<summary>
 Guid of policy to roundrobinly select a service endpoint
</summary>
</member>
<member name="P:Prajna.Service.DistributionPolicyCollection.DistributionRandomGuid">
<summary>
 Guid of policy to select a service endpoint in a roundrobin way
</summary>
</member>
<member name="P:Prajna.Service.DistributionPolicyCollection.DistributionPolicyDefaultGuid">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.DistributionPolicyCollection.DistributionAllGuid">
<summary>
 Guid of policy to select all service endpoint
</summary>
</member>
<member name="M:Prajna.Service.DistributionPolicyCollection.Register(System.Guid,System.String,System.Func{Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64[]})">
<summary>
 Guid of policy to randomly select a service endpoint
 Register additional distribution policy 
</summary>
</member>
<member name="M:Prajna.Service.DistributionPolicyCollection.FindDistributionPolicy(System.Guid)">
<summary>
 Find the distribution policy, if the request distribution policy doesn&apos;t exist, the policy DistributionToFastestBackend will be applied. 
</summary>
</member>
<member name="M:Prajna.Service.DistributionPolicyCollection.DistributionToFastest(Prajna.Service.OneRemoteDistributedFunctionRequest)">
<summary>
 Return a service endpoint with the lowest ExpectedLatencyInMS
</summary>
</member>
<member name="M:Prajna.Service.DistributionPolicyCollection.DistributionRoundRobin(Prajna.Service.OneRemoteDistributedFunctionRequest)">
<summary>
 Return a service endpoint using TotalQuery to determine which service endpoint will service the requests. 
 Note that if multiple requests are issued at almost the same time, it is possible that a service endpoint
 will receive multiple request 
</summary>
</member>
<member name="M:Prajna.Service.DistributionPolicyCollection.DistributionRandom(Prajna.Service.OneRemoteDistributedFunctionRequest)">
<summary>
 Return a random service endpoint 
</summary>
</member>
<member name="M:Prajna.Service.DistributionPolicyCollection.DistributionAll(Prajna.Service.OneRemoteDistributedFunctionRequest)">
<summary>
 Return a random service endpoint 
</summary>
</member>
<member name="T:Prajna.Service.DistributionPolicyCollection">
<summary>
 Collection of distribution policy for distributed function
</summary>
</member>
<member name="T:Prajna.Service.DistributionPolicyFunction">
 <summary> 
 A distribution Policy delegate select 1 to N backend to service a particular request. 
 Return:
     1 to N remote signature that is used to serve the current request. 
 </summary>
</member>
<member name="T:Prajna.Service.FailoverExecution">
<summary>
 How distributed function deal with failover. 
</summary>
</member>
<member name="F:Prajna.Service.FailoverPolicyCollection.FailoverPolicyDefaultGuid@">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="F:Prajna.Service.FailoverPolicyCollection.FailoverByCancelGuid@">
<summary>
 Guid of policy to cancel all distributed function when any service endpoint fails with exception
</summary>
</member>
<member name="F:Prajna.Service.FailoverPolicyCollection.FailoverRerunDistributionGuid@">
<summary>
 Guid of policy to re-run Distribution policy when any service endpoint fails 
</summary>
</member>
<member name="F:Prajna.Service.FailoverPolicyCollection.failoverPolicyCollection">
 <summary> 
 Collection of distribution Policy
 </summary> 
</member>
<member name="P:Prajna.Service.FailoverPolicyCollection.FailoverPolicyDefaultGuid(System.Guid)">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.FailoverPolicyCollection.FailoverRerunDistributionGuid">
<summary>
 Guid of policy to re-run Distribution policy when any service endpoint fails 
</summary>
</member>
<member name="P:Prajna.Service.FailoverPolicyCollection.FailoverPolicyDefaultGuid">
<summary>
 Guid of the default distribution policy 
</summary>
</member>
<member name="P:Prajna.Service.FailoverPolicyCollection.FailoverByCancelGuid">
<summary>
 Guid of policy to cancel all distributed function when any service endpoint fails with exception
</summary>
</member>
<member name="M:Prajna.Service.FailoverPolicyCollection.Register(System.Guid,System.String,System.Func{System.Tuple{Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64,System.Exception},Prajna.Service.FailoverExecution})">
<summary>
 Guid of policy to randomly select a service endpoint
 Register additional distribution policy 
</summary>
</member>
<member name="M:Prajna.Service.FailoverPolicyCollection.FindFailoverPolicy(System.Guid)">
<summary>
 Find the distribution policy, if the request distribution policy doesn&apos;t exist, the policy DistributionToFastestBackend will be applied. 
</summary>
</member>
<member name="M:Prajna.Service.FailoverPolicyCollection.FailoverRerunDistribution(Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64,System.Exception)">
<summary>
 Return a service endpoint with the lowest ExpectedLatencyInMS
</summary>
</member>
<member name="M:Prajna.Service.FailoverPolicyCollection.FailoverByCancel(Prajna.Service.OneRemoteDistributedFunctionRequest,System.Int64,System.Exception)">
<summary>
 Return a service endpoint with the lowest ExpectedLatencyInMS
</summary>
</member>
<member name="T:Prajna.Service.FailoverPolicyCollection">
<summary>
 Collection of distribution policy for distributed function
</summary>
</member>
<member name="T:Prajna.Service.FailoverPolicyFunction">
 <summary> 
 A failover policy delegate select 1 to N backend to re-service a particular request, whenever one request fails 
 Return:
     1 to N remote signature that is used to serve the current request. 
 </summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.CompletionFuncLazy@">
<summary>
 Completion Function 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.AggregationFuncLazy@">
<summary>
 Aggregation Function 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.FailoverFuncLazy@">
<summary>
 Failover policy function
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.DistributionFuncLazy@">
<summary>
 Distribution Function 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.TicksRequestTimeout@">
<summary>
 Timestamp that the request will timeout 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.TicksRequestReceived@">
<summary>
 Timestamp that the request is received. 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.CompletedSignatureCollections@">
<summary>
 Objects are sent to these locations. 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.SentSignatureCollections@">
<summary>
 We will register an outstanding request if SentSignatureCollections contains the network signature 
 Objects are sent to these locations. 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.ReqObjects@">
<summary>
 Request object (input)
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.FailoverPolicy@">
<summary>
 Guid governs the behavior of failover 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.AggregationPolicy@">
<summary>
 Guid governs how to aggregate multiple requests  
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.DistributionPolicy@">
<summary>
 Guid governs which service endpoint(s) are selected to service the request. 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.DomainID@">
<summary>
 ID of the service to be performed 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.OutputSchemaCollection@">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.InputSchemaCollection@">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.ProviderID@">
<summary>
 ID of the service provider to be performed 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.JobID@">
<summary>
 JobID 
</summary>
</member>
<member name="F:Prajna.Service.OneRemoteDistributedFunctionRequest.ctsSource">
<summary>
 Cancellation Token source 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.TicksRequestTimeout(System.Int64)">
<summary>
 Timestamp that the request will timeout 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.ProviderID(System.Guid)">
<summary>
 ID of the service provider to be performed 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.OutputSchemaCollection(System.Guid[])">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.InputSchemaCollection(System.Guid[])">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.FailoverPolicy(System.Guid)">
<summary>
 Guid governs the behavior of failover 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.DomainID(System.Guid)">
<summary>
 ID of the service to be performed 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.AggregationPolicy(System.Guid)">
<summary>
 Guid governs how to aggregate multiple requests  
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.Token">
<summary>
 Cancellation Token
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.TicksRequestTimeout">
<summary>
 Timestamp that the request will timeout 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.TicksRequestReceived">
<summary>
 Timestamp that the request is received. 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.SentSignatureCollections">
<summary>
 We will register an outstanding request if SentSignatureCollections contains the network signature 
 Objects are sent to these locations. 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.ReqObjects">
<summary>
 Request object (input)
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.ProviderID">
<summary>
 ID of the service provider to be performed 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.OutputSchemaCollection">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.JobID">
<summary>
 JobID 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.InputSchemaCollection">
<summary>
 ID that represents the coding of the input 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.FailoverPolicy">
<summary>
 Guid governs the behavior of failover 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.FailoverFuncLazy">
<summary>
 Failover policy function
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.DomainID">
<summary>
 ID of the service to be performed 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.DistributionPolicy">
<summary>
 Guid governs which service endpoint(s) are selected to service the request. 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.DistributionFuncLazy">
<summary>
 Distribution Function 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.CompletionFuncLazy">
<summary>
 Completion Function 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.CompletedSignatureCollections">
<summary>
 Objects are sent to these locations. 
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.AggregationPolicy">
<summary>
 Guid governs how to aggregate multiple requests  
</summary>
</member>
<member name="P:Prajna.Service.OneRemoteDistributedFunctionRequest.AggregationFuncLazy">
<summary>
 Aggregation Function 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.SentSignatureIsEmpty">
<summary>
 Are there any requests to peers still outstanding?
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.SendTo(System.Int64[])">
<summary>
 Send to a certain remote service endpoints
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.SendCancellationToServiceEndpoints">
<summary>
 Send cancellation to live service endpoint
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.ReplyActionOnNext(System.Object)">
<summary>
 Passback reply 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.ReplyActionOnCompleted">
<summary>
 Passback OnComplete
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.OnRemoteReply(System.Int64,System.Object,Prajna.Service.SingleRequestPerformance)">
<summary>
 On receiving a reply 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.OnRemoteCompletion(System.Int64)">
<summary>
 On receiving a completion from a certain peer
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.GetReplySchema(System.Int64)">
<summary>
 Get reply schema
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.FunctionOnStart">
<summary>
 Execued by App when the function starts
 For failing to start (return false), the caller will remove and dispose the resource associated with the 
 OneRemoteDistributedFunctionRequest
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.FunctionOnNext(System.Object)">
<summary>
 Execued by App when the function receives a new object 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.FunctionOnError(System.Exception)">
<summary>
 Execued by App when the function encounter an error 
 Note: external function should inform that the function is failing via OnError( ex ) or Cancel( ex ), 
 which will call FunctionOnError, but only once. 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.FunctionOnCompleted">
<summary>
 Execued by App when the function does not have additional input variable
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.FailedCommon(System.Int64)">
<summary>
 Common processing of a failed endpoint
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.Failed(System.Int64,System.Exception)">
<summary>
 A certain service endpoint has failed with an exception. 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.Failed(System.Int64)">
<summary>
 A certain queue has failed 
 Need to trigger failover policy 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.ExecuteFailoverPollicy(System.Int64,System.Exception)">
<summary>
 Process failover logic 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.Dispose(System.Boolean)">
<summary>
 Internal implementation of Dispose
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.CancelledByExternalToken">
<summary>
 External Cancellation
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.CancelAfter(System.Int32)">
<summary>
 Cancel after a certain time interval
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.Cancel(System.Exception)">
<summary>
 Cancel actions 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.CallbackOnCompletion">
<summary>
 resource will be disposed 
 On Completion. 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.CallbackForCancellation">
<summary>
 On Cancellation
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.BaseGetDistributionPolicySignatures">
<summary>
 Get Distribution function signatures
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.BaseFunctionOnStart">
<summary>
 Execued when the function starts
 For failing to start (return false), the caller will remove and dispose the resource associated with the 
 OneRemoteDistributedFunctionRequest
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.BaseFunctionOnNext(System.Object)">
<summary>
 Executed when the function receives a new object 
</summary>
</member>
<member name="M:Prajna.Service.OneRemoteDistributedFunctionRequest.BaseExecuteDistributionPolicy">
<summary>
 Execute Distribution function
</summary>
</member>
<member name="T:Prajna.Service.OneRemoteDistributedFunctionRequest">
<summary>
 This class encapsulate a single distributed function request. 
</summary>
</member>
<member name="M:Prajna.Service.RegisteredDistributedFunction.GetSchemas">
<summary>
 Get all schemas in the form of a provideID, domainID, schemaInID, schemaOutID tuple of the particular distributed function
 These schemas can be used by a remote App (potentially on different platform) to invoke the distributed function 
</summary>
</member>
<member name="M:Prajna.Service.RegisteredDistributedFunction.System-IDisposable-Dispose">
<summary>
 To be extended
</summary>
</member>
<member name="T:Prajna.Service.RegisteredDistributedFunction">
<summary>
 Representing a single registered distributed function. Two key functions of the RegisteredDistributedFunction class are:
 1. Implement IDisposable interface, when disposed, the registered function no longer respond to the distributed Function call. 
    Note if registered distributed function goes out of scope, the disposeFunc is called with (false) input, 
 2. GetSchemas, return a 4-tuple that identified the provider, domain, schemaIn and schemaOut of the function registered. 
</summary>
</member>
<member name="T:Prajna.Service.RegisteredDistributedFunctionMultiple">
<summary>
 Representing multiple registered distributed function
</summary>
</member>
<member name="T:Prajna.Service.RegisteredDistributedFunctionOne">
<summary>
 Representing a single registered distributed function
</summary>
</member>
<member name="P:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore.ImportedCollections">
<summary>
 Collection of imported distributed functions, indexed by providerID, domainID, schemaIn and schemaOut
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore.TryDiscoverConnectedClients(System.Guid,System.Guid,System.Guid,System.Guid)">
<summary>
 Find an array of network signatures that are associated with distributed function with 
 signature publicID, domainID, schemaIn, schemaOut. 
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore.Register(System.Guid,System.Guid,System.Guid,System.Guid,System.Int64)">
<summary>
 Register a remote function service by a four tuple
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore.ReceiveErrorAt(System.Int64,System.Exception)">
<summary>
 A certain provider has an unrecoverable error, we will need to unregister all distributed function by that provider. 
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore.ErrorAt(System.Int64,System.Exception)">
<summary>
 A certain provider has an unrecoverable error, we will need to unregister all distributed function by that provider. 
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore.Disconnect(System.Int64)">
<summary>
 A certain provider has disconnected, we will need to unregister all distributed function serviced by that provider.
</summary>
</member>
<member name="T:Prajna.Service.RemoteDistributedFunctionProviderSignatureStore">
<summary>
 This class store the signature of remote endpoints that are providing service. 
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionRequestStore.RequestException(System.Guid,System.Int64,System.Exception)">
<summary>
 On exception (when a exception has been received) . 
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionRequestStore.OnNext(System.Guid,System.Int64,System.Object,Prajna.Service.SingleRequestPerformance)">
<summary>
 OnNext (when a reply has been received ) 
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionRequestStore.OnDisconnect(System.Int64)">
<summary>
 Called when a client disconnects.
</summary>
</member>
<member name="M:Prajna.Service.RemoteDistributedFunctionRequestStore.OnCompletion(System.Guid,System.Int64)">
<summary>
 To perform the statistics
 OnNext (when a reply has been received ) 
</summary>
</member>
<member name="T:Prajna.Service.RemoteDistributedFunctionRequestStore">
<summary>
 This class store all distributed function request that is pending of execution
</summary>
</member>
<member name="F:Prajna.Service.RemoteFunctionExecutor.Current@">
<summary>
 Access the common DistributedFunctionStore for the address space. 
</summary>
</member>
<member name="F:Prajna.Service.RemoteFunctionExecutor.CheckForDisposalIntervalInMilliseconds@">
<summary>
 Interval to check for disposal
</summary>
</member>
<member name="F:Prajna.Service.RemoteFunctionExecutor.ForceDisposing@">
<summary>
 After time expires, whether we will forcefully disposing the DistributedFunctionHolder 
</summary>
</member>
<member name="F:Prajna.Service.RemoteFunctionExecutor.MaxWaitTimeForDisposingInMilliseconds@">
<summary>
 Maximum wait to try to dispose object that are still waiting 
</summary>
</member>
<member name="F:Prajna.Service.RemoteFunctionExecutor.inExecutionCollection">
<summary>
 A collection of remote function that is being executed 
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.MaxWaitTimeForDisposingInMilliseconds(System.Int64)">
<summary>
 Maximum wait to try to dispose object that are still waiting 
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.ForceDisposing(System.Boolean)">
<summary>
 After time expires, whether we will forcefully disposing the DistributedFunctionHolder 
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.CheckForDisposalIntervalInMilliseconds(System.Int32)">
<summary>
 Interval to check for disposal
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.MaxWaitTimeForDisposingInMilliseconds">
<summary>
 Maximum wait to try to dispose object that are still waiting 
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.ForceDisposing">
<summary>
 After time expires, whether we will forcefully disposing the DistributedFunctionHolder 
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.Current">
<summary>
 Access the common DistributedFunctionStore for the address space. 
</summary>
</member>
<member name="P:Prajna.Service.RemoteFunctionExecutor.CheckForDisposalIntervalInMilliseconds">
<summary>
 Interval to check for disposal
</summary>
</member>
<member name="M:Prajna.Service.RemoteFunctionExecutor.RegisterHolder(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prajna.Service.DistributedFunctionHolderImporter})">
<summary>
 Register a job, 
 return bool * holder, 
     true: a new job has been created
     false: a existing job holder with the same job ID exists
</summary>
</member>
<member name="M:Prajna.Service.RemoteFunctionExecutor.System-IDisposable-Dispose">
<summary>
 To be extended
</summary>
</member>
<member name="M:Prajna.Service.RemoteFunctionExecutor.CheckForDisposal(System.Object)">
<summary>
 Check whether job has stopped execution and can be disposed. 
</summary>
</member>
<member name="M:Prajna.Service.RemoteFunctionExecutor.Cancel(System.Guid)">
<summary>
 Cancel a job 
</summary>
</member>
<member name="T:Prajna.Service.RemoteFunctionExecutor">
<summary>
 Store that holds executed remote function 
</summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStopLocalInstance(System.String)">
<summary>
 Stop an Instance locally
</summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStopInstanceOnServers(Prajna.Service.ContractServersInfo,System.String)">
<summary>
 Stopping services on a set of servers
</summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStopInstanceOnCluster(Prajna.Core.Cluster,System.String)">
 <summary>
 Stopping Service on a group of remote nodes.
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStopInstance(System.String)">
 <summary>
 Stopping Service on a group of remote nodes.
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStartLocalInstanceWithParam``2(System.String,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Instance locally.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 Return: toStop (a Action can be called to terminate the current RoleInstance). 
         isRunning ( a Func that can be called to evaluate if the current RoleInstance is still running)
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStartInstanceWithParam``1(System.String,Prajna.Service.WorkerRoleInstanceStartParam,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStartInstanceOnServersWithParam``2(Prajna.Service.ContractServersInfo,System.String,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 serverInfo: information of the server 
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStartInstanceOnClusterWithParam``2(Prajna.Core.Cluster,System.String,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalStartInstance``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.RemoteInstance.InternalIsRunningLocalInstance(System.String)">
<summary>
 Is a local instance still running?
</summary>
</member>
<member name="T:Prajna.Service.RemoteInstance">
 <summary>
 Launching a PrajnaInstance on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart
 serviceInstance: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
         You must derive serviceInstance from WorkerRoleInstance
 PrajnaInstance share similar characteristics with Prajnaservice, with characteristics below.
 1. You can run Service on Azure VM or your own cluster in the data center. 
 2. You can host multiple worker role in a same remote program. 
 3. Service can interact (call each other) with each call being a function call. 
 4. You can perform Big data analytical tasks (map/filter/choose/collect, fold, map-reduce, sort, hash-join, cross-join, etc.) on data generated by Service
 5. You can start Service with a parameter. 
 6. You can track debug output (log, stderr, stdout) of the remote service. 
 But in addition, PrajnaInstance is 
 1. Initialied remotely (with a function that you have specified). As such, PrajnaInstance doesn't need to be serializable, and can contain heavy data element. 
 2. You may specify the number of thread to work on the PrajnaInstance (parameter specified in Start Parameter. 
 </summary>
</member>
<member name="M:Prajna.Service.RunningService.StopService">
 <summary>
 Attempt to stop service. After service is stopped, a continuation function is called. 
 contFunc: bool -> unit, called after service is stopped. true: service has been successfully stopped. 
                                                          false: timeout
 </summary>
</member>
<member name="M:Prajna.Service.RunningService.StartService(Microsoft.FSharp.Core.FSharpFunc{System.Boolean,Microsoft.FSharp.Core.Unit})">
 <summary>
 Start the service, when service completes, a continuation function is called. 
 contFunc: bool-> unit, called after service is initialized. true: if service succeeds to initialize
                                                             false: if service fails to initialize
 </summary>
</member>
<member name="T:Prajna.Service.SafeConcurrentDictionary">
<summary>
 Safe Remvoal of an entry of ConcurrentDictionary. 
</summary>
</member>
<member name="M:Prajna.Service.SchemaBinaryFormatterHelper`1.SchemaID">
<summary>
 Get a GUID that representing the coding of a type. Note that this binds to the 
 fullname of the type with assembly (AssemblyQualifiedName) so if the assembly 
 of the type changes, the schemaID will change. 
</summary>
</member>
<member name="T:Prajna.Service.SchemaBinaryFormatterHelper`1">
<summary>
 Helper class to generate schema ID
</summary>
</member>
<member name="M:Prajna.Service.SchemaJSonHelper`1.SchemaID">
<summary>
 Get a GUID that representing the coding of a type. Note that this binds to the 
 fullname of the type with assembly (AssemblyQualifiedName) so if the assembly 
 of the type changes, the schemaID will change. 
</summary>
</member>
<member name="M:Prajna.Service.SchemaJSonHelper`1.Decoder(System.IO.Stream)">
<summary>
 Wrap JSon stream 
</summary>
</member>
<member name="T:Prajna.Service.SchemaJSonHelper`1">
<summary>
 Helper class to generate schema ID
</summary>
</member>
<member name="M:Prajna.Service.SchemaPrajnaFormatterHelper`1.SchemaID">
<summary>
 Get a GUID that representing the coding of a type. Note that this binds to the
 fullname of the type with assembly (AssemblyQualifiedName) so if the assembly
 of the type changes, the schemaID will change.
</summary>
</member>
<member name="T:Prajna.Service.SchemaPrajnaFormatterHelper`1">
<summary>
 Helper class to generate schema ID
</summary>
</member>
<member name="M:Prajna.Service.Service.stopServiceOnCluster(Prajna.Core.Cluster,System.String)">
 <summary>
 Stopping Prajna Service on a group of remote nodes.
 serviceName: name of the service
 serviceClass: OnStart(), OnStop(), Run() call for the initiating of the service. 
 registeredDSets: each registered DSet has information on dsetName, dsetVersion, 
 </summary>
</member>
<member name="M:Prajna.Service.Service.stopService(System.String)">
 <summary>
 Stopping Prajna Service on a group of remote nodes.
 serviceName: name of the service
 serviceClass: OnStart(), OnStop(), Run() call for the initiating of the service. 
 registeredDSets: each registered DSet has information on dsetName, dsetVersion, 
 </summary>
</member>
<member name="M:Prajna.Service.Service.startServiceWithParam``1(System.String,Prajna.Service.WorkerRoleEntryPoint,``0)">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 </summary>
</member>
<member name="M:Prajna.Service.Service.startServiceOnClusterWithParam``1(Prajna.Core.Cluster,System.String,Prajna.Service.WorkerRoleEntryPoint,``0)">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 </summary>
</member>
<member name="M:Prajna.Service.Service.startServiceOnCluster(Prajna.Core.Cluster,System.String,Prajna.Service.WorkerRoleEntryPoint)">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 </summary>
</member>
<member name="M:Prajna.Service.Service.startServiceLocallyWithParam``1(System.String,Prajna.Service.WorkerRoleEntryPoint,``0)">
 <summary>
 Launching Prajna Service locally, with a callback function that can be used to stop the current service. 
 This is mainly used for local debug of service before deployment. 
 serviceName: name of the serivce
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 param: parameter to be called by OnStart
 Return: toStop(unit->unit), a function that can be called to stop the current service. 
 </summary>
</member>
<member name="M:Prajna.Service.Service.startServiceLocally(System.String,Prajna.Service.WorkerRoleEntryPoint)">
 <summary>
 Launching Prajna Service locally, with a callback function that can be used to stop the current service. 
 This is mainly used for local debug of service before deployment. 
 serviceName: name of the serivce
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 Return: toStop(unit->unit), a function that can be called to stop the current service. 
 </summary>
</member>
<member name="M:Prajna.Service.Service.startService(System.String,Prajna.Service.WorkerRoleEntryPoint)">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 </summary>
</member>
<member name="T:Prajna.Service.Service">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart
 serviceClass: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
 Service is very much like a Azure Woker Role. The core differences are:
 1. You can run Service on Azure VM or your own cluster in the data center. 
 2. You can host multiple worker role in a same remote program. 
 3. Service can interact (call each other) with each call being a function call. 
 4. You can perform Big data analytical tasks (map/filter/choose/collect, fold, map-reduce, sort, hash-join, cross-join, etc.) on data generated by Service
 5. You can start Service with a parameter. 
 6. You can track debug output (log, stderr, stdout) of the remote service. 
 </summary>
</member>
<member name="F:Prajna.Service.ServiceEndpointPerformance.ConstructFunc@">
<summary>
 A functional variable used to construct ServiceEndpointPerformance
</summary>
</member>
<member name="F:Prajna.Service.ServiceEndpointPerformance.ExpectedLatencyInMS@">
 <summary>
 If we send request to this Backend, the expected processing latency (in millisecond)
 It is calculated by avgNetworkRtt + avgProcessing + ( avgQueuePerSlot * itemsInQueue )
 </summary>
</member>
<member name="F:Prajna.Service.ServiceEndpointPerformance.DefaultExpectedLatencyInMS@">
<summary>
 Default Expected Latency value before a reply is received 
</summary>
</member>
<member name="F:Prajna.Service.ServiceEndpointPerformance.Curslots@">
<summary>
 Current number of request that is under service 
</summary>
</member>
<member name="F:Prajna.Service.ServiceEndpointPerformance.MaxSlots@">
<summary>
 Maximum number of request that can be served.
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.MaxSlots(System.Int32)">
<summary>
 Maximum number of request that can be served.
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.ExpectedLatencyInMS(System.Int32)">
 <summary>
 If we send request to this Backend, the expected processing latency (in millisecond)
 It is calculated by avgNetworkRtt + avgProcessing + ( avgQueuePerSlot * itemsInQueue )
 </summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.DefaultExpectedLatencyInMS(System.Int32)">
<summary>
 Default Expected Latency value before a reply is received 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.Curslots(System.Int32)">
<summary>
 Current number of request that is under service 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.ConstructFunc(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prajna.Service.ServiceEndpointPerformance})">
<summary>
 A functional variable used to construct ServiceEndpointPerformance
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.TotalQuery">
<summary>
 Total number of queries issued 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.OutstandingRequests">
<summary>
 Number of queries to be serviced. 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.NumFailedQuery">
<summary>
 Number of failed queries
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.NumCompletedQuery">
<summary>
 Number of completed queries 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.MaxSlots">
<summary>
 Maximum number of request that can be served.
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.ExpectedLatencyInMS">
 <summary>
 If we send request to this Backend, the expected processing latency (in millisecond)
 It is calculated by avgNetworkRtt + avgProcessing + ( avgQueuePerSlot * itemsInQueue )
 </summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.DefaultExpectedLatencyInMS">
<summary>
 Default Expected Latency value before a reply is received 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.Curslots">
<summary>
 Current number of request that is under service 
</summary>
</member>
<member name="P:Prajna.Service.ServiceEndpointPerformance.ConstructFunc">
<summary>
 A functional variable used to construct ServiceEndpointPerformance
</summary>
</member>
<member name="M:Prajna.Service.ServiceEndpointPerformance.ReplyArrived">
<summary>
 This function is called when a request/reply arrives 
</summary>
</member>
<member name="M:Prajna.Service.ServiceEndpointPerformance.RegisterRequest">
 <summary> 
 This function is called before each request is sent to backend for statistics 
 </summary>
</member>
<member name="M:Prajna.Service.ServiceEndpointPerformance.QueueInfo">
<summary>
 Show the backend queue status in string 
</summary>
</member>
<member name="M:Prajna.Service.ServiceEndpointPerformance.FailedRequest">
<summary>
 This function is called when a request fails. 
</summary>
</member>
<member name="M:Prajna.Service.ServiceEndpointPerformance.ExpectedLatencyInfo">
<summary>
 Show the expected latency of the backend in string 
</summary>
</member>
<member name="M:Prajna.Service.ServiceEndpointPerformance.DepositReply(Prajna.Service.SingleRequestPerformance)">
 <summary> 
 This function is called whenever a reply is received. For error/timeout, put a non-empty message in perfQ.Message, and call this function. 
 If perQ.Message is not null, the execution fails. 
 </summary> 
</member>
<member name="T:Prajna.Service.ServiceEndpointPerformance">
 <summary> 
 Service endpoint performance tracking, if the programer intend to track more statistics, additional
 information may be included. 
 </summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.Message@">
<summary>
 Additional Message
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.NumSlotsAvailable@">
<summary>
 Number of Slots Available
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.Capacity@">
<summary>
 Number of Pending request in queue
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.InProcessing@">
<summary>
 Time spent in processing 
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.InQueue@">
<summary>
 Time spent in queue of the query engine 
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.InNetwork@">
<summary>
 Time spent in network (including network stack)
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.InAssignment@">
<summary>
 Time spent in assignment stage, before the request is queued to network 
</summary>
</member>
<member name="F:Prajna.Service.SingleRequestPerformance.TickStart@">
<summary>
 Ticks processing start
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.TickStart(System.Int64)">
<summary>
 Ticks processing start
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.NumSlotsAvailable(System.Int32)">
<summary>
 Number of Slots Available
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.Message(System.String)">
<summary>
 Additional Message
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InQueue(System.Int32)">
<summary>
 Time spent in queue of the query engine 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InProcessing(System.Int32)">
<summary>
 Time spent in processing 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InNetwork(System.Int32)">
<summary>
 Time spent in network (including network stack)
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InAssignment(System.Int32)">
<summary>
 Time spent in assignment stage, before the request is queued to network 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.Capacity(System.Int32)">
<summary>
 Number of Pending request in queue
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.TickStart">
<summary>
 Ticks processing start
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.NumSlotsAvailable">
<summary>
 Number of Slots Available
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.Message">
<summary>
 Additional Message
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InQueue">
<summary>
 Time spent in queue of the query engine 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InProcessing">
<summary>
 Time spent in processing 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InNetwork">
<summary>
 Time spent in network (including network stack)
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.InAssignment">
<summary>
 Time spent in assignment stage, before the request is queued to network 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.Elapse">
<summary>
 Milliseconds since this structure is created. 
</summary>
</member>
<member name="P:Prajna.Service.SingleRequestPerformance.Capacity">
<summary>
 Number of Pending request in queue
</summary>
</member>
<member name="M:Prajna.Service.SingleRequestPerformance.Unpack(System.IO.Stream)">
<summary>
 Deserialize 
</summary>
</member>
<member name="M:Prajna.Service.SingleRequestPerformance.Pack(Prajna.Service.SingleRequestPerformance,System.IO.Stream)">
<summary>
 Serialize 
</summary>
</member>
<member name="M:Prajna.Service.SingleRequestPerformance.FrontEndInfo">
<summary>
 Show string that can be used to monitor frontend performance 
</summary>
</member>
<member name="M:Prajna.Service.SingleRequestPerformance.BackEndInfo">
<summary>
 Show string that can be used to monitor backend performance 
</summary>
</member>
<member name="T:Prajna.Service.SingleRequestPerformance">
<summary>
 SingleRequestPerformance gives out the performance of a single query. 
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleEntryPoint.Run">
<summary>
 void Run(): main entry point when the service is running. 
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleEntryPoint.OnStop">
<summary>
 bool OnStop(): Run once when the service stopped
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleEntryPoint.OnStartByObject(System.Object)">
<summary>
 bool OnStartByObject(): Run once when the service started
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleEntryPoint.IsRunning">
<summary>
 bool IsRunning(): return true if the service is running (should be set at OnStart), false if the service terminates.
</summary>
</member>
<member name="T:Prajna.Service.WorkerRoleEntryPoint">
 <summary>
 WorkerRoleEntryPoint can be extended to run a Prajna worker service. The worker service will extend the class WorkerRoleEntryPoint with the following functions:
 Please note that the extended class will be serialized to the remote end. It is crucial to consider the data footprint in serialization for efficient execution. 
 If you have an heavy object, consider to use WorkerRoleInstance
 </summary>
</member>
<member name="T:Prajna.Service.WorkerRoleEntryPointUnit">
 <summary>
 WorkerRoleEntryPoint can be extended to run a Prajna worker service. The worker service will extend the class WorkerRoleEntryPoint with the following functions:
 Please note that the extended class will be serialized to the remote end. It is crucial to consider the data footprint in serialization for efficient execution. 
 </summary>
</member>
<member name="M:Prajna.Service.WorkerRoleEntryPoint`1.OnStart(`0)">
<summary>
 bool OnStart(): Run once when the service started
</summary>
</member>
<member name="T:Prajna.Service.WorkerRoleEntryPoint`1">
 <summary>
 WorkerRoleEntryPoint can be extended to run a Prajna worker service. The worker service will extend the class WorkerRoleEntryPoint with the following functions:
 Please note that the extended class will be serialized to the remote end. It is crucial to consider the data footprint in serialization for efficient execution. 
 </summary>
</member>
<member name="F:Prajna.Service.WorkerRoleInstance.EvTerminated@">
<summary>
 When an instance terminates it should set EvTerminated flag so that parent instance may terminate 
</summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstance.EvTerminated">
<summary>
 When an instance terminates it should set EvTerminated flag so that parent instance may terminate 
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleInstance.Run">
<summary>
 void Run(): main entry point when the service is running,
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleInstance.OnStop">
<summary>
 bool OnStop(): Run once to stop all thread, 
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleInstance.OnStartByObject(System.Object)">
<summary>
 bool OnStart(): Run once when the service instance started for all thread, it will be runned in each thread. 
</summary>
</member>
<member name="M:Prajna.Service.WorkerRoleInstance.IsRunning">
<summary>
 bool IsRunning(): return true if the service is running (should be set at OnStart), false if the service terminates.
</summary>
</member>
<member name="T:Prajna.Service.WorkerRoleInstance">
 <summary>
 WorkerRoleInstance can be extended to run a Prajna worker service. Unlike WorkerRoleEntryPoint, WorkerRoleInstance is to be instantiated at the remote end 
 so it is class member is not serialized. 
 </summary>
</member>
<member name="T:Prajna.Service.WorkerRoleInstanceGeneric`1">
 <summary>
 WorkerRoleInstance can be extended to run a Prajna worker service. Unlike WorkerRoleEntryPoint, WorkerRoleInstance is to be instantiated at the remote end 
 so it is class member is not serialized. 
 </summary>
</member>
<member name="M:Prajna.Service.WorkerRoleInstanceService`1.OnStop">
<summary>
 Thread 0 is running on the Service thread. 
</summary>
</member>
<member name="T:Prajna.Service.WorkerRoleInstanceService`1">
 <summary>
 The code abstract running WorkerRoleInstance. The Prajna machine at remote will instantiate one WorkerRoleInstance. For the instance. 
 1. OnStart will be called once, to start the instance. 
 2. Run() will be called N times, depending on NumThreads that runs the instance. 
 3. OnStop will be called once, if the instance needed to be shutdown. 
 </summary> 
</member>
<member name="F:Prajna.Service.WorkerRoleInstanceStartParam.NewInstanceFunc@">
 <summary>
 User will need to override this function to instantiate the right front end instance to be used for service. 
 </summary>
</member>
<member name="F:Prajna.Service.WorkerRoleInstanceStartParam.ThreadCloseTimeoutInMS@">
 <summary> 
 Timeout at Thread close (in millisecond)
 </summary>
</member>
<member name="F:Prajna.Service.WorkerRoleInstanceStartParam.NumThreads@">
 <summary> 
 Number of threads of that runs WorkerRoleInstance. 
 </summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstanceStartParam.ThreadCloseTimeoutInMS(System.Int32)">
 <summary> 
 Timeout at Thread close (in millisecond)
 </summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstanceStartParam.NumThreads(System.Int32)">
 <summary> 
 Number of threads of that runs WorkerRoleInstance. 
 </summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstanceStartParam.NewInstanceFunc(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prajna.Service.WorkerRoleInstance})">
 <summary>
 User will need to override this function to instantiate the right front end instance to be used for service. 
 </summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstanceStartParam.ThreadCloseTimeoutInMS">
 <summary> 
 Timeout at Thread close (in millisecond)
 </summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstanceStartParam.NumThreads">
 <summary> 
 Number of threads of that runs WorkerRoleInstance. 
 </summary>
</member>
<member name="P:Prajna.Service.WorkerRoleInstanceStartParam.NewInstanceFunc">
 <summary>
 User will need to override this function to instantiate the right front end instance to be used for service. 
 </summary>
</member>
<member name="T:Prajna.Service.WorkerRoleInstanceStartParam">
 <summary>
 This class contains the parameter used to start a multithreaded WorkerRoleInstance. The class (and if you have derived from the class, any additional information) 
 will be serialized and send over the network to be executed on Prajna platform. Please fill in all class members that are not default. 
 </summary> 
</member>
<member name="M:Prajna.Service.WorkerRoleInstance`1.OnStart(`0)">
<summary>
 bool OnStart(): Run once when the service started for all thread, it will be runned in each thread. 
</summary>
</member>
<member name="T:Prajna.Service.WorkerRoleInstance`1">
 <summary>
 WorkerRoleInstance can be extended to run a Prajna worker service. Unlike WorkerRoleEntryPoint, WorkerRoleInstance is to be instantiated at the remote end 
 so it is class member is not serialized. 
 </summary>
</member>
<member name="T:Prajna.Service.CSharp.ContractServerInfoLocal">
<summary>
 Manifested list of servers to be used to launch services, import and export contract
 This class is a local manifestation of ContractServersInfo that is to be used. 
</summary>
</member>
<member name="T:Prajna.Service.CSharp.ContractServersInfo">
<summary>
 Specify servers to be used to launch services, import and export contract
</summary>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportSeqFunctionWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportSeqFunctionWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportSeqFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportSeqFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunctionWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunctionWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunctionTaskWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunctionTaskWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunctionTask``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunctionTask``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ImportAction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Action from both local &amp; server, with name, input parameter, if successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportSeqFunction``2(System.String,System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Int32,System.Boolean)">
 <summary>
 Export as a function Func&lt;'T,seq&lt;'TResult>>, the result can be imported and executed by Prajna data analytical pipeline. 
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="serializationLimit"> Parameter that controls granularity of serialization. If serializationLimit&lt;=0, the size is equivalent to Int32.MaxValue.
      The export function will collect an array of size serializationLimit of 'TResult[] worth of data, and then send the result to the calling function. 
 </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportSeqFunction``1(System.String,System.Func{System.Collections.Generic.IEnumerable{``0}},System.Int32,System.Boolean)">
 <summary>
 Export as a function Func&lt;seq&lt;'TResult>>, the result can be imported and executed by Prajna data analytical pipeline. 
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="serializationLimit"> Parameter that controls granularity of serialization. If serializationLimit&lt;=0, the size is equivalent to Int32.MaxValue.
      The export function will collect an array of size serializationLimit of 'TResult[] worth of data, and then send the result to the calling function. 
 </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportFunctionTask``1(System.String,System.Func{System.Threading.Tasks.Task{``0}},System.Boolean)">
 <summary>
 Export as a function that return a Task Func&lt;Task&lt;'TResult>>
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,Task&lt;'TResult>> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportFunctionTask``2(System.String,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Boolean)">
 <summary>
 Export as a function that return a Task Func&lt;'T,Task&lt;'TResult>>
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,Task&lt;'TResult>> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportFunction``1(System.String,System.Func{``0},System.Boolean)">
 <summary>
 Export as a function Func&lt;'T,'TResult>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'TResult> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportFunction``2(System.String,System.Func{``0,``1},System.Boolean)">
 <summary>
 Export as a function Func&lt;'T,'TResult>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,'TResult> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.ContractStore.ExportAction``1(System.String,System.Action{``0},System.Boolean)">
 <summary>
 Export an action Action&lt;'T>
 <param name="name"> Name of the action to be exported </param>
 <param name="act"> An action of type Action&lt;'T> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="T:Prajna.Service.CSharp.ContractStore">
 <summary>
 ContractStore provides a central location for export/import contract
 </summary>
</member>
<member name="T:Prajna.Service.CSharp.DistributedFunctionProvider">
<summary>
 Infromation of distributed Function Provider 
 To use distributed function, 
</summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.StopLocal(System.String)">
<summary>
 Stop a local instance
</summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Stop(Prajna.Service.ContractServersInfo,System.String)">
<summary>
 Stopping services on a set of servers
</summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Stop(System.String)">
 <summary>
 Stopping Service on a group of remote nodes.
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Stop(Prajna.Core.Cluster,System.String)">
 <summary>
 Stopping Service on a group of remote nodes.
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.StartLocal``1(System.String,System.Func{``0})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 Return: toStop (a function can be called to terminate the current RoleInstance). 
         isRunning ( a Func that can be called to evaluate if the current RoleInstance is still running)
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.StartLocal``2(System.String,``0,System.Func{``1})">
 <summary>
 Launching Prajna Instance locally, mainly for debuging purposes. 
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 Return: toStop (a function can be called to terminate the current RoleInstance). 
         isRunning ( a Func that can be called to evaluate if the current RoleInstance is still running)
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Start``2(Prajna.Service.ContractServersInfo,System.String,``0,System.Func{``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 serverInfo: information of the server 
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Start``1(System.String,System.Func{``0})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Start``2(System.String,``0,System.Func{``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.Start``2(Prajna.Core.Cluster,System.String,``0,System.Func{``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.CSharp.RemoteInstance.IsRunningLocal(System.String)">
<summary>
 Is a local instance still running
</summary>
</member>
<member name="T:Prajna.Service.CSharp.RemoteInstance">
 <summary>
 Launching a PrajnaInstance on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart
 serviceInstance: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
         You must derive serviceInstance from WorkerRoleInstance
 PrajnaInstance share similar characteristics with Prajnaservice, with characteristics below.
 1. You can run Service on Azure VM or your own cluster in the data center. 
 2. You can host multiple worker role in a same remote program. 
 3. Service can interact (call each other) with each call being a function call. 
 4. You can perform Big data analytical tasks (map/filter/choose/collect, fold, map-reduce, sort, hash-join, cross-join, etc.) on data generated by Service
 5. You can start Service with a parameter. 
 6. You can track debug output (log, stderr, stdout) of the remote service. 
 But in addition, PrajnaInstance is 
 1. Initialied remotely (with a function that you have specified). As such, PrajnaInstance doesn't need to be serializable, and can contain heavy data element. 
 2. You may specify the number of thread to work on the PrajnaInstance (parameter specified in Start Parameter. 
 </summary>
</member>
<member name="T:Prajna.Service.FSharp.CacheService">
 <summary>
 Running a empty service, when the service is running, cache data will be hold at remote container. 
 </summary>
</member>
<member name="T:Prajna.Service.FSharp.ContractServerInfoLocal">
<summary>
 Manifested list of servers to be used to launch services, import and export contract
 This class is a local manifestation of ContractServersInfo that is to be used. 
</summary>
</member>
<member name="T:Prajna.Service.FSharp.ContractServersInfo">
<summary>
 Specify servers to be used to launch services, import and export contract
</summary>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportSeqFunctionWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportSeqFunctionWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportSeqFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportSeqFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunctionWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunctionWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunctionTaskWithTimeout``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunctionTaskWithTimeout``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunctionTask``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunctionTask``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportFunction``2(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Function from both local &amp; server, with name, input parameter. The function has a timeout to control 
 remote execution behavior. If successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ImportAction``1(Prajna.Service.ContractServersInfo,System.String)">
 <summary> 
 Import a Action from both local &amp; server, with name, input parameter, if successfully imported, the function will be cached for faster reimporting. 
 </summary> 
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportSeqFunctionWithParam``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Collections.Generic.IEnumerable{``1}},System.Int32,System.Boolean)">
 <summary>
 Export as a function 'T -> seq&lt;'TResult>, the result can be imported and executed by Prajna data analytical pipeline. 
 F# cannot overload this function with the form unit -> seq&lt;'TResult>, we hence use name to specify the difference. 
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type 'T -> seq&lt;'TResult> to be exported </param>
 <param name="serializationLimit"> Parameter that controls granularity of serialization. If serializationLimit&lt;=0, the size is equivalent to Int32.MaxValue.
      The export function will collect an array of size serializationLimit of 'TResult[] worth of data, and then send the result to the calling function. 
 </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportSeqFunction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{``0}},System.Int32,System.Boolean)">
 <summary>
 Export as a function unit -> seq&lt;'TResult>, the result can be imported and executed by Prajna data analytical pipeline. 
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type unit -> seq&lt;'TResult> to be exported </param>
 <param name="serializationLimit"> Parameter that controls granularity of serialization. If serializationLimit&lt;=0, the size is equivalent to Int32.MaxValue.
      The export function will collect an array of size serializationLimit of 'TResult[] worth of data, and then send the result to the calling function. 
 </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportFunctionTaskWithParam``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},System.Boolean)">
 <summary>
 Export as a function that return a Task: 'T-> Task&lt;'TResult>
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,Task&lt;'TResult>> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportFunctionTask``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}},System.Boolean)">
 <summary>
 Export as a function that return a Task: unit -> Task&lt;'TResult>
 </summary>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type Func&lt;'T,Task&lt;'TResult>> to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportFunction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.Boolean)">
 <summary>
 Export as a function Func&lt;'T,'TResult>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type unit -> 'TResult to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportFunction``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Boolean)">
 <summary>
 Export as a function Func&lt;'T,'TResult>
 <param name="name"> Name of the action to be exported </param>
 <param name="func"> A function of type 'T -> 'TResult to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.ContractStore.ExportAction``1(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Boolean)">
 <summary>
 Export an action Action&lt;'T>
 <param name="name"> Name of the action to be exported </param>
 <param name="act"> An action of type 'T -> unit to be exported </param>
 <param name="bReload"> Whether allows Action reloading. If bReload is false, Prajna will throw an exception if an item of same name already exists in contract store. </param>
 </summary>
</member>
<member name="T:Prajna.Service.FSharp.ContractStore">
 <summary>
 ContractStore provides a central location for export/import contract
 </summary>
</member>
<member name="T:Prajna.Service.FSharp.DefaultSerializerForDistributedFunction">
<summary>
 Govern the behavior of the default serialization to be used 
</summary>
</member>
<member name="T:Prajna.Service.FSharp.DistributedFunctionProvider">
<summary>
 Infromation of distributed Function Provider 
 To use distributed function
</summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.StopLocal(System.String)">
<summary>
 Stop a local instance
</summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Stop(Prajna.Service.ContractServersInfo,System.String)">
<summary>
 Stopping services on a set of servers
</summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Stop(System.String)">
 <summary>
 Stopping Service on a group of remote nodes.
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Stop(Prajna.Core.Cluster,System.String)">
 <summary>
 Stopping Service on a group of remote nodes.
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.StartLocal``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Launching Instance locally. 
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 Return: toStop (a function can be called to terminate the current RoleInstance). 
         isRunning ( a Func that can be called to evaluate if the current RoleInstance is still running)
 &lt;/summary&gt;
</summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.StartLocal``2(System.String,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Instance locally. 
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 Return: toStop (a function can be called to terminate the current RoleInstance). 
         isRunning ( a Func that can be called to evaluate if the current RoleInstance is still running)
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Start``2(Prajna.Service.ContractServersInfo,System.String,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 serverInfo: information of the server 
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Start``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Start``2(System.String,Prajna.Service.WorkerRoleInstanceStartParam,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.Start``2(Prajna.Core.Cluster,System.String,``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>
 Launching Prajna Service on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart, must derive from WorkerRoleInstanceStartParam
 func: the function to initialized the WorkerRoleInstance. This function will be executed as a closure remotely. The returned class must derive from WorkerRoleInstance.
 </summary>
</member>
<member name="M:Prajna.Service.FSharp.RemoteInstance.IsRunningLocal(System.String)">
<summary>
 Is a local instance still running
</summary>
</member>
<member name="T:Prajna.Service.FSharp.RemoteInstance">
 <summary>
 Launching a PrajnaInstance on a group of remote nodes.
 serviceName: name of the serivce
 param: parameter to be called by OnStart
 serviceInstance: OnStart(param), OnStop(), Run(), IsRunning() call for the initiating of the service. 
         You must derive serviceInstance from WorkerRoleInstance
 PrajnaInstance share similar characteristics with Prajnaservice, with characteristics below.
 1. You can run Service on Azure VM or your own cluster in the data center. 
 2. You can host multiple worker role in a same remote program. 
 3. Service can interact (call each other) with each call being a function call. 
 4. You can perform Big data analytical tasks (map/filter/choose/collect, fold, map-reduce, sort, hash-join, cross-join, etc.) on data generated by Service
 5. You can start Service with a parameter. 
 6. You can track debug output (log, stderr, stdout) of the remote service. 
 But in addition, PrajnaInstance is 
 1. Initialied remotely (with a function that you have specified). As such, PrajnaInstance doesn't need to be serializable, and can contain heavy data element. 
 2. You may specify the number of thread to work on the PrajnaInstance (parameter specified in Start Parameter. 
 </summary>
</member>
<member name="T:Prajna.Service.FSharp.WorkerRoleInstance">
<summary>
 WorkerRoleInstance is extended to run a service. It is to be instantiated at the remote end so that it is class member 
 does not have the constraint to be serializable. 
 &lt;/summary&gt;
</summary>
</member>
<member name="T:Prajna.Service.FSharp.WorkerRoleInstanceStartParam">
 <summary>
 This class contains the parameter used to start a multithreaded WorkerRoleInstance. The class (and if you have derived from the class, any additional information) 
 will be serialized and send over the network to be executed on Prajna platform. Please fill in all class members that are not default. 
 </summary> 
</member>
<member name="T:Prajna.Service.FSharp.WorkerRoleInstance`1">
<summary>
 WorkerRoleInstance is extended to run a service. It is to be instantiated at the remote end so that it is class member 
 does not have the constraint to be serializable. 
 &lt;/summary&gt;
</summary>
</member>
</members>
</doc>
